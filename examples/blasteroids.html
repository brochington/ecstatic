<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ecstatic Demo: Asteroids (Working Collisions)</title>
    <style>
      body {
        font-family: sans-serif;
        background: #111;
        color: #eee;
        text-align: center;
      }

      canvas {
        background: #000;
        border: 2px solid #555;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
      }
    </style>
  </head>

  <body>
    <h1>Ecstatic Demo: Asteroids (Working Collisions)</h1>
    <p>Controls: [Arrow Keys] to move, [Space] to shoot</p>
    <canvas id="ecs-canvas"></canvas>

    <script
      type="module"
      src="https://unpkg.com/@brochington/ecstatic@0.3.0"
    ></script>
    <script type="module">
      /* -------------------------------------------------------------------------- */
      /*                               HELPER FUNCTIONS                             */
      /* -------------------------------------------------------------------------- */

      function getRandomNumber(min, max) {
        return Math.random() * (max - min) + min;
      }

      /* -------------------------------------------------------------------------- */
      /*                                    WORLD                                   */
      /* -------------------------------------------------------------------------- */

      const { World } = ecstatic;
      const world = new World();
      const CANVAS_WIDTH = 800;
      const CANVAS_HEIGHT = 600;
      const MIN_ASTEROID_RADIUS = 10;

      /* -------------------------------------------------------------------------- */
      /*                                 COMPONENTS                                 */
      /* -------------------------------------------------------------------------- */

      // --- Singleton Components ---
      class CanvasContext {
        constructor() {
          this.canvas = document.getElementById('ecs-canvas');
          this.context = this.canvas.getContext('2d');
          this.width = CANVAS_WIDTH;
          this.height = CANVAS_HEIGHT;
          this.canvas.width = this.width;
          this.canvas.height = this.height;
        }
      }

      class InputState {
        left = false;
        right = false;
        up = false;
        space = false;
        spaceReleased = true;
      }

      class GameState {
        score = 0;
      }

      // --- Entity Components ---
      class Transform {
        constructor(x, y, rotation = 0) {
          this.x = x;
          this.y = y;
          this.rotation = rotation;
          this.dx = 0;
          this.dy = 0;
        }
      }

      class Collider {
        constructor(radius) {
          this.radius = radius;
        }
      }

      class Polygon {
        constructor(points, color = 'white') {
          this.points = points;
          this.color = color;
        }
      }

      class Health {
        constructor(value) {
          this.value = value;
        }
      }

      class Expires {
        constructor(lifeInFrames) {
          this.life = lifeInFrames;
        }
      }

      class Collision {
        constructor(otherEntity) {
          this.with = otherEntity;
        }
      }

      /* -------------------------------------------------------------------------- */
      /*                                   SYSTEMS                                  */
      /* -------------------------------------------------------------------------- */

      function playerInputSystem({ world }) {
        const { component: input } = world.grab(InputState);
        const player = world.getTagged('player');
        if (!player) return;

        const transform = player.get(Transform);
        const ROTATION_SPEED = 0.05;
        const THRUST_AMOUNT = 0.1;
        const MAX_SPEED = 5;

        if (input.left) transform.rotation -= ROTATION_SPEED;
        if (input.right) transform.rotation += ROTATION_SPEED;
        if (input.up) {
          transform.dx += Math.cos(transform.rotation) * THRUST_AMOUNT;
          transform.dy += Math.sin(transform.rotation) * THRUST_AMOUNT;

          const speed = Math.sqrt(transform.dx ** 2 + transform.dy ** 2);
          if (speed > MAX_SPEED) {
            transform.dx = (transform.dx / speed) * MAX_SPEED;
            transform.dy = (transform.dy / speed) * MAX_SPEED;
          }
        }
        if (input.space && input.spaceReleased) {
          createBullet(player);
          input.spaceReleased = false;
        }
      }

      function movementSystem({ components, world }) {
        const { component: canvas } = world.grab(CanvasContext);
        const transform = components.get(Transform);

        transform.x += transform.dx;
        transform.y += transform.dy;

        if (transform.x > canvas.width) transform.x = 0;
        if (transform.x < 0) transform.x = canvas.width;
        if (transform.y > canvas.height) transform.y = 0;
        if (transform.y < 0) transform.y = canvas.height;
      }

      function bulletLifecycleSystem({ entity, components }) {
        const expires = components.get(Expires);
        expires.life -= 1;
        if (expires.life <= 0) {
          entity.destroy();
        }
      }

      function collisionSystem({ entity: entityA, world }) {
        // No need to check entities that have already been marked for collision this frame.
        if (entityA.has(Collision)) return;

        const allColliders = world.locateAll([Collider, Transform]);
        const currentIndex = allColliders.findIndex(e => e.id === entityA.id);

        for (let i = currentIndex + 1; i < allColliders.length; i++) {
          const entityB = allColliders[i];
          if (entityB.has(Collision)) continue;

          if (
            (entityA.hasTag('player') && entityB.hasTag('bullet')) ||
            (entityA.hasTag('bullet') && entityB.hasTag('player'))
          ) {
            continue;
          }

          const posA = entityA.get(Transform);
          const colA = entityA.get(Collider);
          const posB = entityB.get(Transform);
          const colB = entityB.get(Collider);

          const dx = posB.x - posA.x;
          const dy = posB.y - posA.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < colA.radius + colB.radius) {
            // Add a component to represent the collision event.
            entityA.add(new Collision(entityB));
            entityB.add(new Collision(entityA));
          }
        }
      }

      function collisionResolutionSystem({ entity, world }) {
        const collision = entity.get(Collision);
        const otherEntity = collision.with;

        const { component: gameState } = world.grab(GameState);

        const isEntityAsteroid = entity.hasTag('asteroid');
        const isOtherAsteroid = otherEntity.hasTag('asteroid');

        // Handle Bullet hitting an Asteroid
        if (entity.hasTag('bullet') && isOtherAsteroid) {
          otherEntity.get(Health).value -= 1;
          gameState.score += 10;
          entity.destroy();
        } else if (isEntityAsteroid && otherEntity.hasTag('bullet')) {
          entity.get(Health).value -= 1;
          gameState.score += 10;
          otherEntity.destroy();
        }

        // Handle Player hitting an Asteroid
        if (
          (entity.hasTag('player') && isOtherAsteroid) ||
          (isEntityAsteroid && otherEntity.hasTag('player'))
        ) {
          console.log('Game Over! Final Score:', gameState.score);
          document.location.reload();
        }

        // Important: "Consume" the collision event by removing the component.
        entity.remove(Collision);
        otherEntity.remove(Collision);
      }

      function destructionSystem({ entity, world, components }) {
        const health = components.get(Health);
        if (health.value <= 0) {
          const transform = components.get(Transform);
          const collider = components.get(Collider);
          const { component: gameState } = world.grab(GameState);

          const newRadius = collider.radius / 2;
          if (newRadius >= MIN_ASTEROID_RADIUS) {
            gameState.score += 50;
            createAsteroid(transform.x, transform.y, newRadius);
            createAsteroid(transform.x, transform.y, newRadius);
          } else {
            gameState.score += 100;
          }
          entity.destroy();
        }
      }

      function renderSystem({ world }) {
        const { component: canvas } = world.grab(CanvasContext);
        const ctx = canvas.context;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (const entity of world.locateAll([Transform, Polygon])) {
          const transform = entity.get(Transform);
          const polygon = entity.get(Polygon);

          ctx.save();
          ctx.translate(transform.x, transform.y);
          ctx.rotate(transform.rotation);
          ctx.strokeStyle = polygon.color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(polygon.points[0], polygon.points[1]);
          for (let i = 2; i < polygon.points.length; i += 2) {
            ctx.lineTo(polygon.points[i], polygon.points[i + 1]);
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }

        const { component: gameState } = world.grab(GameState);
        ctx.fillStyle = 'white';
        ctx.font = '24px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`Score: ${gameState.score}`, 20, 30);
      }

      // --- System Registration ---
      world.addSystem([InputState], playerInputSystem);
      world.addSystem([Transform], movementSystem);
      world.addSystem([Expires], bulletLifecycleSystem);
      world.addSystem([Collider, Transform], collisionSystem);
      world.addSystem([Health, Transform, Collider], destructionSystem);
      world.addSystem([Collision], collisionResolutionSystem);
      world.addSystem([CanvasContext], renderSystem);

      /* -------------------------------------------------------------------------- */
      /*                              ENTITY FACTORIES                              */
      /* -------------------------------------------------------------------------- */

      function createPlayer() {
        const shipShape = [-15, 10, 15, 0, -15, -10];
        return world
          .createEntity()
          .addTag('player')
          .add(new Transform(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, -Math.PI / 2))
          .add(new Polygon(shipShape, 'cyan'))
          .add(new Collider(15))
          .add(new Health(1));
      }

      function createAsteroid(x, y, radius) {
        const points = [];
        const sides = 10;
        for (let i = 0; i < sides; i++) {
          const angle = (i / sides) * Math.PI * 2;
          const dist = getRandomNumber(radius * 0.8, radius * 1.2);
          points.push(Math.cos(angle) * dist, Math.sin(angle) * dist);
        }
        const vel = getRandomNumber(0.5, 2);
        const angle = getRandomNumber(0, Math.PI * 2);
        const healthValue = Math.max(1, Math.floor(radius / 15));

        const asteroid = world
          .createEntity()
          .addTag('asteroid')
          .add(new Transform(x, y))
          .add(new Polygon(points, 'white'))
          .add(new Collider(radius))
          .add(new Health(healthValue));

        const transform = asteroid.get(Transform);
        transform.dx = Math.cos(angle) * vel;
        transform.dy = Math.sin(angle) * vel;
        return asteroid;
      }

      function createBullet(player) {
        const playerTransform = player.get(Transform);
        const bulletSpeed = 7;

        const startX =
          playerTransform.x + Math.cos(playerTransform.rotation) * 15;
        const startY =
          playerTransform.y + Math.sin(playerTransform.rotation) * 15;

        const bullet = world
          .createEntity()
          .addTag('bullet')
          .add(new Transform(startX, startY))
          .add(new Polygon([-2, -2, 2, -2, 2, 2, -2, 2], 'yellow'))
          .add(new Collider(2))
          .add(new Expires(90));

        const bulletTransform = bullet.get(Transform);
        bulletTransform.dx =
          Math.cos(playerTransform.rotation) * bulletSpeed + playerTransform.dx;
        bulletTransform.dy =
          Math.sin(playerTransform.rotation) * bulletSpeed + playerTransform.dy;
      }

      /* -------------------------------------------------------------------------- */
      /*                              INITIALIZE STATE                              */
      /* -------------------------------------------------------------------------- */

      world.createEntity().add(new CanvasContext());
      world.createEntity().add(new InputState());
      world.createEntity().add(new GameState());

      createPlayer();
      for (let i = 0; i < 5; i++) {
        createAsteroid(
          getRandomNumber(0, CANVAS_WIDTH),
          getRandomNumber(0, CANVAS_HEIGHT),
          40
        );
      }

      /* -------------------------------------------------------------------------- */
      /*                             USER INTERACTION                             */
      /* -------------------------------------------------------------------------- */

      const input = world.grab(InputState).component;
      window.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') input.left = true;
        if (e.key === 'ArrowRight') input.right = true;
        if (e.key === 'ArrowUp') input.up = true;
        if (e.key === ' ') input.space = true;
      });
      window.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft') input.left = false;
        if (e.key === 'ArrowRight') input.right = false;
        if (e.key === 'ArrowUp') input.up = false;
        if (e.key === ' ') {
          input.space = false;
          input.spaceReleased = true;
        }
      });

      /* -------------------------------------------------------------------------- */
      /*                                  GAME LOOP                                 */
      /* -------------------------------------------------------------------------- */

      function gameLoop() {
        world.systems.run();
        requestAnimationFrame(gameLoop);
      }

      gameLoop();
    </script>
  </body>
</html>
