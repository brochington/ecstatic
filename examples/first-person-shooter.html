<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ecstatic Demo: First-Person Shooter (Polished)</title>
  <style>
    body {
      margin: 0;
      font-family: monospace;
      background: #000;
      color: #fff;
      overflow: hidden;
    }

    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }

    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 4px;
      height: 4px;
      background-color: white;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    #hud {
      position: absolute;
      bottom: 20px;
      left: 20px;
      font-size: 24px;
      text-shadow: 1px 1px 2px black;
    }

    #game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      pointer-events: auto;
      cursor: pointer;
    }

    #game-over-screen h1 {
      font-size: 4em;
      color: #ff4444;
      margin: 0;
    }

    #game-over-screen p {
      font-size: 1.5em;
    }
  </style>
</head>

<body>
  <canvas id="ecs-canvas"></canvas>

  <div id="ui-overlay">
    <div id="crosshair"></div>
    <div id="hud">
      <div>Health: <span id="health">100</span></div>
      <div>Score: <span id="score">0</span></div>
    </div>
    <div id="game-over-screen">
      <h1>GAME OVER</h1>
      <p>Click to Restart</p>
    </div>
  </div>

  <script type="importmap">
    {
        "imports": {
            "ecstatic": "../dist/ecstatic.esm.js",
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
  <script type="module">
    import * as ecstatic from 'ecstatic';
    import * as THREE from 'three';
    import {
      PointerLockControls
    } from 'three/addons/controls/PointerLockControls.js';

    const {
      World
    } = ecstatic;
    const world = new World();
    const sceneSize = 100;

    /* -------------------------------------------------------------------------- */
    /*                               HELPER FUNCTIONS                             */
    /* -------------------------------------------------------------------------- */

    function getRandomNumber(min, max) {
      return Math.random() * (max - min) + min;
    }

    /* -------------------------------------------------------------------------- */
    /*                                 RESOURCES                                  */
    /* -------------------------------------------------------------------------- */

    class ThreeScene {
      constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById('ecs-canvas'),
          antialias: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        this.scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 50, 50);
        this.scene.add(dirLight);
      }
    }


    class Controls {
      constructor(camera, canvas) {
        this.pointerLock = new PointerLockControls(camera, canvas);
      }
    }

    class InputState {
      forward = false;
      backward = false;
      left = false;
      right = false;
      shoot = false;
      shootReleased = true;
    }

    class GameConfig {
      maxEnemies = 8;
      enemySpawnRate = 240;
      healthPackSpawnRate = 600;
    }

    /* -------------------------------------------------------------------------- */
    /*                                 COMPONENTS                                 */
    /* -------------------------------------------------------------------------- */

    class GameState {
      score = 0;
      isGameOver = false;
      enemySpawnTimer = 0;
      healthPackSpawnTimer = 300;
    }

    class ThreeObject {
      constructor(mesh) {
        this.mesh = mesh;
      }
    }

    class Velocity extends THREE.Vector3 { }

    class Collider {
      constructor(boundingBox) {
        this.box = boundingBox;
      }
    }

    class Health {
      constructor(value, maxValue) {
        this.value = value;
        this.maxValue = maxValue;
      }
    }

    class Expires {
      constructor(lifeInFrames) {
        this.life = lifeInFrames;
      }
    }

    class EnemyAI {
      constructor(shootCooldown = 180) {
        this.shootCooldown = shootCooldown;
        this.timer = Math.random() * shootCooldown;
        this.moveTimer = 0;
        this.moveCooldown = 60;
        this.targetPosition = new THREE.Vector3();
        this.avoidanceForce = new THREE.Vector3();
      }
    }

    class Projectile {
      constructor(firedBy) {
        this.firedBy = firedBy;
      }
    }

    class HealthPack {
      constructor() {
        this.bobTimer = 0;
        this.bobOffset = 0;
      }
    }

    const Player = 'player';
    const Enemy = 'enemy';
    const Bullet = 'bullet';
    const Obstacle = 'obstacle';
    const Particle = 'particle';

    /* -------------------------------------------------------------------------- */
    /*                                   EVENTS                                   */
    /* -------------------------------------------------------------------------- */

    class CollisionEvent {
      constructor(entityA, entityB) {
        this.entityA = entityA;
        this.entityB = entityB;
      }
    }

    class PlayerDamagedEvent { }
    class PlayerHealedEvent {
      constructor(packEntity) {
        this.packEntity = packEntity;
      }
    }
    class PlayerDeathEvent { }

    /* -------------------------------------------------------------------------- */
    /*                                   SYSTEMS                                  */
    /* -------------------------------------------------------------------------- */

    function playerMovementSystem({
      world
    }) {
      const input = world.getResource(InputState);
      const playerEntity = world.getTagged(Player);
      const controls = world.getResource(Controls);
      if (!input || !playerEntity || !controls) return;

      const velocity = playerEntity.get(Velocity);
      const threeObject = playerEntity.get(ThreeObject);

      velocity.y -= 0.01;
      velocity.x *= 0.95;
      velocity.z *= 0.95;

      const speed = 0.02;
      const direction = new THREE.Vector3();
      const camera = controls.pointerLock.getObject();

      if (input.forward) {
        camera.getWorldDirection(direction);
        velocity.add(direction.multiplyScalar(speed));
      }
      if (input.backward) {
        camera.getWorldDirection(direction);
        velocity.sub(direction.multiplyScalar(speed));
      }
      if (input.right) {
        direction.setFromMatrixColumn(camera.matrix, 0);
        velocity.add(direction.multiplyScalar(speed));
      }
      if (input.left) {
        direction.setFromMatrixColumn(camera.matrix, 0);
        velocity.sub(direction.multiplyScalar(speed));
      }

      const maxSpeed = 0.2;
      if (new THREE.Vector2(velocity.x, velocity.z).length() > maxSpeed) {
        const yVel = velocity.y;
        velocity.y = 0;
        velocity.normalize().multiplyScalar(maxSpeed);
        velocity.y = yVel;
      }

      threeObject.mesh.position.add(velocity);

      // --- NEW: Boundary Clamping ---
      const halfSize = sceneSize / 2;
      const playerRadius = 0.5; // A small buffer for player size
      threeObject.mesh.position.x = THREE.MathUtils.clamp(threeObject.mesh.position.x, -halfSize + playerRadius, halfSize - playerRadius);
      threeObject.mesh.position.z = THREE.MathUtils.clamp(threeObject.mesh.position.z, -halfSize + playerRadius, halfSize - playerRadius);


      if (threeObject.mesh.position.y < 1.7) {
        threeObject.mesh.position.y = 1.7;
        velocity.y = 0;
      }
    }


    function playerShootingSystem({
      world
    }) {
      const input = world.getResource(InputState);
      const player = world.getTagged(Player);
      const controls = world.getResource(Controls);

      if (!input || !player || !controls || !input.shoot || !input.shootReleased) return;

      const camera = controls.pointerLock.getObject();
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);

      const startPosition = new THREE.Vector3();
      camera.getWorldPosition(startPosition).add(direction.clone().multiplyScalar(1.5));

      createBullet(world, startPosition, direction, Player);
      createMuzzleFlash(world, startPosition, direction);

      input.shootReleased = false;
    }

    function enemyAISystem({
      world,
      components
    }) {
      const ai = components.get(EnemyAI);
      const enemyObj = components.get(ThreeObject);
      const velocity = components.get(Velocity);
      const player = world.getTagged(Player);
      if (!player) return;

      const playerObj = player.get(ThreeObject);
      enemyObj.mesh.lookAt(playerObj.mesh.position);

      ai.timer--;
      if (ai.timer <= 0) {
        const startPosition = enemyObj.mesh.position.clone();
        const direction = playerObj.mesh.position.clone().sub(startPosition).normalize();
        createBullet(world, startPosition, direction, Enemy);
        ai.timer = ai.shootCooldown + getRandomNumber(-30, 30);
      }

      ai.moveTimer--;
      if (ai.moveTimer <= 0) {
        const distanceFromPlayer = getRandomNumber(5, 15);
        const angle = Math.random() * Math.PI * 2;
        ai.targetPosition.copy(playerObj.mesh.position);
        ai.targetPosition.x += Math.cos(angle) * distanceFromPlayer;
        ai.targetPosition.z += Math.sin(angle) * distanceFromPlayer;
        ai.targetPosition.y = 1;
        ai.moveTimer = ai.moveCooldown;
      }

      const directionToTarget = ai.targetPosition.clone().sub(enemyObj.mesh.position);
      const distanceToTarget = directionToTarget.length();

      if (distanceToTarget > 1) {
        directionToTarget.normalize().multiplyScalar(0.015);
        velocity.x += directionToTarget.x;
        velocity.z += directionToTarget.z;
      }

      velocity.x *= 0.9;
      velocity.z *= 0.9;

      const obstacles = world.getAllTagged(Obstacle);
      ai.avoidanceForce.set(0, 0, 0);

      for (const obstacle of obstacles) {
        const obstaclePos = obstacle.get(ThreeObject).mesh.position;
        const distance = enemyObj.mesh.position.distanceTo(obstaclePos);

        if (distance < 3) {
          const avoidDir = enemyObj.mesh.position.clone().sub(obstaclePos).normalize();
          const strength = (3 - distance) / 3;
          ai.avoidanceForce.add(avoidDir.multiplyScalar(strength * 0.05));
        }
      }

      velocity.add(ai.avoidanceForce);
    }

    function movementSystem({
      components
    }) {
      const velocity = components.get(Velocity);
      const threeObject = components.get(ThreeObject);
      threeObject.mesh.position.add(velocity);
    }

    function particleMovementSystem({
      components
    }) {
      const velocity = components.get(Velocity);
      velocity.y -= 0.005;
      velocity.multiplyScalar(0.98);
    }

    function healthPackAnimationSystem({
      components
    }) {
      const healthPack = components.get(HealthPack);
      const threeObject = components.get(ThreeObject);

      healthPack.bobTimer += 0.05;
      healthPack.bobOffset = Math.sin(healthPack.bobTimer) * 0.2;
      threeObject.mesh.position.y = 1 + healthPack.bobOffset;

      threeObject.mesh.rotation.y += 0.02;
    }


    function lifecycleSystem({
      entity,
      components
    }) {
      const expires = components.get(Expires);
      expires.life--;
      if (expires.life <= 0) {
        entity.destroy();
      }
    }

    function updateCollidersSystem({
      entity,
      components
    }) {
      if (entity.hasTag(Player)) return;

      const threeObject = components.get(ThreeObject);
      const collider = components.get(Collider);
      collider.box.setFromObject(threeObject.mesh);
    }

    function updatePlayerColliderSystem({
      world
    }) {
      const player = world.getTagged(Player);
      if (!player) return;

      const threeObject = player.get(ThreeObject);
      const collider = player.get(Collider);

      const playerPosition = threeObject.mesh.position;
      collider.box.setFromCenterAndSize(
        playerPosition,
        new THREE.Vector3(1, 2, 1)
      );
    }

    function entityObstacleCollisionSystem({
      world
    }) {
      const obstacles = world.getAllTagged(Obstacle);

      // Handle player collision with obstacles
      const player = world.getTagged(Player);
      if (player && player.state === 'created') {
        const playerCollider = player.get(Collider);
        const playerObject = player.get(ThreeObject);

        for (const obstacle of obstacles) {
          const obstacleCollider = obstacle.get(Collider);
          if (playerCollider.box.intersectsBox(obstacleCollider.box)) {
            const playerBox = playerCollider.box;
            const obstacleBox = obstacleCollider.box;

            // Calculate overlap on each axis
            const overlapX = Math.min(playerBox.max.x, obstacleBox.max.x) - Math.max(playerBox.min.x, obstacleBox.min.x);
            const overlapZ = Math.min(playerBox.max.z, obstacleBox.max.z) - Math.max(playerBox.min.z, obstacleBox.min.z);

            if (Math.abs(overlapX) < Math.abs(overlapZ)) {
              const sign = Math.sign(playerObject.mesh.position.x - obstacle.get(ThreeObject).mesh.position.x);
              playerObject.mesh.position.x += overlapX * sign;
            } else {
              const sign = Math.sign(playerObject.mesh.position.z - obstacle.get(ThreeObject).mesh.position.z);
              playerObject.mesh.position.z += overlapZ * sign;
            }
          }
        }
      }

      // Handle enemy collision with obstacles
      const enemies = world.locateAll([EnemyAI, ThreeObject, Collider]);
      for (const enemy of enemies) {
        if (enemy.state !== 'created') continue;

        const enemyCollider = enemy.get(Collider);
        const enemyObject = enemy.get(ThreeObject);

        for (const obstacle of obstacles) {
          const obstacleCollider = obstacle.get(Collider);
          if (enemyCollider.box.intersectsBox(obstacleCollider.box)) {
            const enemyBox = enemyCollider.box;
            const obstacleBox = obstacleCollider.box;

            // Calculate overlap on each axis
            const overlapX = Math.min(enemyBox.max.x, obstacleBox.max.x) - Math.max(enemyBox.min.x, obstacleBox.min.x);
            const overlapZ = Math.min(enemyBox.max.z, obstacleBox.max.z) - Math.max(enemyBox.min.z, obstacleBox.min.z);

            if (Math.abs(overlapX) < Math.abs(overlapZ)) {
              const sign = Math.sign(enemyObject.mesh.position.x - obstacle.get(ThreeObject).mesh.position.x);
              enemyObject.mesh.position.x += overlapX * sign;
            } else {
              const sign = Math.sign(enemyObject.mesh.position.z - obstacle.get(ThreeObject).mesh.position.z);
              enemyObject.mesh.position.z += overlapZ * sign;
            }
          }
        }
      }
    }


    function collisionSystem({
      world
    }) {
      const bullets = world.locateAll([Projectile, Collider]);
      const enemies = world.locateAll([EnemyAI, Collider]);
      const obstacles = world.getAllTagged(Obstacle);
      const healthPacks = world.locateAll([HealthPack]);
      const player = world.getTagged(Player);

      for (const bullet of bullets) {
        if (bullet.state !== 'created') continue;
        const bulletCollider = bullet.get(Collider);
        const projectile = bullet.get(Projectile);

        if (projectile.firedBy === Enemy && player && player.state === 'created') {
          const playerCollider = player.get(Collider);
          if (bulletCollider.box.intersectsBox(playerCollider.box)) {
            world.events.emit(new CollisionEvent(bullet, player));
            continue;
          }
        }

        if (projectile.firedBy === Player) {
          for (const enemy of enemies) {
            if (enemy.state !== 'created') continue;
            const enemyCollider = enemy.get(Collider);
            if (bulletCollider.box.intersectsBox(enemyCollider.box)) {
              world.events.emit(new CollisionEvent(bullet, enemy));
              break;
            }
          }
        }

        for (const obstacle of obstacles) {
          const obstacleCollider = obstacle.get(Collider);
          if (bulletCollider.box.intersectsBox(obstacleCollider.box)) {
            bullet.destroy();
            break;
          }
        }
      }

      if (player && player.state === 'created') {
        const playerCollider = player.get(Collider);
        for (const pack of healthPacks) {
          const packCollider = pack.get(Collider);
          if (playerCollider.box.intersectsBox(packCollider.box)) {
            world.events.emit(new PlayerHealedEvent(pack));
          }
        }
      }
    }

    function deathSystem({
      world,
      entity,
      components
    }) {
      if (entity.state !== 'created') return;

      const health = components.get(Health);
      if (health.value <= 0) {
        if (entity.hasTag(Player)) {
          world.events.emit(new PlayerDeathEvent());
        } else if (entity.hasTag(Enemy)) {
          const gameStateEntity = world.locate(GameState);
          if (gameStateEntity) {
            const gameState = gameStateEntity.get(GameState);
            gameState.score += 100;
          }
          const position = entity.get(ThreeObject).mesh.position;
          createExplosion(world, position, 0xff4444);
        }
        entity.destroy();
      }
    }

    function damageSystem({
      event: collision,
      world
    }) {
      const {
        entityA: bullet,
        entityB: target
      } = collision;

      if (bullet.state !== 'created' || target.state !== 'created') return;

      if (target.has(Health)) {
        const targetHealth = target.get(Health);
        targetHealth.value -= 15;
        if (target.hasTag(Player)) {
          world.events.emit(new PlayerDamagedEvent());
        }
      }

      const position = bullet.get(ThreeObject).mesh.position;
      createExplosion(world, position, 0xffffff, 5);
      bullet.destroy();
    }


    function gameOverSystem({
      world
    }) {
      const gameStateEntity = world.locate(GameState);
      if (!gameStateEntity) return;
      const gameState = gameStateEntity.get(GameState);

      const controls = world.getResource(Controls);
      if (!gameState || !controls) return;

      gameState.isGameOver = true;
      controls.pointerLock.unlock();
      document.getElementById('game-over-screen').style.display = 'flex';
    }

    function crosshairSystem({
      world
    }) {
      const controls = world.getResource(Controls);
      const crosshair = document.getElementById('crosshair');
      if (!controls || !crosshair) return;

      const camera = controls.pointerLock.getObject();
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

      const enemies = world.getAllTagged(Enemy);
      let aimingAtEnemy = false;

      for (const enemy of enemies) {
        const enemyMesh = enemy.get(ThreeObject).mesh;
        const intersects = raycaster.intersectObject(enemyMesh);

        if (intersects.length > 0 && intersects[0].distance < 30) {
          aimingAtEnemy = true;
          break;
        }
      }

      if (aimingAtEnemy) {
        crosshair.style.width = '6px';
        crosshair.style.height = '6px';
        crosshair.style.backgroundColor = '#ff4444';
        crosshair.style.boxShadow = '0 0 4px #ff4444';
      } else {
        crosshair.style.width = '4px';
        crosshair.style.height = '4px';
        crosshair.style.backgroundColor = 'white';
        crosshair.style.boxShadow = 'none';
      }
    }

    function uiRenderSystem({
      world
    }) {
      const gameStateEntity = world.locate(GameState);
      if (!gameStateEntity) return;
      const gameState = gameStateEntity.get(GameState);
      const player = world.getTagged(Player);

      document.getElementById('score').innerText = gameState.score;
      if (player && player.has(Health)) {
        document.getElementById('health').innerText = player.get(Health).value;
      } else {
        document.getElementById('health').innerText = 0;
      }
    }

    function rendererSystem({
      world
    }) {
      const threeScene = world.getResource(ThreeScene);
      if (!threeScene) return;
      threeScene.renderer.render(threeScene.scene, threeScene.camera);
    }


    function cleanupSystem({
      world
    }) {
      const threeScene = world.getResource(ThreeScene);
      if (!threeScene) return;

      for (const entity of world.entities.values()) {
        if (entity.state === 'destroying') {
          if (entity.has(ThreeObject)) {
            const threeObject = entity.get(ThreeObject);
            threeScene.scene.remove(threeObject.mesh);
            if (threeObject.mesh.geometry) threeObject.mesh.geometry.dispose();
            if (threeObject.mesh.material) threeObject.mesh.material.dispose();
          }
          entity.destroyImmediately();
        }
      }
    }

    function enemySpawnerSystem({
      world,
      components
    }) {
      const gameState = components.get(GameState);
      const gameConfig = world.getResource(GameConfig);
      const currentEnemies = world.locateAll([EnemyAI]).length;

      if (currentEnemies < gameConfig.maxEnemies) {
        gameState.enemySpawnTimer--;
        if (gameState.enemySpawnTimer <= 0) {
          spawnEnemy(world);
          gameState.enemySpawnTimer = gameConfig.enemySpawnRate;
        }
      }
    }

    function healthPackSpawnerSystem({
      world,
      components
    }) {
      const gameState = components.get(GameState);
      const gameConfig = world.getResource(GameConfig);
      const currentPacks = world.locateAll([HealthPack]).length;

      if (currentPacks < 1) {
        gameState.healthPackSpawnTimer--;
        if (gameState.healthPackSpawnTimer <= 0) {
          spawnHealthPack(world);
          gameState.healthPackSpawnTimer = gameConfig.healthPackSpawnRate;
        }
      }
    }

    /* -------------------------------------------------------------------------- */
    /*                           SYSTEM REGISTRATION                            */
    /* -------------------------------------------------------------------------- */

    world.setPhaseOrder(['Input', 'Logic', 'Events', 'Render', 'Cleanup']);

    world.addSystem([GameState], playerMovementSystem, {
      phase: 'Input'
    });
    world.addSystem([GameState], playerShootingSystem, {
      phase: 'Input'
    });

    world.addSystem([GameState], enemySpawnerSystem, {
      phase: 'Logic'
    });
    world.addSystem([GameState], healthPackSpawnerSystem, {
      phase: 'Logic'
    });
    world.addSystem([Expires], lifecycleSystem, {
      phase: 'Logic'
    });
    world.addSystem([Collider, ThreeObject], updateCollidersSystem, {
      phase: 'Logic'
    });
    world.addSystem([GameState], updatePlayerColliderSystem, {
      phase: 'Logic'
    });
    world.addSystem([GameState], entityObstacleCollisionSystem, {
      phase: 'Logic'
    });
    world.addSystem([GameState], collisionSystem, {
      phase: 'Logic'
    });
    world.addSystem([Velocity, ThreeObject], movementSystem, {
      phase: 'Logic'
    });
    world.addSystem([Velocity, Particle], particleMovementSystem, {
      phase: 'Logic'
    });
    world.addSystem([HealthPack, ThreeObject], healthPackAnimationSystem, {
      phase: 'Logic'
    });
    world.addSystem([EnemyAI, ThreeObject, Velocity], enemyAISystem, {
      phase: 'Logic'
    });
    world.addSystem([Health], deathSystem, {
      phase: 'Logic'
    });

    world.addSystemListener(CollisionEvent, damageSystem, {
      phase: 'Events'
    });
    world.addSystemListener(PlayerDeathEvent, gameOverSystem, {
      phase: 'Events'
    });

    world.addSystem([GameState], uiRenderSystem, {
      phase: 'Render'
    });
    world.addSystem([GameState], crosshairSystem, {
      phase: 'Render'
    });
    // world.addSystem([GameState], splatterFadeSystem, {
    //   phase: 'Render'
    // });
    world.addSystem([GameState], rendererSystem, {
      phase: 'Render'
    });

    world.addSystem([GameState], cleanupSystem, {
      phase: 'Cleanup'
    });


    /* -------------------------------------------------------------------------- */
    /*                               INITIALIZATION                               */
    /* -------------------------------------------------------------------------- */

    function createExplosion(world, position, color, count = 20) {
      const threeScene = world.getResource(ThreeScene);
      if (!threeScene) return;

      for (let i = 0; i < count; i++) {
        const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const mat = new THREE.MeshBasicMaterial({
          color
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(position);
        threeScene.scene.add(mesh);

        const velocity = new Velocity(
          getRandomNumber(-0.2, 0.2),
          getRandomNumber(0.1, 0.3),
          getRandomNumber(-0.2, 0.2)
        );
        world.createEntity()
          .add(new ThreeObject(mesh))
          .add(velocity)
          .add(new Expires(60))
          .addTag(Particle);
      }
    }


    function createBullet(world, position, direction, firedByTag) {
      const threeScene = world.getResource(ThreeScene);
      if (!threeScene) return;

      const isPlayerBullet = firedByTag === Player;
      const color = isPlayerBullet ? 0x00ffff : 0xff00ff;

      const geo = new THREE.SphereGeometry(0.1, 8, 8);
      const mat = new THREE.MeshPhongMaterial({
        color,
        emissive: color,
        emissiveIntensity: 1
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(position);

      const light = new THREE.PointLight(color, 1, 10);
      mesh.add(light);

      const velocity = direction.clone().multiplyScalar(1.5);
      const collider = new Collider(new THREE.Box3().setFromObject(mesh));

      threeScene.scene.add(mesh);

      world.createEntity()
        .add(new ThreeObject(mesh))
        .add(new Velocity(velocity.x, velocity.y, velocity.z))
        .add(collider)
        .add(new Expires(180))
        .add(new Projectile(firedByTag))
        .addTag(Bullet);
    }

    function createMuzzleFlash(world, position, direction) {
      const threeScene = world.getResource(ThreeScene);
      if (!threeScene) return;

      for (let i = 0; i < 3; i++) {
        const geo = new THREE.SphereGeometry(0.05 + Math.random() * 0.1, 6, 6);
        const mat = new THREE.MeshBasicMaterial({
          color: 0xffff00,
          transparent: true,
          opacity: 0.8
        });
        const mesh = new THREE.Mesh(geo, mat);

        const flashPos = position.clone().add(direction.clone().multiplyScalar(0.2));
        flashPos.add(new THREE.Vector3(
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2
        ));
        mesh.position.copy(flashPos);

        threeScene.scene.add(mesh);

        const velocity = direction.clone().multiplyScalar(0.02);
        velocity.add(new THREE.Vector3(
          (Math.random() - 0.5) * 0.01,
          (Math.random() - 0.5) * 0.01,
          (Math.random() - 0.5) * 0.01
        ));

        world.createEntity()
          .add(new ThreeObject(mesh))
          .add(new Velocity(velocity.x, velocity.y, velocity.z))
          .add(new Expires(8))
          .addTag(Particle);
      }
    }

    function spawnEnemy(world) {
      const threeScene = world.getResource(ThreeScene);
      if (!threeScene) return;

      const obstacles = world.getAllTagged(Obstacle);
      const player = world.getTagged(Player);
      let position = new THREE.Vector3();
      let validPosition = false;
      let attempts = 0;

      while (!validPosition && attempts < 50) {
        position.set(
          getRandomNumber(-sceneSize / 2 + 2, sceneSize / 2 - 2),
          1,
          getRandomNumber(-sceneSize / 2 + 2, sceneSize / 2 - 2)
        );

        if (player) {
          const playerPos = player.get(ThreeObject).mesh.position;
          if (position.distanceTo(playerPos) < 8) {
            attempts++;
            continue;
          }
        }

        validPosition = true;
        const testBox = new THREE.Box3().setFromCenterAndSize(position, new THREE.Vector3(1.6, 2, 1.6));

        for (const obstacle of obstacles) {
          const obstacleCollider = obstacle.get(Collider);
          if (testBox.intersectsBox(obstacleCollider.box)) {
            validPosition = false;
            break;
          }
        }

        attempts++;
      }

      if (!validPosition) {
        position.set(
          getRandomNumber(-sceneSize / 2 + 2, sceneSize / 2 - 2),
          1,
          getRandomNumber(-sceneSize / 2 + 2, sceneSize / 2 - 2)
        );
      }

      const enemyGeo = new THREE.IcosahedronGeometry(0.8, 0);
      const enemyMat = new THREE.MeshPhongMaterial({
        color: 0xff4444
      });
      const enemyMesh = new THREE.Mesh(enemyGeo, enemyMat);
      enemyMesh.position.copy(position);
      threeScene.scene.add(enemyMesh);

      world.createEntity()
        .add(new ThreeObject(enemyMesh))
        .add(new Velocity())
        .add(new Collider(new THREE.Box3().setFromObject(enemyMesh)))
        .add(new Health(30))
        .add(new EnemyAI())
        .addTag(Enemy);
    }

    function spawnHealthPack(world) {
      const threeScene = world.getResource(ThreeScene);
      if (!threeScene) return;

      const packGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const packMat = new THREE.MeshPhongMaterial({
        color: 0x00ff00
      });
      const packMesh = new THREE.Mesh(packGeo, packMat);

      packMesh.position.set(
        getRandomNumber(-sceneSize / 2 + 5, sceneSize / 2 - 5),
        1,
        getRandomNumber(-sceneSize / 2 + 5, sceneSize / 2 - 5)
      );
      threeScene.scene.add(packMesh);

      world.createEntity()
        .add(new ThreeObject(packMesh))
        .add(new Collider(new THREE.Box3().setFromObject(packMesh)))
        .add(new HealthPack());
    }

    function createStarfield(scene) {
      const vertices = [];
      for (let i = 0; i < 10000; i++) {
        const x = THREE.MathUtils.randFloatSpread(2000);
        const y = THREE.MathUtils.randFloatSpread(2000);
        const z = THREE.MathUtils.randFloatSpread(2000);
        vertices.push(x, y, z);
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      const material = new THREE.PointsMaterial({
        color: 0x888888,
        size: 0.2
      });
      const stars = new THREE.Points(geometry, material);
      scene.add(stars);
    }

    function createBoundaryWalls(world, threeScene) {
      const wallThickness = 2;
      const wallHeight = 10;
      const halfSize = sceneSize / 2;
      const wallMaterial = new THREE.MeshPhongMaterial({
        color: 0x555555,
        transparent: true,
        opacity: 0.2
      });

      const wallPositions = [{
        size: [sceneSize + wallThickness, wallHeight, wallThickness],
        pos: [0, wallHeight / 2, -halfSize]
      }, {
        size: [sceneSize + wallThickness, wallHeight, wallThickness],
        pos: [0, wallHeight / 2, halfSize]
      }, {
        size: [wallThickness, wallHeight, sceneSize + wallThickness],
        pos: [-halfSize, wallHeight / 2, 0]
      }, {
        size: [wallThickness, wallHeight, sceneSize + wallThickness],
        pos: [halfSize, wallHeight / 2, 0]
      },];

      for (const wall of wallPositions) {
        const wallGeo = new THREE.BoxGeometry(...wall.size);
        const wallMesh = new THREE.Mesh(wallGeo, wallMaterial);
        wallMesh.position.set(...wall.pos);
        threeScene.scene.add(wallMesh);

        world.createEntity()
          .add(new ThreeObject(wallMesh))
          .add(new Collider(new THREE.Box3().setFromObject(wallMesh)))
          .addTag(Obstacle);
      }
    }


    function initializeGame() {
      const threeScene = new ThreeScene();
      world.setResource(threeScene);
      world.setResource(new Controls(threeScene.camera, threeScene.renderer.domElement));
      world.setResource(new InputState());
      world.setResource(new GameConfig());
      world.createEntity().add(new GameState());

      createStarfield(threeScene.scene);
      createBoundaryWalls(world, threeScene);

      const groundGeo = new THREE.PlaneGeometry(sceneSize, sceneSize);
      const groundMat = new THREE.MeshPhongMaterial({
        color: 0x333333,
        depthWrite: false
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      threeScene.scene.add(ground);

      // Add ground as an obstacle to prevent entities from falling through
      // Create a proper bounding box for the ground plane
      const groundBox = new THREE.Box3(
        new THREE.Vector3(-sceneSize/2, -0.5, -sceneSize/2),
        new THREE.Vector3(sceneSize/2, 0.5, sceneSize/2)
      );
      world.createEntity()
        .add(new ThreeObject(ground))
        .add(new Collider(groundBox))
        .addTag(Obstacle);

      for (let i = 0; i < 20; i++) {
        const size = getRandomNumber(2, 8);
        const boxGeo = new THREE.BoxGeometry(size, size, size);
        const boxMat = new THREE.MeshPhongMaterial({
          color: 0x888888
        });
        const box = new THREE.Mesh(boxGeo, boxMat);
        box.position.set(
          getRandomNumber(-sceneSize / 2, sceneSize / 2),
          size / 2,
          getRandomNumber(-sceneSize / 2, sceneSize / 2)
        );
        threeScene.scene.add(box);
        world.createEntity()
          .add(new ThreeObject(box))
          .add(new Collider(new THREE.Box3().setFromObject(box)))
          .addTag(Obstacle);
      }

      const playerContainer = new THREE.Object3D();
      playerContainer.position.set(0, 1.7, 0);
      threeScene.scene.add(playerContainer);
      threeScene.camera.position.set(0, 0, 0);
      playerContainer.add(threeScene.camera);

      const playerCollider = new Collider(new THREE.Box3().setFromCenterAndSize(
        new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 2, 1))
      );

      world.createEntity()
        .add(new ThreeObject(playerContainer))
        .add(new Velocity())
        .add(new Health(100, 100))
        .add(playerCollider)
        .addTag(Player);
    }

    /* -------------------------------------------------------------------------- */
    /*                                INPUT HANDLING                              */
    /* -------------------------------------------------------------------------- */
    function setupInput() {
      const gameOverScreen = document.getElementById('game-over-screen');

      // Remove existing event listeners to prevent duplicates after reset
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('keyup', handleKeyUp);
      document.removeEventListener('mousedown', handleMouseDown);
      document.removeEventListener('mouseup', handleMouseUp);

      // Define event handlers that fetch resources dynamically
      function handleKeyDown(e) {
        const input = world.getResource(InputState);
        if (!input) return;
        if (e.key === 'w' || e.key === 'ArrowUp') input.forward = true;
        if (e.key === 's' || e.key === 'ArrowDown') input.backward = true;
        if (e.key === 'a' || e.key === 'ArrowLeft') input.left = true;
        if (e.key === 'd' || e.key === 'ArrowRight') input.right = true;
      }

      function handleKeyUp(e) {
        const input = world.getResource(InputState);
        if (!input) return;
        if (e.key === 'w' || e.key === 'ArrowUp') input.forward = false;
        if (e.key === 's' || e.key === 'ArrowDown') input.backward = false;
        if (e.key === 'a' || e.key === 'ArrowLeft') input.left = false;
        if (e.key === 'd' || e.key === 'ArrowRight') input.right = false;
      }

      function handleMouseDown() {
        const input = world.getResource(InputState);
        const controls = world.getResource(Controls);
        const gameStateEntity = world.locate(GameState);
        if (!input || !controls || !gameStateEntity) return;
        const gameState = gameStateEntity.get(GameState);

        if (controls.pointerLock.isLocked) {
          input.shoot = true;
        } else if (!gameState.isGameOver) {
          controls.pointerLock.lock();
        }
      }

      function handleMouseUp() {
        const input = world.getResource(InputState);
        if (!input) return;
        input.shoot = false;
        input.shootReleased = true;
      }

      // Add event listeners
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      document.addEventListener('mousedown', handleMouseDown);
      document.addEventListener('mouseup', handleMouseUp);

      window.addEventListener('resize', () => {
        const threeScene = world.getResource(ThreeScene);
        if (!threeScene) return;
        threeScene.camera.aspect = window.innerWidth / window.innerHeight;
        threeScene.camera.updateProjectionMatrix();
        threeScene.renderer.setSize(window.innerWidth, window.innerHeight);

        const splatter = world.getResource(SplatterCanvas);
        if (splatter) {
          splatter.canvas.width = window.innerWidth;
          splatter.canvas.height = window.innerHeight;
        }
      });

      gameOverScreen.addEventListener('click', () => {
        const gameStateEntity = world.locate(GameState);
        if (!gameStateEntity) return;
        const gameState = gameStateEntity.get(GameState);
        if (gameState.isGameOver) {
          resetGame();
        }
      });
    }

    /* -------------------------------------------------------------------------- */
    /*                                  GAME LOGIC                                */
    /* -------------------------------------------------------------------------- */

    function resetGame() {
      // Destroy all entities immediately
      world.entities.forEach(entity => entity.destroyImmediately());

      // Clear resources
      world.removeResource(ThreeScene);
      world.removeResource(Controls);
      world.removeResource(InputState);
      world.removeResource(GameConfig);

      document.getElementById('game-over-screen').style.display = 'none';
      document.getElementById('health').textContent = '100';
      document.getElementById('score').textContent = '0';

      initializeGame();
      setupInput();

      // Re-lock the pointer for the new game
      const controls = world.getResource(Controls);
      if (controls) {
        controls.pointerLock.lock();
      }
    }


    world.addSystemListener(PlayerHealedEvent, ({
      event
    }) => {
      const player = world.getTagged(Player);
      if (!player) return;

      const health = player.get(Health);
      health.value = Math.min(health.maxValue, health.value + 50);

      event.packEntity.destroy();

    }, {
      phase: 'Events'
    });


    function gameLoop() {
      const gameStateEntity = world.locate(GameState);
      if (gameStateEntity) {
        const gameState = gameStateEntity.get(GameState);
        if (gameState.isGameOver) {
          rendererSystem({
            world
          });
          uiRenderSystem({
            world
          });
        } else {
          world.systems.run();
        }
      }
      requestAnimationFrame(gameLoop);
    }

    initializeGame();
    setupInput();
    gameLoop();
  </script>
</body>

</html>