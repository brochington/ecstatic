!function(Q,B){"object"==typeof exports&&"object"==typeof module?module.exports=B():"function"==typeof define&&define.amd?define("ecstatic",[],B):"object"==typeof exports?exports.ecstatic=B():Q.ecstatic=B()}(window,(function(){return function(Q){var B=window.webpackHotUpdateecstatic;window.webpackHotUpdateecstatic=function(Q,n){!function(Q,B){if(!y[Q]||!R[Q])return;for(var n in R[Q]=!1,B)Object.prototype.hasOwnProperty.call(B,n)&&(b[n]=B[n]);0==--C&&0===u&&r()}(Q,n),B&&B(Q,n)};var n,t=!0,e="71bc2a6a0f382af010b3",F={},U=[],s=[];function I(Q){var B=L[Q];if(!B)return E;var t=function(t){return B.hot.active?(L[t]?-1===L[t].parents.indexOf(Q)&&L[t].parents.push(Q):(U=[Q],n=t),-1===B.children.indexOf(t)&&B.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+Q),U=[]),E(t)},e=function(Q){return{configurable:!0,enumerable:!0,get:function(){return E[Q]},set:function(B){E[Q]=B}}};for(var F in E)Object.prototype.hasOwnProperty.call(E,F)&&"e"!==F&&"t"!==F&&Object.defineProperty(t,F,e(F));return t.e=function(Q){return"ready"===c&&g("prepare"),u++,E.e(Q).then(B,(function(Q){throw B(),Q}));function B(){u--,"prepare"===c&&(a[Q]||X(Q),0===u&&0===C&&r())}},t.t=function(Q,B){return 1&B&&(Q=t(Q)),E.t(Q,-2&B)},t}function i(B){var t={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:n!==B,active:!0,accept:function(Q,B){if(void 0===Q)t._selfAccepted=!0;else if("function"==typeof Q)t._selfAccepted=Q;else if("object"==typeof Q)for(var n=0;n<Q.length;n++)t._acceptedDependencies[Q[n]]=B||function(){};else t._acceptedDependencies[Q]=B||function(){}},decline:function(Q){if(void 0===Q)t._selfDeclined=!0;else if("object"==typeof Q)for(var B=0;B<Q.length;B++)t._declinedDependencies[Q[B]]=!0;else t._declinedDependencies[Q]=!0},dispose:function(Q){t._disposeHandlers.push(Q)},addDisposeHandler:function(Q){t._disposeHandlers.push(Q)},removeDisposeHandler:function(Q){var B=t._disposeHandlers.indexOf(Q);B>=0&&t._disposeHandlers.splice(B,1)},invalidate:function(){switch(this._selfInvalidated=!0,c){case"idle":(b={})[B]=Q[B],g("ready");break;case"ready":m(B);break;case"prepare":case"check":case"dispose":case"apply":(o=o||[]).push(B)}},check:x,apply:Z,status:function(Q){if(!Q)return c;l.push(Q)},addStatusHandler:function(Q){l.push(Q)},removeStatusHandler:function(Q){var B=l.indexOf(Q);B>=0&&l.splice(B,1)},data:F[B]};return n=void 0,t}var l=[],c="idle";function g(Q){c=Q;for(var B=0;B<l.length;B++)l[B].call(null,Q)}var d,b,G,o,C=0,u=0,a={},R={},y={};function V(Q){return+Q+""===Q?+Q:Q}function x(Q){if("idle"!==c)throw new Error("check() is only allowed in idle status");return t=Q,g("check"),(B=1e4,B=B||1e4,new Promise((function(Q,n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var t=new XMLHttpRequest,e=E.p+"hot/hot-update.json";t.open("GET",e,!0),t.timeout=B,t.send(null)}catch(Q){return n(Q)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)n(new Error("Manifest request to "+e+" timed out."));else if(404===t.status)Q();else if(200!==t.status&&304!==t.status)n(new Error("Manifest request to "+e+" failed."));else{try{var B=JSON.parse(t.responseText)}catch(Q){return void n(Q)}Q(B)}}}))).then((function(Q){if(!Q)return g(N()?"ready":"idle"),null;R={},a={},y=Q.c,G=Q.h,g("prepare");var B=new Promise((function(Q,B){d={resolve:Q,reject:B}}));b={};return X(0),"prepare"===c&&0===u&&0===C&&r(),B}));var B}function X(Q){var B;y[Q]?(R[Q]=!0,C++,(B=document.createElement("script")).charset="utf-8",B.src=E.p+"hot/hot-update.js",document.head.appendChild(B)):a[Q]=!0}function r(){g("ready");var Q=d;if(d=null,Q)if(t)Promise.resolve().then((function(){return Z(t)})).then((function(B){Q.resolve(B)}),(function(B){Q.reject(B)}));else{var B=[];for(var n in b)Object.prototype.hasOwnProperty.call(b,n)&&B.push(V(n));Q.resolve(B)}}function Z(B){if("ready"!==c)throw new Error("apply() is only allowed in ready status");return function B(t){var s,I,i,l,c;function d(Q){for(var B=[Q],n={},t=B.map((function(Q){return{chain:[Q],id:Q}}));t.length>0;){var e=t.pop(),F=e.id,U=e.chain;if((l=L[F])&&(!l.hot._selfAccepted||l.hot._selfInvalidated)){if(l.hot._selfDeclined)return{type:"self-declined",chain:U,moduleId:F};if(l.hot._main)return{type:"unaccepted",chain:U,moduleId:F};for(var s=0;s<l.parents.length;s++){var I=l.parents[s],i=L[I];if(i){if(i.hot._declinedDependencies[F])return{type:"declined",chain:U.concat([I]),moduleId:F,parentId:I};-1===B.indexOf(I)&&(i.hot._acceptedDependencies[F]?(n[I]||(n[I]=[]),C(n[I],[F])):(delete n[I],B.push(I),t.push({chain:U.concat([I]),id:I})))}}}}return{type:"accepted",moduleId:Q,outdatedModules:B,outdatedDependencies:n}}function C(Q,B){for(var n=0;n<B.length;n++){var t=B[n];-1===Q.indexOf(t)&&Q.push(t)}}N();var u={},a=[],R={},x=function(){console.warn("[HMR] unexpected require("+r.moduleId+") to disposed module")};for(var X in b)if(Object.prototype.hasOwnProperty.call(b,X)){var r;c=V(X),r=b[X]?d(c):{type:"disposed",moduleId:X};var Z=!1,m=!1,p=!1,W="";switch(r.chain&&(W="\nUpdate propagation: "+r.chain.join(" -> ")),r.type){case"self-declined":t.onDeclined&&t.onDeclined(r),t.ignoreDeclined||(Z=new Error("Aborted because of self decline: "+r.moduleId+W));break;case"declined":t.onDeclined&&t.onDeclined(r),t.ignoreDeclined||(Z=new Error("Aborted because of declined dependency: "+r.moduleId+" in "+r.parentId+W));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(r),t.ignoreUnaccepted||(Z=new Error("Aborted because "+c+" is not accepted"+W));break;case"accepted":t.onAccepted&&t.onAccepted(r),m=!0;break;case"disposed":t.onDisposed&&t.onDisposed(r),p=!0;break;default:throw new Error("Unexception type "+r.type)}if(Z)return g("abort"),Promise.reject(Z);if(m)for(c in R[c]=b[c],C(a,r.outdatedModules),r.outdatedDependencies)Object.prototype.hasOwnProperty.call(r.outdatedDependencies,c)&&(u[c]||(u[c]=[]),C(u[c],r.outdatedDependencies[c]));p&&(C(a,[r.moduleId]),R[c]=x)}var h,A=[];for(I=0;I<a.length;I++)c=a[I],L[c]&&L[c].hot._selfAccepted&&R[c]!==x&&!L[c].hot._selfInvalidated&&A.push({module:c,parents:L[c].parents.slice(),errorHandler:L[c].hot._selfAccepted});g("dispose"),Object.keys(y).forEach((function(Q){!1===y[Q]&&function(Q){delete installedChunks[Q]}(Q)}));var S,D,H=a.slice();for(;H.length>0;)if(c=H.pop(),l=L[c]){var v={},Y=l.hot._disposeHandlers;for(i=0;i<Y.length;i++)(s=Y[i])(v);for(F[c]=v,l.hot.active=!1,delete L[c],delete u[c],i=0;i<l.children.length;i++){var z=L[l.children[i]];z&&((h=z.parents.indexOf(c))>=0&&z.parents.splice(h,1))}}for(c in u)if(Object.prototype.hasOwnProperty.call(u,c)&&(l=L[c]))for(D=u[c],i=0;i<D.length;i++)S=D[i],(h=l.children.indexOf(S))>=0&&l.children.splice(h,1);g("apply"),void 0!==G&&(e=G,G=void 0);for(c in b=void 0,R)Object.prototype.hasOwnProperty.call(R,c)&&(Q[c]=R[c]);var T=null;for(c in u)if(Object.prototype.hasOwnProperty.call(u,c)&&(l=L[c])){D=u[c];var J=[];for(I=0;I<D.length;I++)if(S=D[I],s=l.hot._acceptedDependencies[S]){if(-1!==J.indexOf(s))continue;J.push(s)}for(I=0;I<J.length;I++){s=J[I];try{s(D)}catch(Q){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:c,dependencyId:D[I],error:Q}),t.ignoreErrored||T||(T=Q)}}}for(I=0;I<A.length;I++){var k=A[I];c=k.module,U=k.parents,n=c;try{E(c)}catch(Q){if("function"==typeof k.errorHandler)try{k.errorHandler(Q)}catch(B){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:c,error:B,originalError:Q}),t.ignoreErrored||T||(T=B),T||(T=Q)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:c,error:Q}),t.ignoreErrored||T||(T=Q)}}if(T)return g("fail"),Promise.reject(T);if(o)return B(t).then((function(Q){return a.forEach((function(B){Q.indexOf(B)<0&&Q.push(B)})),Q}));return g("idle"),new Promise((function(Q){Q(a)}))}(B=B||{})}function N(){if(o)return b||(b={}),o.forEach(m),o=void 0,!0}function m(B){Object.prototype.hasOwnProperty.call(b,B)||(b[B]=Q[B])}var L={};function E(B){if(L[B])return L[B].exports;var n=L[B]={i:B,l:!1,exports:{},hot:i(B),parents:(s=U,U=[],s),children:[]};return Q[B].call(n.exports,n,n.exports,I(B)),n.l=!0,n.exports}return E.m=Q,E.c=L,E.d=function(Q,B,n){E.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:n})},E.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},E.t=function(Q,B){if(1&B&&(Q=E(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var n=Object.create(null);if(E.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var t in Q)E.d(n,t,function(B){return Q[B]}.bind(null,t));return n},E.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return E.d(B,"a",B),B},E.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},E.p="/static/",E.h=function(){return e},I(0)(E.s=0)}([function(Q,B,n){Q.exports=n(1)},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "World", function() { return /* reexport */ World_World; });\n\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== \'undefined\' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \'undefined\' && typeof msCrypto.getRandomValues === \'function\' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error(\'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js\n/* harmony default export */ var regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js\n\n\nfunction validate(uuid) {\n  return typeof uuid === \'string\' && regex.test(uuid);\n}\n\n/* harmony default export */ var esm_browser_validate = (validate);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var stringify_i = 0; stringify_i < 256; ++stringify_i) {\n  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It\'s been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \'-\' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \'-\' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \'-\' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \'-\' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it\'s likely due to one\n  // of the following:\n  // - One or more input array values don\'t map to a hex octet (leading to\n  // "undefined" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!esm_browser_validate(uuid)) {\n    throw TypeError(\'Stringified UUID is invalid\');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ var esm_browser_stringify = (stringify);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return esm_browser_stringify(rnds);\n}\n\n/* harmony default export */ var esm_browser_v4 = (v4);\n// CONCATENATED MODULE: ./src/guards.ts\n// export function classIsCompType(cl: any)\nfunction isComponentInstance(Class, comp) {\n  if (!comp) {\n    return false;\n  }\n\n  if (!(comp instanceof Class)) {\n    return false;\n  }\n\n  return true;\n}\nfunction isComponentName(possibleName, entitiesByCTypes) {\n  // string\n  if (typeof possibleName !== \'string\') {\n    return false;\n  }\n\n  for (const a of entitiesByCTypes.keys()) {\n    if (a.includes(possibleName)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n// CONCATENATED MODULE: ./src/ComponentCollection.ts\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n// CT is a Union, like `type = typeof FirstComponent | typeof SecondComponent`.\nclass ComponentCollection_ComponentCollection {\n  constructor() {\n    _defineProperty(this, "components", new Map());\n\n    _defineProperty(this, "add", component => {\n      this.components.set(component.constructor.name, component);\n    });\n\n    _defineProperty(this, "update", (cl, func) => {\n      const c = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, c)) {\n        const updatedComponent = func(c);\n        this.components.set(cl.name, updatedComponent);\n      }\n    });\n\n    _defineProperty(this, "remove", cType => {\n      this.components.delete(cType.name);\n    });\n\n    _defineProperty(this, "get", cl => {\n      const comp = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, comp)) {\n        return comp;\n      } else {\n        throw new Error(`ComponentCollection does not have component of type ${cl.name}`);\n      }\n    });\n\n    _defineProperty(this, "has", cType => {\n      return Array.isArray(cType) ? cType.every(ct => this.components.has(ct.name) === true) : this.components.has(cType.name);\n    });\n\n    _defineProperty(this, "hasByName", cName => {\n      return Array.isArray(cName) ? cName.every(ct => this.components.has(ct) === true) : this.components.has(cName);\n    });\n  }\n\n  /**\n   * Get the component type names that are currently being used in the collection.\n   */\n  get componentTypes() {\n    return [...this.components.keys()];\n  }\n  /**\n   * Get the current number of components that are in the collection.\n   */\n\n\n  get size() {\n    return this.components.size;\n  }\n\n  toDevComponents() {\n    const obj = {};\n\n    for (const [compName, comp] of this.components) {\n      obj[compName] = comp;\n    }\n\n    return obj;\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevEntity.ts\nfunction DevEntity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevEntity {\n  constructor(entity, world) {\n    DevEntity_defineProperty(this, "id", void 0);\n\n    DevEntity_defineProperty(this, "components", void 0);\n\n    DevEntity_defineProperty(this, "tags", void 0);\n\n    DevEntity_defineProperty(this, "systems", []);\n\n    this.id = entity.id;\n    this.components = entity.components.toDevComponents(), this.tags = [...entity.tags];\n    const compNames = Object.keys(this.components);\n\n    for (const [systemName, cNames] of world.systems.compNamesBySystemName) {\n      if (cNames.every(cName => compNames.includes(cName))) {\n        this.systems.push(systemName);\n      }\n    }\n  }\n\n  toTableRow() {\n    return {\n      id: this.id,\n      components: Object.keys(this.components).join(", "),\n      tags: this.tags.join(", "),\n      systems: this.systems.join(\', \')\n    };\n  }\n\n}\n\n/* harmony default export */ var src_DevEntity = (DevEntity);\n// CONCATENATED MODULE: ./src/SimpleFSM.ts\nfunction SimpleFSM_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass SimpleFSM {\n  constructor(initialState, transitions) {\n    SimpleFSM_defineProperty(this, "current", void 0);\n\n    SimpleFSM_defineProperty(this, "initial", void 0);\n\n    SimpleFSM_defineProperty(this, "transitions", void 0);\n\n    this.initial = initialState;\n    this.current = initialState;\n    this.transitions = transitions;\n  }\n\n  next() {\n    if (this.transitions[this.current]) {\n      this.current = this.transitions[this.current](this.current);\n    }\n  }\n\n  reset() {\n    this.current = this.initial;\n  }\n\n  is(checkState) {\n    return this.current === checkState;\n  }\n\n  includes(checkStateArr) {\n    return checkStateArr.some(s => this.current === s);\n  }\n\n}\n// CONCATENATED MODULE: ./src/Entity.ts\nfunction Entity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n// import { CompTypes } from \'interfaces\';\n\n\nclass Entity_Entity {\n  constructor(world) {\n    Entity_defineProperty(this, "_id", void 0);\n\n    Entity_defineProperty(this, "_world", void 0);\n\n    Entity_defineProperty(this, "_error", void 0);\n\n    Entity_defineProperty(this, "_state", void 0);\n\n    this._id = esm_browser_v4();\n    this._world = world;\n    this._error = null;\n    this._state = new SimpleFSM("creating", {\n      creating: () => this._error ? "error" : "created",\n      created: () => "destroying",\n      destroying: () => this._error ? "error" : "destroyed",\n      destroyed: () => "destroyed",\n      error: () => "error"\n    });\n    /*\n    Registering with the World.\n    */\n\n    this._world.registerEntity(this);\n\n    this._state.next(); // created\n\n\n    this.onCreate();\n  }\n\n  get state() {\n    return this._state.current;\n  }\n\n  checkState(possibleState) {\n    return this._state.is(possibleState);\n  }\n  /* LifeCycle methods, meant to be overridden */\n\n\n  onCreate() {// abstract\n  }\n\n  onDestroy() {// abstract\n  }\n\n  onComponentAdd() {// abstract\n  }\n\n  onComponentUpdate() {// abstract\n  }\n\n  onComponentRemove() {// abstract\n  }\n  /**\n   * Add a component to an Entity, doh.\n   */\n\n\n  add(component) {\n    this._world.set(this._id, component);\n\n    if (component[Symbol.for("ecs.trackedComponent.isTracked")]) {\n      component[Symbol.for("ecs.trackedComponent.setWorld")](this._world);\n      component[Symbol.for("ecs.trackedComponent.onAdd")](this._world, this);\n    }\n\n    return this;\n  }\n  /**\n   * Add a tag to a component\n   */\n\n\n  addTag(tag) {\n    const entitySet = this._world.entitiesByTags.has(tag) ? this._world.entitiesByTags.get(tag) : new Set();\n\n    if (entitySet) {\n      entitySet.add(this._id);\n\n      this._world.entitiesByTags.set(tag, entitySet);\n    }\n\n    return this;\n  }\n  /**\n   * Determines if an entity has a component related to it.\n   */\n\n\n  has(cType) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    return cc.has(cType);\n  }\n  /**\n   * Check to see if an entity tagged with a given tag.\n   */\n\n\n  hasTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        return entitySet.has(this._id);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get a component that belongs to an entity.\n   */\n\n\n  get(cl) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    const component = cc.get(cl);\n    return component;\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection\n   */\n\n\n  getAll() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Remove a component from an entity.\n   * @param cType A component class, eg MyComponent\n   */\n\n\n  remove(cType) {\n    this._world.remove(this._id, cType);\n\n    return this;\n  }\n  /**\n   * Remove a tag from an entity\n   */\n\n\n  removeTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        entitySet.delete(this._id);\n\n        if (entitySet.size === 0) {\n          this._world.entitiesByTags.delete(tag);\n        }\n      }\n    }\n\n    return this;\n  }\n  /** Clears all components from an Entity */\n\n\n  clear() {\n    this._world.clearEntityComponents(this._id);\n\n    return this;\n  }\n  /**\n   * Remove all tags on an entity\n   */\n\n\n  clearTags() {\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      entitySet.delete(this._id);\n\n      if (entitySet.size === 0) {\n        this._world.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n  destroy() {\n    if (!this._state.is("created")) {\n      throw new Error("Ecstatic: Unable to destroy if it isn\'t created, or already destroyed");\n    }\n\n    this._state.next(); // destroying\n    // This will probably be deferred so that Systems can work on it.\n\n\n    this._world.destroyEntity(this._id); // should return an error??\n\n\n    this.onDestroy(); // assuming for now that this is best done after actually removing the entity from the world.\n\n    if (this._state.is("destroying")) {\n      this._state.next(); // destroyed\n\n    } else if (this._state.is("error") && this._error) {// Do something with error!!\n    }\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get world() {\n    return this._world;\n  }\n\n  destroyImmediately() {// placeholder for method that doesn\'t wait for entity to go through the normal\n    // destory pipeline and process.\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection.\n   * Does the same thing as entityInstance.getAll().\n   */\n\n\n  get components() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Retrieves all the tags that have been added to this entity.\n   */\n\n\n  get tags() {\n    const tags = new Set();\n\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      if (entitySet.has(this._id)) {\n        tags.add(tag);\n      }\n    }\n\n    return tags;\n  }\n  /**\n   * Convert Entity to a DevEntity. Very helpful in for debugging.\n   */\n\n\n  toDevEntity() {\n    return new src_DevEntity(this, this._world);\n  }\n\n}\nfunction createEntity(world) {\n  const entity = new Entity_Entity(world);\n  return entity;\n}\n// CONCATENATED MODULE: ./src/DevTools.ts\nfunction DevTools_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevTools {\n  constructor(world) {\n    DevTools_defineProperty(this, "world", void 0);\n\n    this.world = world;\n  }\n  /**\n   * display the all systems of the world, and the components required by each system.\n   * Super helpful to use with console.table()\n   * @example\n   * ```\n   * console.table(world.dev.systemComponents);\n   * ```\n   */\n\n\n  get systemComponents() {\n    const compsBySystems = [];\n\n    for (const [system, compNames] of this.world.systems.compNamesBySystemName) {\n      compsBySystems.push({\n        system,\n        components: compNames.join(", ")\n      });\n    }\n\n    return compsBySystems;\n  }\n  /**\n   * Create an array of DevEntites. Can be very helpful for things like inspecting component state,\n   * and which systems will be called on an entity.\n   * @example\n   * ```\n   * console.table(world.dev.entities);\n   *\n   * // Pro tip! try displaying a table of entities with console.table and DevEntity.toTableRow().\n   * console.table(world.dev.entities.map(devEntity => devEntity.toTableRow()));\n   * ```\n   */\n\n\n  get entities() {\n    return [...this.world.entities.values()].map(e => e.toDevEntity());\n  }\n\n}\n\n/* harmony default export */ var src_DevTools = (DevTools);\n// CONCATENATED MODULE: ./src/Systems.ts\nfunction Systems_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/**\n * Arguments that are passed into a System function on each iteration.\n * This is how you acces things like the entity that particular entity to act on,\n * as well as some other helpful params like if the entity is the first or last entity\n * in the group of entities that being iterated over.\n */\n\nclass Systems_Systems {\n  // double check to make sure that maps are ordered.\n  constructor(world) {\n    Systems_defineProperty(this, "world", void 0);\n\n    Systems_defineProperty(this, "systemFuncBySystemName", void 0);\n\n    Systems_defineProperty(this, "compNamesBySystemName", void 0);\n\n    this.world = world;\n    this.systemFuncBySystemName = new Map();\n    this.compNamesBySystemName = new Map();\n  }\n\n  add(cTypes, systemFunc, funcName) {\n    const cNames = cTypes.map(ct => ct.name);\n    let name = systemFunc.name;\n\n    if (systemFunc.name === \'\') {\n      // Super brute force, and might lead to errors in the future, but for now\n      // using the stringified system function if the function doesn\'t already have a name.\n      // This is useful for anonymous functions used as a system function.\n      // Might be good to figure out how to get a hash of the function string.\n      name = systemFunc.toString().slice(0, 30);\n    }\n\n    if (funcName) {\n      name = funcName;\n    }\n\n    this.systemFuncBySystemName.set(name, systemFunc);\n    this.compNamesBySystemName.set(name, cNames);\n    this.world.entitiesByCTypes.set(cNames, new Set());\n    return this;\n  }\n\n  run() {\n    // TODO: Might be cool to add a way to stop the systems loop when in dev.\n    //       Maybe something like world.dev.stop() or pause().\n    for (const [funcName, systemFunc] of this.systemFuncBySystemName.entries()) {\n      let index = 0;\n      const size = this.world.entitiesByCTypes.size;\n      const cNames = this.compNamesBySystemName.get(funcName) || [];\n      const cTypeArrs = this.world.entitiesByCTypes.get(cNames) || new Set();\n\n      for (const eid of cTypeArrs) {\n        const args = {\n          entity: this.world.entities.get(eid) || new Entity_Entity(this.world),\n          components: this.world.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(),\n          world: this.world,\n          index,\n          size,\n          isFirst: index === 0,\n          isLast: index + 1 === size\n        };\n        systemFunc(args);\n        index += 1;\n      }\n    }\n  }\n\n}\n// CONCATENATED MODULE: ./src/World.ts\nfunction World_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nclass World_World {\n  constructor() {\n    World_defineProperty(this, "componentCollections", new Map());\n\n    World_defineProperty(this, "entities", new Map());\n\n    World_defineProperty(this, "entitiesByCTypes", new Map());\n\n    World_defineProperty(this, "entitiesByTags", new Map());\n\n    World_defineProperty(this, "systems", void 0);\n\n    World_defineProperty(this, "dev", void 0);\n\n    World_defineProperty(this, "find", predicate => {\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "findAll", predicate => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "locate", cl => {\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "locateAll", cl => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "grab", cl => {\n      // const entity = this.locate((cl as unknown) as CT[keyof CT]);\n      const entity = this.locate(cl);\n\n      if (entity) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n        return {\n          entity,\n          component\n        };\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabBy", (cl, predicate) => {\n      const entities = this.locateAll(cl);\n\n      for (const entity of entities) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n\n        if (predicate(component)) {\n          return {\n            component,\n            entity\n          };\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabAll", cl => {\n      const entities = this.locateAll(cl);\n      return entities.map(entity => {\n        return {\n          entity,\n          component: entity.components.get(cl)\n        };\n      });\n    });\n\n    World_defineProperty(this, "get", (eid, cl) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      return cc.get(cl);\n    });\n\n    World_defineProperty(this, "getComponent", (cl, defaultValue) => {\n      const result = this.grab(cl);\n\n      if (!result) {\n        return defaultValue ? defaultValue : null;\n      }\n\n      return result.component;\n    });\n\n    World_defineProperty(this, "getTagged", tag => {\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        const entityId = tagEntityIds.values().next().value;\n        const entity = this.entities.get(entityId);\n\n        if (entity) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "getAllTagged", tag => {\n      let entities = []; // eslint-disable-line\n\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        for (const entityId of tagEntityIds) {\n          const entity = this.entities.get(entityId);\n\n          if (entity) {\n            entities.push(entity);\n          }\n        }\n      }\n\n      return entities;\n    });\n\n    World_defineProperty(this, "set", (eid, component) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      cc.add(component);\n      this.componentCollections.set(eid, cc);\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      return this;\n    });\n\n    World_defineProperty(this, "remove", (eid, cType) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(); // remove entity from current entitiesByCTypes\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.delete(eid);\n        }\n      }\n\n      cc.remove(cType); // Move entityId to new CTypes if needed.\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      return this;\n    });\n\n    this.dev = new src_DevTools(this);\n    this.systems = new Systems_Systems(this);\n  }\n  /**\n   * "finds" a single entity based on a predicate\n   */\n\n\n  /**\n   * Alternative method for adding systems.\n   */\n  addSystem(cTypes, systemFunc, funcName) {\n    this.systems.add(cTypes, systemFunc, funcName);\n    return this;\n  }\n\n  registerEntity(entity) {\n    const cc = new ComponentCollection_ComponentCollection();\n    this.componentCollections.set(entity.id, cc);\n    this.entities.set(entity.id, entity);\n    return this;\n  }\n  /**\n   * Remove all components that belong to an entity.\n   */\n\n\n  clearEntityComponents(eid) {\n    this.componentCollections.set(eid, new ComponentCollection_ComponentCollection());\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Create an entity that is in the world.\n   * Basically just new Entity(world), but saves an import of Entity.\n   */\n\n\n  createEntity() {\n    const entity = new Entity_Entity(this);\n    return entity; // Register entity here....\n  }\n  /**\n   * Destroys an entity.\n   * Same as entity.destroy().\n   */\n\n\n  destroyEntity(eid) {\n    this.componentCollections.delete(eid);\n    this.entities.delete(eid);\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    } // remove any tag associations with destroyed entities.\n\n\n    for (const [tag, entitySet] of this.entitiesByTags) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n\n      if (entitySet.size === 0) {\n        this.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n}\n// CONCATENATED MODULE: ./src/index.ts\n // import { createEntity } from \'./Entity\';\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY3N0YXRpYy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzP2Q4ZjgiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzPzQwZDYiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzA2ZTQiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3N0cmluZ2lmeS5qcz81OGNmIiwid2VicGFjazovL2Vjc3RhdGljLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz9lYzI2Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL2d1YXJkcy50cz8zYjU3Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL0NvbXBvbmVudENvbGxlY3Rpb24udHM/NTFjNCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZFbnRpdHkudHM/ZDE0MiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9TaW1wbGVGU00udHM/NDY5OSIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9FbnRpdHkudHM/YWM2OCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZUb29scy50cz9lMDFhIiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL1N5c3RlbXMudHM/YTYxMyIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9Xb3JsZC50cz9jYzBiIiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL2luZGV4LnRzP2ZmYjQiXSwibmFtZXMiOlsiaXNDb21wb25lbnRJbnN0YW5jZSIsIkNsYXNzIiwiY29tcCIsImlzQ29tcG9uZW50TmFtZSIsInBvc3NpYmxlTmFtZSIsImVudGl0aWVzQnlDVHlwZXMiLCJhIiwia2V5cyIsImluY2x1ZGVzIiwiQ29tcG9uZW50Q29sbGVjdGlvbiIsIk1hcCIsImNvbXBvbmVudCIsImNvbXBvbmVudHMiLCJzZXQiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJjbCIsImZ1bmMiLCJjIiwiZ2V0IiwidXBkYXRlZENvbXBvbmVudCIsImNUeXBlIiwiZGVsZXRlIiwiRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsImN0IiwiaGFzIiwiY05hbWUiLCJjb21wb25lbnRUeXBlcyIsInNpemUiLCJ0b0RldkNvbXBvbmVudHMiLCJvYmoiLCJjb21wTmFtZSIsIkRldkVudGl0eSIsImVudGl0eSIsIndvcmxkIiwiaWQiLCJ0YWdzIiwiY29tcE5hbWVzIiwiT2JqZWN0Iiwic3lzdGVtTmFtZSIsImNOYW1lcyIsInN5c3RlbXMiLCJjb21wTmFtZXNCeVN5c3RlbU5hbWUiLCJwdXNoIiwidG9UYWJsZVJvdyIsImpvaW4iLCJTaW1wbGVGU00iLCJpbml0aWFsU3RhdGUiLCJ0cmFuc2l0aW9ucyIsImluaXRpYWwiLCJjdXJyZW50IiwibmV4dCIsInJlc2V0IiwiaXMiLCJjaGVja1N0YXRlIiwiY2hlY2tTdGF0ZUFyciIsInNvbWUiLCJzIiwiRW50aXR5IiwiX2lkIiwidXVpZHY0IiwiX3dvcmxkIiwiX2Vycm9yIiwiX3N0YXRlIiwiY3JlYXRpbmciLCJjcmVhdGVkIiwiZGVzdHJveWluZyIsImRlc3Ryb3llZCIsImVycm9yIiwicmVnaXN0ZXJFbnRpdHkiLCJvbkNyZWF0ZSIsInN0YXRlIiwicG9zc2libGVTdGF0ZSIsIm9uRGVzdHJveSIsIm9uQ29tcG9uZW50QWRkIiwib25Db21wb25lbnRVcGRhdGUiLCJvbkNvbXBvbmVudFJlbW92ZSIsImFkZCIsIlN5bWJvbCIsImZvciIsImFkZFRhZyIsInRhZyIsImVudGl0eVNldCIsImVudGl0aWVzQnlUYWdzIiwiU2V0IiwiY2MiLCJjb21wb25lbnRDb2xsZWN0aW9ucyIsImhhc1RhZyIsImdldEFsbCIsInJlbW92ZSIsInJlbW92ZVRhZyIsImNsZWFyIiwiY2xlYXJFbnRpdHlDb21wb25lbnRzIiwiY2xlYXJUYWdzIiwiZW50cmllcyIsImRlc3Ryb3kiLCJkZXN0cm95RW50aXR5IiwiZGVzdHJveUltbWVkaWF0ZWx5IiwidG9EZXZFbnRpdHkiLCJjcmVhdGVFbnRpdHkiLCJEZXZUb29scyIsInN5c3RlbUNvbXBvbmVudHMiLCJjb21wc0J5U3lzdGVtcyIsInN5c3RlbSIsImVudGl0aWVzIiwidmFsdWVzIiwibWFwIiwiZSIsIlN5c3RlbXMiLCJzeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lIiwiY1R5cGVzIiwic3lzdGVtRnVuYyIsImZ1bmNOYW1lIiwidG9TdHJpbmciLCJzbGljZSIsInJ1biIsImluZGV4IiwiY1R5cGVBcnJzIiwiZWlkIiwiYXJncyIsImlzRmlyc3QiLCJpc0xhc3QiLCJXb3JsZCIsInByZWRpY2F0ZSIsInJlc3VsdHMiLCJsb2NhdGUiLCJsb2NhdGVBbGwiLCJkZWZhdWx0VmFsdWUiLCJyZXN1bHQiLCJncmFiIiwidGFnRW50aXR5SWRzIiwiZW50aXR5SWQiLCJ2YWx1ZSIsImN0QXJyIiwiaGFzQnlOYW1lIiwiZGV2IiwiYWRkU3lzdGVtIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7O0FDbEJlLHdEQUFjLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEdBQUcseUNBQXlDLEU7O0FDQXJHOztBQUUvQjtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDOztBQUVlLGlFQUFRLEU7O0FDTmM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxXQUFDLEtBQUssQ0FBQyxXQUFDLE9BQU8sR0FBRyxXQUFDO0FBQzVCLGtCQUFrQixXQUFDO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseWdCQUF5Z0I7QUFDemdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU8s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QWlCbUcsR0FBakI7QUFDRDtBQUNGLEtBUnFDLENBVXRDOzs7QUFDQSxTQUFLLE1BQU0sQ0FBQ3JDLEdBQUQsRUFBTUMsU0FBTixDQUFYLElBQStCLEtBQUtDLGNBQXBDLEVBQW9EO0FBQ2xELFVBQUlELFNBQVMsQ0FBQ3pELEdBQVYsQ0FBYzZGLEdBQWQsQ0FBSixFQUF3QjtBQUN0QnBDLGlCQUFTLENBQUMvRCxNQUFWLENBQWlCbUcsR0FBakI7QUFDRDs7QUFFRCxVQUFJcEMsU0FBUyxDQUFDdEQsSUFBVixLQUFtQixDQUF2QixFQUEwQjtBQUN4QixhQUFLdUQsY0FBTCxDQUFvQmhFLE1BQXBCLENBQTJCOEQsR0FBM0I7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNEOztBQWxWK0MsQzs7Q0NSbEQiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxudmFyIGdldFJhbmRvbVZhbHVlcztcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuICAgIC8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFycikge1xuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgdmFyIHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7IiwiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwiaW1wb3J0IEVudGl0eSwgeyBFbnRpdHlJZCB9IGZyb20gXCIuL0VudGl0eVwiO1xuaW1wb3J0IHsgQ29tcFR5cGVzIH0gZnJvbSAnaW50ZXJmYWNlcyc7XG5pbXBvcnQgQ29tcG9uZW50Q29sbGVjdGlvbiBmcm9tICcuL0NvbXBvbmVudENvbGxlY3Rpb24nO1xuXG4vLyBleHBvcnQgZnVuY3Rpb24gY2xhc3NJc0NvbXBUeXBlKGNsOiBhbnkpXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbXBvbmVudEluc3RhbmNlPFQ+KFxuICBDbGFzczogbmV3ICguLi5hcmdzOiBhbnkpID0+IFQsXG4gIGNvbXA6IGFueVxuKTogY29tcCBpcyBJbnN0YW5jZVR5cGU8dHlwZW9mIENsYXNzPiB7XG4gIGlmICghY29tcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDbGFzcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb21wb25lbnROYW1lPENUIGV4dGVuZHMgQ29tcFR5cGVzPENUPj4oXG4gIHBvc3NpYmxlTmFtZTogYW55LFxuICBlbnRpdGllc0J5Q1R5cGVzOiBNYXA8KGtleW9mIENUKVtdLCBTZXQ8RW50aXR5SWQ+PlxuKTogcG9zc2libGVOYW1lIGlzIENUW2tleW9mIENUXSB7XG4gIC8vIHN0cmluZ1xuICBpZiAodHlwZW9mIHBvc3NpYmxlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGEgb2YgZW50aXRpZXNCeUNUeXBlcy5rZXlzKCkpIHtcbiAgICBpZiAoYS5pbmNsdWRlcyhwb3NzaWJsZU5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgeyBpc0NvbXBvbmVudEluc3RhbmNlIH0gZnJvbSBcIi4vZ3VhcmRzXCI7XG5cbnR5cGUgQ2xhc3M8VD4gPSB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUIH07XG5cbi8vIENUIGlzIGEgVW5pb24sIGxpa2UgYHR5cGUgPSB0eXBlb2YgRmlyc3RDb21wb25lbnQgfCB0eXBlb2YgU2Vjb25kQ29tcG9uZW50YC5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBvbmVudENvbGxlY3Rpb248Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PiB7XG4gIGNvbXBvbmVudHM6IE1hcDxzdHJpbmcsIEluc3RhbmNlVHlwZTxDVD4+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIGluc3RhbmNlIG9mIGEgY29tcG9uZW50XG4gIC8vIGFkZCA9IChjb21wb25lbnQ6IEluc3RhbmNlVHlwZTxDVFtrZXlvZiBDVF0+KTogdm9pZCA9PiB7XG4gIGFkZCA9IChjb21wb25lbnQ6IEluc3RhbmNlVHlwZTxDVD4pOiB2b2lkID0+IHtcbiAgICB0aGlzLmNvbXBvbmVudHMuc2V0KGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lLCBjb21wb25lbnQpO1xuICB9O1xuXG4gIHVwZGF0ZSA9IDxUPihcbiAgICBjbDogQ2xhc3M8VD4sXG4gICAgZnVuYzogKGM6IEluc3RhbmNlVHlwZTx0eXBlb2YgY2w+KSA9PiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPlxuICApOiB2b2lkID0+IHtcbiAgICBjb25zdCBjID0gdGhpcy5jb21wb25lbnRzLmdldChjbC5uYW1lKTtcblxuICAgIGlmIChpc0NvbXBvbmVudEluc3RhbmNlKGNsLCBjKSkge1xuICAgICAgY29uc3QgdXBkYXRlZENvbXBvbmVudCA9IGZ1bmMoYyk7XG4gICAgICB0aGlzLmNvbXBvbmVudHMuc2V0KGNsLm5hbWUsIHVwZGF0ZWRDb21wb25lbnQgYXMgSW5zdGFuY2VUeXBlPENUPik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBjVHlwZSBDbGFzcyBvZiBjb21wb25lbnQgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlID0gKGNUeXBlOiBDVCk6IHZvaWQgPT4ge1xuICAgIHRoaXMuY29tcG9uZW50cy5kZWxldGUoY1R5cGUubmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGNvbXBvbmVudCB0aGF0IG1hdGNoZXMgdGhlIHBhc3NlZCBjbGFzcy5cbiAgICogV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gY29tcG9uZW50XG4gICAqIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGNvbGxlY3Rpb24sIHNvIGlmIHlvdSBkb24ndCBrbm93IGlmIGl0J3Mgc2FmZVxuICAgKiB0byBnZXQgYSBjb21wb25lbnQsIHlvdSBzaG91bGQgdGVzdCB3aXRoIGhhcygpIG9yIGhhc0J5TmFtZSgpIGZpcnN0LlxuICAgKiBZb3UgaGF2ZSBiZWVuIHdhcm5lZC5cbiAgICogQHBhcmFtIGNsIGNvbXBvbmVudCBDbGFzcyByZWZlcmVuY2UuXG4gICAqL1xuICBnZXQgPSA8VD4oY2w6IENsYXNzPFQ+KTogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gPT4ge1xuICAgIGNvbnN0IGNvbXAgPSB0aGlzLmNvbXBvbmVudHMuZ2V0KGNsLm5hbWUpO1xuXG4gICAgaWYgKGlzQ29tcG9uZW50SW5zdGFuY2U8VD4oY2wsIGNvbXApKSB7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ29tcG9uZW50Q29sbGVjdGlvbiBkb2VzIG5vdCBoYXZlIGNvbXBvbmVudCBvZiB0eXBlICR7Y2wubmFtZX1gXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvLyBQb3NzaWJsZSBvdGhlciB3YXkgdG8gd3JpdGUgYSBnZXQgbWV0aG9kIHRoYXQgbWFpbnRhaW5zIHRoZSB0eXBlIG9mIHRoZVxuICAvLyBDb21wb25lbnQgdGhyb3VnaG91dC4gS2VlcGluZyBhcm91bmQgZm9yIG5vdyBhcmUgYSByZWZlcmVuY2UuXG4gIC8vIGdldDxVIGV4dGVuZHMgQ1Q+KGNvbXBDbGFzczogQ2xhc3M8VT4pOiBVIHtcbiAgLy8gICBpZiAoIXRoaXMuY29tcG9uZW50cy5oYXMoY29tcENsYXNzLm5hbWUpKSB7XG4gIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gIC8vICAgICAgIGBDb21wb25lbnRDb2xsZWN0aW9uIGRvZXMgbm90IGhhdmUgY29tcG9uZW50IG9mIHR5cGUgJHtjb21wQ2xhc3MubmFtZX1gXG4gIC8vICAgICApO1xuICAvLyAgIH1cblxuICAvLyAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuZ2V0KGNvbXBDbGFzcy5uYW1lKSEgYXMgdW5rbm93biBhcyBVO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIFRlc3QgdG8gc2VlIGlmIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5zIGEgc3BlY2lmaWMgQ2xhc3Mgb3IgQ2xhc3Nlcy5cbiAgICogQHBhcmFtIGNUeXBlIGNvbXBvbmVudCBDbGFzcywgb3IgYXJyYXkgb2YgY29tcG9uZW50IENsYXNzZXMuXG4gICAqL1xuICBoYXMgPSAoY1R5cGU6IENUIHwgQ1RbXSk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNUeXBlKVxuICAgICAgPyBjVHlwZS5ldmVyeSgoY3QpID0+IHRoaXMuY29tcG9uZW50cy5oYXMoY3QubmFtZSkgPT09IHRydWUpXG4gICAgICA6IHRoaXMuY29tcG9uZW50cy5oYXMoY1R5cGUubmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3QgdG8gc2VlIGlmIHRoZSBjb2xsZWN0aW9uIGhhcyBhIGNvbXBvbmVudCBpbnN0YW5jZSBiYXNlZCBvbiBhXG4gICAqIGNsYXNzIG5hbWUuIFNvbWUgYnVpbGQgc3RlcHMvbWluaWZpZXJzIHdpbGwgY2hhbmdlIHRoZSBuYW1lIG9mIENsYXNzZXMsXG4gICAqIHNvIGl0J3MgdXN1YWxseSBiZXN0IHRvIHBhc3MgaW4gYSBNeUNsYXNzLm5hbWUgaW5zdGVhZCBvZiAnTXlDbGFzcycuXG4gICAqIEBwYXJhbSBjTmFtZSBUaGUgbmFtZSBvZiBhIENsYXNzLCBvciBhcnJheSBvZiBDbGFzcyBuYW1lcy5cbiAgICovXG4gIGhhc0J5TmFtZSA9IChjTmFtZTogc3RyaW5nIHwgc3RyaW5nW10pOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjTmFtZSlcbiAgICAgID8gY05hbWUuZXZlcnkoY3QgPT4gdGhpcy5jb21wb25lbnRzLmhhcyhjdCkgPT09IHRydWUpXG4gICAgICA6IHRoaXMuY29tcG9uZW50cy5oYXMoY05hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbXBvbmVudCB0eXBlIG5hbWVzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyB1c2VkIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZ2V0IGNvbXBvbmVudFR5cGVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuY29tcG9uZW50cy5rZXlzKCldO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBudW1iZXIgb2YgY29tcG9uZW50cyB0aGF0IGFyZSBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIGdldCBzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5zaXplO1xuICB9XG5cbiAgdG9EZXZDb21wb25lbnRzKCk6IFJlY29yZDxzdHJpbmcsIEluc3RhbmNlVHlwZTxDVD4+IHtcbiAgICBjb25zdCBvYmo6IFJlY29yZDxzdHJpbmcsIEluc3RhbmNlVHlwZTxDVD4+ID0ge307XG4gICAgZm9yIChjb25zdCBbY29tcE5hbWUsIGNvbXBdIG9mIHRoaXMuY29tcG9uZW50cykge1xuICAgICAgb2JqW2NvbXBOYW1lXSA9IGNvbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxuIiwiaW1wb3J0IFdvcmxkLCB7IENsYXNzIH0gZnJvbSBcIi4vV29ybGRcIjtcbmltcG9ydCBFbnRpdHkgZnJvbSBcIi4vRW50aXR5XCI7XG5pbXBvcnQgeyBUYWcgfSBmcm9tIFwiLi9UYWdcIjtcblxuaW50ZXJmYWNlIERldkVudGl0eVRhYmxlUm93IHtcbiAgaWQ6IHN0cmluZztcbiAgY29tcG9uZW50czogc3RyaW5nO1xuICB0YWdzOiBzdHJpbmc7XG4gIHN5c3RlbXM6IHN0cmluZztcbn1cblxuY2xhc3MgRGV2RW50aXR5PENUIGV4dGVuZHMgQ2xhc3M8YW55Pj4ge1xuICBpZDogc3RyaW5nO1xuXG4gIGNvbXBvbmVudHM6IFJlY29yZDxzdHJpbmcsIEluc3RhbmNlVHlwZTxDVD4+O1xuXG4gIHRhZ3M6IFRhZ1tdO1xuXG4gIHN5c3RlbXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZW50aXR5OiBFbnRpdHk8Q1Q+LCB3b3JsZDogV29ybGQ8Q1Q+KSB7XG4gICAgdGhpcy5pZCA9IGVudGl0eS5pZDtcbiAgICB0aGlzLmNvbXBvbmVudHMgPSBlbnRpdHkuY29tcG9uZW50cy50b0RldkNvbXBvbmVudHMoKSxcbiAgICB0aGlzLnRhZ3MgPSBbLi4uZW50aXR5LnRhZ3NdO1xuXG4gICAgY29uc3QgY29tcE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRzKTtcblxuICAgIGZvciAoY29uc3QgW3N5c3RlbU5hbWUsIGNOYW1lc10gb2Ygd29ybGQuc3lzdGVtcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUpIHtcbiAgICAgIGlmIChjTmFtZXMuZXZlcnkoKGNOYW1lKSA9PiBjb21wTmFtZXMuaW5jbHVkZXMoY05hbWUpKSkge1xuICAgICAgICB0aGlzLnN5c3RlbXMucHVzaChzeXN0ZW1OYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b1RhYmxlUm93KCk6IERldkVudGl0eVRhYmxlUm93IHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBjb21wb25lbnRzOiBPYmplY3Qua2V5cyh0aGlzLmNvbXBvbmVudHMpLmpvaW4oXCIsIFwiKSxcbiAgICAgIHRhZ3M6IHRoaXMudGFncy5qb2luKFwiLCBcIiksXG4gICAgICBzeXN0ZW1zOiB0aGlzLnN5c3RlbXMuam9pbignLCAnKSxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERldkVudGl0eTtcbiIsImV4cG9ydCB0eXBlIFN0YXRlID0gc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sO1xuXG5leHBvcnQgdHlwZSBUcmFuc2l0aW9uczxTIGV4dGVuZHMgU3RhdGU+ID0gUmVjb3JkPFMsIChjdXJyZW50OiBTKSA9PiBTPjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltcGxlRlNNPFMgZXh0ZW5kcyBTdGF0ZT4ge1xuICBjdXJyZW50OiBTO1xuXG4gIGluaXRpYWw6IFM7XG5cbiAgdHJhbnNpdGlvbnM6IFRyYW5zaXRpb25zPFM+O1xuXG4gIGNvbnN0cnVjdG9yKGluaXRpYWxTdGF0ZTogUywgdHJhbnNpdGlvbnM6IFRyYW5zaXRpb25zPFM+KSB7XG4gICAgdGhpcy5pbml0aWFsID0gaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMuY3VycmVudCA9IGluaXRpYWxTdGF0ZTtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnM7XG4gIH1cblxuICBuZXh0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25zW3RoaXMuY3VycmVudF0pIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMudHJhbnNpdGlvbnNbdGhpcy5jdXJyZW50XSh0aGlzLmN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuaW5pdGlhbDtcbiAgfVxuXG4gIGlzKGNoZWNrU3RhdGU6IFMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09PSBjaGVja1N0YXRlO1xuICB9XG5cbiAgaW5jbHVkZXMoY2hlY2tTdGF0ZUFycjogU1tdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGNoZWNrU3RhdGVBcnIuc29tZShzID0+IHRoaXMuY3VycmVudCA9PT0gcyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgV29ybGQgZnJvbSBcIi4vV29ybGRcIjtcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gXCIuL0NvbXBvbmVudENvbGxlY3Rpb25cIjtcbmltcG9ydCB7IFRhZyB9IGZyb20gXCIuL1RhZ1wiO1xuLy8gaW1wb3J0IHsgQ29tcFR5cGVzIH0gZnJvbSAnaW50ZXJmYWNlcyc7XG5pbXBvcnQgRGV2RW50aXR5IGZyb20gXCIuL0RldkVudGl0eVwiO1xuXG5pbXBvcnQgU2ltcGxlRlNNIGZyb20gXCIuL1NpbXBsZUZTTVwiO1xuXG5leHBvcnQgdHlwZSBFbnRpdHlJZCA9IHN0cmluZztcblxudHlwZSBDbGFzczxUPiA9IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQgfTtcblxudHlwZSBFbnRpdHlTdGF0ZSA9XG4gIHwgXCJjcmVhdGluZ1wiXG4gIHwgXCJjcmVhdGVkXCJcbiAgfCBcImRlc3Ryb3lpbmdcIlxuICB8IFwiZGVzdHJveWVkXCJcbiAgfCBcImVycm9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudGl0eTxDVCBleHRlbmRzIENsYXNzPGFueT4+IHtcbiAgcHJpdmF0ZSBfaWQ6IHN0cmluZztcbiAgcHJpdmF0ZSBfd29ybGQ6IFdvcmxkPENUPjtcblxuICBwcml2YXRlIF9lcnJvcjogRXJyb3IgfCBudWxsO1xuXG4gIHByaXZhdGUgX3N0YXRlOiBTaW1wbGVGU008RW50aXR5U3RhdGU+O1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZDxDVD4pIHtcbiAgICB0aGlzLl9pZCA9IHV1aWR2NCgpO1xuICAgIHRoaXMuX3dvcmxkID0gd29ybGQ7XG5cbiAgICB0aGlzLl9lcnJvciA9IG51bGw7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBTaW1wbGVGU008RW50aXR5U3RhdGU+KFwiY3JlYXRpbmdcIiwge1xuICAgICAgY3JlYXRpbmc6ICgpID0+ICh0aGlzLl9lcnJvciA/IFwiZXJyb3JcIiA6IFwiY3JlYXRlZFwiKSxcbiAgICAgIGNyZWF0ZWQ6ICgpID0+IFwiZGVzdHJveWluZ1wiLFxuICAgICAgZGVzdHJveWluZzogKCkgPT4gKHRoaXMuX2Vycm9yID8gXCJlcnJvclwiIDogXCJkZXN0cm95ZWRcIiksXG4gICAgICBkZXN0cm95ZWQ6ICgpID0+IFwiZGVzdHJveWVkXCIsXG4gICAgICBlcnJvcjogKCkgPT4gXCJlcnJvclwiLFxuICAgIH0pO1xuXG4gICAgLypcbiAgICBSZWdpc3RlcmluZyB3aXRoIHRoZSBXb3JsZC5cbiAgICAqL1xuICAgIHRoaXMuX3dvcmxkLnJlZ2lzdGVyRW50aXR5KHRoaXMpO1xuXG4gICAgdGhpcy5fc3RhdGUubmV4dCgpIC8vIGNyZWF0ZWRcblxuICAgIHRoaXMub25DcmVhdGUoKTtcblxuICB9XG5cbiAgZ2V0IHN0YXRlKCk6IEVudGl0eVN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuY3VycmVudDtcbiAgfVxuXG4gIGNoZWNrU3RhdGUocG9zc2libGVTdGF0ZTogRW50aXR5U3RhdGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaXMocG9zc2libGVTdGF0ZSk7XG4gIH1cblxuICAvKiBMaWZlQ3ljbGUgbWV0aG9kcywgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiAqL1xuXG4gIG9uQ3JlYXRlKCk6IHZvaWQge1xuICAgIC8vIGFic3RyYWN0XG4gIH1cblxuICBvbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIG9uQ29tcG9uZW50QWRkKCk6IHZvaWQge1xuICAgIC8vIGFic3RyYWN0XG4gIH1cblxuICBvbkNvbXBvbmVudFVwZGF0ZSgpOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25Db21wb25lbnRSZW1vdmUoKTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBjb21wb25lbnQgdG8gYW4gRW50aXR5LCBkb2guXG4gICAqL1xuICBhZGQoY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8Q1Q+KTogdGhpcyB7XG4gICAgdGhpcy5fd29ybGQuc2V0KHRoaXMuX2lkLCBjb21wb25lbnQpO1xuXG4gICAgaWYgKGNvbXBvbmVudFtTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQuaXNUcmFja2VkXCIpXSkge1xuICAgICAgY29tcG9uZW50W1N5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5zZXRXb3JsZFwiKV0odGhpcy5fd29ybGQpO1xuXG4gICAgICBjb21wb25lbnRbU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50Lm9uQWRkXCIpXSh0aGlzLl93b3JsZCwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgdGFnIHRvIGEgY29tcG9uZW50XG4gICAqL1xuICBhZGRUYWcodGFnOiBUYWcpOiB0aGlzIHtcbiAgICBjb25zdCBlbnRpdHlTZXQgPSB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5oYXModGFnKVxuICAgICAgPyB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5nZXQodGFnKVxuICAgICAgOiBuZXcgU2V0PEVudGl0eUlkPigpO1xuXG4gICAgaWYgKGVudGl0eVNldCkge1xuICAgICAgZW50aXR5U2V0LmFkZCh0aGlzLl9pZCk7XG4gICAgICB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5zZXQodGFnLCBlbnRpdHlTZXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYW4gZW50aXR5IGhhcyBhIGNvbXBvbmVudCByZWxhdGVkIHRvIGl0LlxuICAgKi9cbiAgaGFzKGNUeXBlOiBDVCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHxcbiAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgcmV0dXJuIGNjLmhhcyhjVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIGFuIGVudGl0eSB0YWdnZWQgd2l0aCBhIGdpdmVuIHRhZy5cbiAgICovXG4gIGhhc1RhZyh0YWc6IFRhZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5oYXModGFnKSkge1xuICAgICAgY29uc3QgZW50aXR5U2V0ID0gdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZyk7XG4gICAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICAgIHJldHVybiBlbnRpdHlTZXQuaGFzKHRoaXMuX2lkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgY29tcG9uZW50IHRoYXQgYmVsb25ncyB0byBhbiBlbnRpdHkuXG4gICAqL1xuICBnZXQ8VD4oY2w6IENsYXNzPFQ+KTogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHxcbiAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvblxuICAgKi9cbiAgZ2V0QWxsKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNvbXBvbmVudCBmcm9tIGFuIGVudGl0eS5cbiAgICogQHBhcmFtIGNUeXBlIEEgY29tcG9uZW50IGNsYXNzLCBlZyBNeUNvbXBvbmVudFxuICAgKi9cbiAgcmVtb3ZlKGNUeXBlOiBDVCk6IHRoaXMge1xuICAgIHRoaXMuX3dvcmxkLnJlbW92ZSh0aGlzLl9pZCwgY1R5cGUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdGFnIGZyb20gYW4gZW50aXR5XG4gICAqL1xuICByZW1vdmVUYWcodGFnOiBUYWcpOiB0aGlzIHtcbiAgICBpZiAodGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuaGFzKHRhZykpIHtcbiAgICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICAgIGlmIChlbnRpdHlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENsZWFycyBhbGwgY29tcG9uZW50cyBmcm9tIGFuIEVudGl0eSAqL1xuICBjbGVhcigpOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5jbGVhckVudGl0eUNvbXBvbmVudHModGhpcy5faWQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0YWdzIG9uIGFuIGVudGl0eVxuICAgKi9cbiAgY2xlYXJUYWdzKCk6IHRoaXMge1xuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5lbnRyaWVzKCkpIHtcbiAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICBpZiAoZW50aXR5U2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fc3RhdGUuaXMoXCJjcmVhdGVkXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRWNzdGF0aWM6IFVuYWJsZSB0byBkZXN0cm95IGlmIGl0IGlzbid0IGNyZWF0ZWQsIG9yIGFscmVhZHkgZGVzdHJveWVkXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUubmV4dCgpOyAvLyBkZXN0cm95aW5nXG5cbiAgICAvLyBUaGlzIHdpbGwgcHJvYmFibHkgYmUgZGVmZXJyZWQgc28gdGhhdCBTeXN0ZW1zIGNhbiB3b3JrIG9uIGl0LlxuICAgIHRoaXMuX3dvcmxkLmRlc3Ryb3lFbnRpdHkodGhpcy5faWQpOyAvLyBzaG91bGQgcmV0dXJuIGFuIGVycm9yPz9cblxuICAgIHRoaXMub25EZXN0cm95KCk7IC8vIGFzc3VtaW5nIGZvciBub3cgdGhhdCB0aGlzIGlzIGJlc3QgZG9uZSBhZnRlciBhY3R1YWxseSByZW1vdmluZyB0aGUgZW50aXR5IGZyb20gdGhlIHdvcmxkLlxuXG4gICAgaWYgKHRoaXMuX3N0YXRlLmlzKFwiZGVzdHJveWluZ1wiKSkge1xuICAgICAgdGhpcy5fc3RhdGUubmV4dCgpOyAvLyBkZXN0cm95ZWRcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlLmlzKFwiZXJyb3JcIikgJiYgdGhpcy5fZXJyb3IpIHtcbiAgICAgIC8vIERvIHNvbWV0aGluZyB3aXRoIGVycm9yISFcbiAgICB9XG4gIH1cblxuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cblxuICBnZXQgd29ybGQoKTogV29ybGQ8Q1Q+IHtcbiAgICByZXR1cm4gdGhpcy5fd29ybGQ7XG4gIH1cblxuICBkZXN0cm95SW1tZWRpYXRlbHkoKTogdm9pZCB7XG4gICAgLy8gcGxhY2Vob2xkZXIgZm9yIG1ldGhvZCB0aGF0IGRvZXNuJ3Qgd2FpdCBmb3IgZW50aXR5IHRvIGdvIHRocm91Z2ggdGhlIG5vcm1hbFxuICAgIC8vIGRlc3RvcnkgcGlwZWxpbmUgYW5kIHByb2Nlc3MuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvbi5cbiAgICogRG9lcyB0aGUgc2FtZSB0aGluZyBhcyBlbnRpdHlJbnN0YW5jZS5nZXRBbGwoKS5cbiAgICovXG4gIGdldCBjb21wb25lbnRzKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgdGhlIHRhZ3MgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhpcyBlbnRpdHkuXG4gICAqL1xuICBnZXQgdGFncygpOiBTZXQ8VGFnPiB7XG4gICAgY29uc3QgdGFncyA9IG5ldyBTZXQ8VGFnPigpO1xuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKHRoaXMuX2lkKSkge1xuICAgICAgICB0YWdzLmFkZCh0YWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YWdzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgRW50aXR5IHRvIGEgRGV2RW50aXR5LiBWZXJ5IGhlbHBmdWwgaW4gZm9yIGRlYnVnZ2luZy5cbiAgICovXG4gIHRvRGV2RW50aXR5KCk6IERldkVudGl0eTxDVD4ge1xuICAgIHJldHVybiBuZXcgRGV2RW50aXR5PENUPih0aGlzLCB0aGlzLl93b3JsZCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVudGl0eTxDVCBleHRlbmRzIENsYXNzPGFueT4+KFxuICB3b3JsZDogV29ybGQ8Q1Q+XG4pOiBFbnRpdHk8Q1Q+IHtcbiAgY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eTxDVD4od29ybGQpO1xuXG4gIHJldHVybiBlbnRpdHk7XG59XG4iLCJpbXBvcnQgV29ybGQsIHsgQ2xhc3MgfSBmcm9tICcuL1dvcmxkJztcbmltcG9ydCBEZXZFbnRpdHkgZnJvbSAnLi9EZXZFbnRpdHknO1xuXG5pbnRlcmZhY2UgRGV2U3lzdGVtQ29tcHMge1xuICBzeXN0ZW06IHN0cmluZztcbiAgY29tcG9uZW50czogc3RyaW5nO1xufVxuXG5cbmNsYXNzIERldlRvb2xzPENUIGV4dGVuZHMgQ2xhc3M8YW55Pj4ge1xuICB3b3JsZDogV29ybGQ8Q1Q+O1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZDxDVD4pIHtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gIH1cbiAgLyoqXG4gICAqIGRpc3BsYXkgdGhlIGFsbCBzeXN0ZW1zIG9mIHRoZSB3b3JsZCwgYW5kIHRoZSBjb21wb25lbnRzIHJlcXVpcmVkIGJ5IGVhY2ggc3lzdGVtLlxuICAgKiBTdXBlciBoZWxwZnVsIHRvIHVzZSB3aXRoIGNvbnNvbGUudGFibGUoKVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuc3lzdGVtQ29tcG9uZW50cyk7XG4gICAqIGBgYFxuICAgKi9cbiAgZ2V0IHN5c3RlbUNvbXBvbmVudHMoKTogRGV2U3lzdGVtQ29tcHNbXSB7XG4gICAgY29uc3QgY29tcHNCeVN5c3RlbXMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgW3N5c3RlbSwgY29tcE5hbWVzXSBvZiB0aGlzLndvcmxkLnN5c3RlbXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lKSB7XG4gICAgICBjb21wc0J5U3lzdGVtcy5wdXNoKHsgc3lzdGVtLCBjb21wb25lbnRzOiBjb21wTmFtZXMuam9pbihcIiwgXCIpIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wc0J5U3lzdGVtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYXJyYXkgb2YgRGV2RW50aXRlcy4gQ2FuIGJlIHZlcnkgaGVscGZ1bCBmb3IgdGhpbmdzIGxpa2UgaW5zcGVjdGluZyBjb21wb25lbnQgc3RhdGUsXG4gICAqIGFuZCB3aGljaCBzeXN0ZW1zIHdpbGwgYmUgY2FsbGVkIG9uIGFuIGVudGl0eS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIGNvbnNvbGUudGFibGUod29ybGQuZGV2LmVudGl0aWVzKTtcbiAgICpcbiAgICogLy8gUHJvIHRpcCEgdHJ5IGRpc3BsYXlpbmcgYSB0YWJsZSBvZiBlbnRpdGllcyB3aXRoIGNvbnNvbGUudGFibGUgYW5kIERldkVudGl0eS50b1RhYmxlUm93KCkuXG4gICAqIGNvbnNvbGUudGFibGUod29ybGQuZGV2LmVudGl0aWVzLm1hcChkZXZFbnRpdHkgPT4gZGV2RW50aXR5LnRvVGFibGVSb3coKSkpO1xuICAgKiBgYGBcbiAgICovXG5cbiAgZ2V0IGVudGl0aWVzKCk6IERldkVudGl0eTxDVD5bXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLndvcmxkLmVudGl0aWVzLnZhbHVlcygpXS5tYXAoKGUpID0+IGUudG9EZXZFbnRpdHkoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGV2VG9vbHM7XG4iLCJpbXBvcnQgRW50aXR5LCB7IEVudGl0eUlkIH0gZnJvbSBcIi4vRW50aXR5XCI7XG5pbXBvcnQgV29ybGQsIHsgQ2xhc3MgfSBmcm9tIFwiLi9Xb3JsZFwiO1xuaW1wb3J0IENvbXBvbmVudENvbGxlY3Rpb24gZnJvbSBcIi4vQ29tcG9uZW50Q29sbGVjdGlvblwiO1xuXG4vKipcbiAqIEFyZ3VtZW50cyB0aGF0IGFyZSBwYXNzZWQgaW50byBhIFN5c3RlbSBmdW5jdGlvbiBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAqIFRoaXMgaXMgaG93IHlvdSBhY2NlcyB0aGluZ3MgbGlrZSB0aGUgZW50aXR5IHRoYXQgcGFydGljdWxhciBlbnRpdHkgdG8gYWN0IG9uLFxuICogYXMgd2VsbCBhcyBzb21lIG90aGVyIGhlbHBmdWwgcGFyYW1zIGxpa2UgaWYgdGhlIGVudGl0eSBpcyB0aGUgZmlyc3Qgb3IgbGFzdCBlbnRpdHlcbiAqIGluIHRoZSBncm91cCBvZiBlbnRpdGllcyB0aGF0IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3lzdGVtRnVuY0FyZ3M8Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PiB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBlbnRpdHkgYmVpbmcgaXRlcmF0ZWQuXG4gICAqL1xuICBlbnRpdHk6IEVudGl0eTxDVD47XG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB0aGF0IGJlbG9uZyB0byB0aGUgZW50aXR5XG4gICAqL1xuICBjb21wb25lbnRzOiBDb21wb25lbnRDb2xsZWN0aW9uPENUPjtcbiAgLyoqXG4gICAqIFRoZSBXb3JsZCBpbnN0YW5jZS5cbiAgICogVXNlIHRoaXMgdG8gYWNjZXNzIG90aGVyIGVudGl0aWVzLlxuICAgKi9cbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICAvKipcbiAgICogSXMgdGhlIGZpcnN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogSGVscGZ1bCBmb3Igc2V0dGluZyB1cCBzdGF0ZSB0aGF0IGlzIHRoZSBzYW1lIGZvciBhbGwgZW50aXRpZXMgb25seSBvbmNlLlxuICAgKi9cbiAgaXNGaXJzdDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIElzIHRoZSBsYXN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogQ2FuIGJlIGhlbHBmdWwgdG8gdGVhciBkb3duIGFueXRoaW5nIHRoYXQgc2hvdWxkIGJlIGRlYWx0IHdpdGggYWZ0ZXIgYWxsIHRoZSBlbnRpdGVzIGhhdmUgcmFuLlxuICAgKi9cbiAgaXNMYXN0OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBzeXN0ZW0gaXMgcnVuLlxuICovXG5leHBvcnQgdHlwZSBTeXN0ZW1GdW5jPENUIGV4dGVuZHMgQ2xhc3M8Q1Q+PiA9IChcbiAgc3l0ZW1GdW5jQXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+XG4pID0+IHZvaWQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbXM8Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PiB7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG5cbiAgc3lzdGVtRnVuY0J5U3lzdGVtTmFtZTogTWFwPHN0cmluZywgU3lzdGVtRnVuYzxDVD4+OyAvLyBkb3VibGUgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgbWFwcyBhcmUgb3JkZXJlZC5cblxuICBjb21wTmFtZXNCeVN5c3RlbU5hbWU6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPjtcblxuICBjb25zdHJ1Y3Rvcih3b3JsZDogV29ybGQ8Q1Q+KSB7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMuc3lzdGVtRnVuY0J5U3lzdGVtTmFtZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbXBOYW1lc0J5U3lzdGVtTmFtZSA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGFkZChjVHlwZXM6IENUW10sIHN5c3RlbUZ1bmM6IFN5c3RlbUZ1bmM8Q1Q+LCBmdW5jTmFtZT86IHN0cmluZyk6IHRoaXMge1xuICAgIGNvbnN0IGNOYW1lcyA9IGNUeXBlcy5tYXAoKGN0KSA9PiBjdC5uYW1lKTtcblxuICAgIFxuICAgIGxldCBuYW1lID0gc3lzdGVtRnVuYy5uYW1lO1xuICAgIGlmIChzeXN0ZW1GdW5jLm5hbWUgPT09ICcnKSB7XG4gICAgICAvLyBTdXBlciBicnV0ZSBmb3JjZSwgYW5kIG1pZ2h0IGxlYWQgdG8gZXJyb3JzIGluIHRoZSBmdXR1cmUsIGJ1dCBmb3Igbm93XG4gICAgICAvLyB1c2luZyB0aGUgc3RyaW5naWZpZWQgc3lzdGVtIGZ1bmN0aW9uIGlmIHRoZSBmdW5jdGlvbiBkb2Vzbid0IGFscmVhZHkgaGF2ZSBhIG5hbWUuXG4gICAgICAvLyBUaGlzIGlzIHVzZWZ1bCBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB1c2VkIGFzIGEgc3lzdGVtIGZ1bmN0aW9uLlxuICAgICAgLy8gTWlnaHQgYmUgZ29vZCB0byBmaWd1cmUgb3V0IGhvdyB0byBnZXQgYSBoYXNoIG9mIHRoZSBmdW5jdGlvbiBzdHJpbmcuXG4gICAgICBuYW1lID0gc3lzdGVtRnVuYy50b1N0cmluZygpLnNsaWNlKDAsIDMwKTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY05hbWUpIHtcbiAgICAgIG5hbWUgPSBmdW5jTmFtZTtcbiAgICB9XG5cbiAgICB0aGlzLnN5c3RlbUZ1bmNCeVN5c3RlbU5hbWUuc2V0KG5hbWUsIHN5c3RlbUZ1bmMpO1xuICAgIHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lLnNldChuYW1lLCBjTmFtZXMpO1xuICAgIHRoaXMud29ybGQuZW50aXRpZXNCeUNUeXBlcy5zZXQoY05hbWVzLCBuZXcgU2V0PEVudGl0eUlkPigpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcnVuKCk6IHZvaWQge1xuXG4gICAgLy8gVE9ETzogTWlnaHQgYmUgY29vbCB0byBhZGQgYSB3YXkgdG8gc3RvcCB0aGUgc3lzdGVtcyBsb29wIHdoZW4gaW4gZGV2LlxuICAgIC8vICAgICAgIE1heWJlIHNvbWV0aGluZyBsaWtlIHdvcmxkLmRldi5zdG9wKCkgb3IgcGF1c2UoKS5cbiAgICBmb3IgKGNvbnN0IFtcbiAgICAgIGZ1bmNOYW1lLFxuICAgICAgc3lzdGVtRnVuYyxcbiAgICBdIG9mIHRoaXMuc3lzdGVtRnVuY0J5U3lzdGVtTmFtZS5lbnRyaWVzKCkpIHtcbiAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy53b3JsZC5lbnRpdGllc0J5Q1R5cGVzLnNpemU7XG4gICAgICBjb25zdCBjTmFtZXMgPSB0aGlzLmNvbXBOYW1lc0J5U3lzdGVtTmFtZS5nZXQoZnVuY05hbWUpIHx8IFtdO1xuICAgICAgY29uc3QgY1R5cGVBcnJzID0gdGhpcy53b3JsZC5lbnRpdGllc0J5Q1R5cGVzLmdldChjTmFtZXMpIHx8IG5ldyBTZXQoKTtcblxuICAgICAgZm9yIChjb25zdCBlaWQgb2YgY1R5cGVBcnJzKSB7XG4gICAgICAgIGNvbnN0IGFyZ3M6IFN5c3RlbUZ1bmNBcmdzPENUPiA9IHtcbiAgICAgICAgICBlbnRpdHk6IHRoaXMud29ybGQuZW50aXRpZXMuZ2V0KGVpZCkgfHwgbmV3IEVudGl0eTxDVD4odGhpcy53b3JsZCksXG4gICAgICAgICAgY29tcG9uZW50czpcbiAgICAgICAgICAgIHRoaXMud29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHxcbiAgICAgICAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpLFxuICAgICAgICAgIHdvcmxkOiB0aGlzLndvcmxkLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgaXNGaXJzdDogaW5kZXggPT09IDAsXG4gICAgICAgICAgaXNMYXN0OiBpbmRleCArIDEgPT09IHNpemUsXG4gICAgICAgIH07XG5cbiAgICAgICAgc3lzdGVtRnVuYyhhcmdzKTtcblxuICAgICAgICBpbmRleCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IEVudGl0eSwgeyBFbnRpdHlJZCB9IGZyb20gXCIuL0VudGl0eVwiO1xuaW1wb3J0IENvbXBvbmVudENvbGxlY3Rpb24gZnJvbSBcIi4vQ29tcG9uZW50Q29sbGVjdGlvblwiO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSBcIi4vVGFnXCI7XG5pbXBvcnQgeyBTeXN0ZW1GdW5jIH0gZnJvbSBcIi4vU3lzdGVtc1wiO1xuaW1wb3J0IERldlRvb2xzIGZyb20gXCIuL0RldlRvb2xzXCI7XG5pbXBvcnQgU3lzdGVtcyBmcm9tICcuL1N5c3RlbXMnO1xuXG5leHBvcnQgdHlwZSBDbGFzczxUPiA9IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQgfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV29ybGQ8Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PiB7XG4gIGNvbXBvbmVudENvbGxlY3Rpb25zOiBNYXA8RW50aXR5SWQsIENvbXBvbmVudENvbGxlY3Rpb248Q1Q+PiA9IG5ldyBNYXAoKTtcblxuICBlbnRpdGllczogTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+PiA9IG5ldyBNYXAoKTtcblxuICBlbnRpdGllc0J5Q1R5cGVzOiBNYXA8c3RyaW5nW10sIFNldDxFbnRpdHlJZD4+ID0gbmV3IE1hcCgpO1xuXG4gIGVudGl0aWVzQnlUYWdzOiBNYXA8VGFnLCBTZXQ8RW50aXR5SWQ+PiA9IG5ldyBNYXAoKTtcblxuICBzeXN0ZW1zOiBTeXN0ZW1zPENUPjtcblxuICBkZXY6IERldlRvb2xzPENUPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRldiA9IG5ldyBEZXZUb29scyh0aGlzKTtcbiAgICB0aGlzLnN5c3RlbXMgPSBuZXcgU3lzdGVtcyh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcImZpbmRzXCIgYSBzaW5nbGUgZW50aXR5IGJhc2VkIG9uIGEgcHJlZGljYXRlXG4gICAqL1xuICBmaW5kID0gKHByZWRpY2F0ZTogKGVudGl0eTogRW50aXR5PENUPikgPT4gYm9vbGVhbik6IEVudGl0eTxDVD4gfCBudWxsID0+IHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogXCJmaW5kc1wiIGFsbCBlbnRpdGllcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSwga2luZGEgbGlrZSBmaWx0ZXIuXG4gICAqL1xuICBmaW5kQWxsID0gKHByZWRpY2F0ZTogKGVudGl0eTogRW50aXR5PENUPikgPT4gYm9vbGVhbik6IEVudGl0eTxDVD5bXSA9PiB7XG4gICAgY29uc3QgcmVzdWx0czogRW50aXR5PENUPltdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGVudGl0eSkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFwibG9jYXRlc1wiIGEgc2luZ2xlIGVudGl0eSBiYXNlZCBvbiBpdHMgQ29tcG9uZW50cy5cbiAgICovXG4gIGxvY2F0ZSA9IChjbDogQ1QgfCBDVFtdKTogRW50aXR5PENUPiB8IG51bGwgPT4ge1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHkuY29tcG9uZW50cy5oYXMoY2wpKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvY2F0ZXMgYWxsIGVudGl0aWVzIHRoYXQgY29udGFpbiB0aGUgY29tcG9uZW50cyBuYW1lZFxuICAgKi9cbiAgbG9jYXRlQWxsID0gKGNsOiBDVCB8IENUW10pOiBFbnRpdHk8Q1Q+W10gPT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6IEVudGl0eTxDVD5bXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVudGl0eS5jb21wb25lbnRzLmhhcyhjbCkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdyYWJzIHRoZSBmaXJzdCBlbnRpdHksIGFuZCBpdHMgcmVsYXRlZCBjb21wb25lbnQsIHRoYXQgbWF0Y2hlcyB0aGUgY29tcG9uZW50IHR5cGUuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zdCB7IGVudGl0eSwgY29tcG9uZW50IH0gPSB3b3JsZC5ncmFiKE15Q29tcG9uZW50KTtcbiAgICogYGBgXG4gICAqL1xuICBncmFiID0gPFQ+KFxuICAgIGNsOiBDbGFzczxUPlxuICApOiB7IGVudGl0eTogRW50aXR5PENUPjsgY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPiB9IHwgbnVsbCA9PiB7XG4gICAgLy8gY29uc3QgZW50aXR5ID0gdGhpcy5sb2NhdGUoKGNsIGFzIHVua25vd24pIGFzIENUW2tleW9mIENUXSk7XG4gICAgY29uc3QgZW50aXR5ID0gdGhpcy5sb2NhdGUoKGNsIGFzIHVua25vd24pIGFzIENUKTtcblxuICAgIGlmIChlbnRpdHkpIHtcbiAgICAgIGNvbnN0IGNjID1cbiAgICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZW50aXR5LmlkKSB8fFxuICAgICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW50aXR5LFxuICAgICAgICBjb21wb25lbnQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHcmFiIHNpbmdsZSBjb21wb25lbnQgYmFzZWQgb24gY29tcG9uZW50IHR5cGUgYW5kIHByZWRpY2F0ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCB7IGVudGl0eSwgY29tcG9uZW50IH0gPSB3b3JsZC5ncmFiQnkoRmlyc3RDb21wb25lbnQsIChjb21wKSA9PiBjb21wLmlkID09ICdhd2Vzb21lJylcbiAgICogYGBgXG4gICAqL1xuICBncmFiQnkgPSA8VD4oXG4gICAgY2w6IENsYXNzPFQ+LFxuICAgIHByZWRpY2F0ZTogKGNvbXA6IEluc3RhbmNlVHlwZTx0eXBlb2YgY2w+KSA9PiBib29sZWFuXG4gICk6IHsgZW50aXR5OiBFbnRpdHk8Q1Q+OyBjb21wb25lbnQ6IEluc3RhbmNlVHlwZTx0eXBlb2YgY2w+IH0gfCBudWxsID0+IHtcbiAgICBjb25zdCBlbnRpdGllcyA9IHRoaXMubG9jYXRlQWxsKChjbCBhcyB1bmtub3duKSBhcyBDVCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgY2MgPVxuICAgICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlbnRpdHkuaWQpIHx8XG4gICAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgICBjb25zdCBjb21wb25lbnQgPSBjYy5nZXQ8VD4oY2wpO1xuXG4gICAgICBpZiAocHJlZGljYXRlKGNvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgZW50aXR5LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHcmFiIGFsbCB0aGUgY29tcG9uZW50cyBwcmltYXJpbHksIGFuZCB0aGUgZW50aXRpZXMgaWYgbmVlZGVkXG4gICAqL1xuICBncmFiQWxsID0gPFQ+KFxuICAgIGNsOiBDbGFzczxUPlxuICApOiB7IGVudGl0eTogRW50aXR5PENUPjsgY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPiB9W10gPT4ge1xuICAgIGNvbnN0IGVudGl0aWVzID0gdGhpcy5sb2NhdGVBbGwoKGNsIGFzIHVua25vd24pIGFzIENUKTtcblxuICAgIHJldHVybiBlbnRpdGllcy5tYXAoKGVudGl0eSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW50aXR5LFxuICAgICAgICBjb21wb25lbnQ6IGVudGl0eS5jb21wb25lbnRzLmdldDxUPihjbCksXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhbiBlbnRpdHkgaWQgYW5kIGNvbXBvbmVudFR5cGUsIHJldHVybnMgY29tcG9uZW50XG4gICAqL1xuICBnZXQgPSA8VD4oZWlkOiBFbnRpdHlJZCwgY2w6IENsYXNzPFQ+KTogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gPT4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICByZXR1cm4gY2MuZ2V0PFQ+KGNsKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhbmQgZ2V0IHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCwgd2l0aG91dCBhbnkgYXNzb2NpYXRlZCBlbnRpdGllcy5cbiAgICogSGVscGZ1bCBpcyB5b3Uga25vdyB0aGF0IG9ubHkgb25lIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IGV4aXN0cyBhY3Jvc3MgYWxsIGVudGl0aWVzLlxuICAgKiBAcGFyYW0gY2wgQ29tcG9uZW50IENsYXNzIENvbnRydWN0b3JcbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBIGRlZmF1bHQgY29tcG9uZW50IGluc3RhbmNlIGlmIG5vIGNvbXBvbmVudHMgYXJlIGZvdW5kLlxuICAgKi9cbiAgZ2V0Q29tcG9uZW50ID0gPFQ+KFxuICAgIGNsOiBDbGFzczxUPixcbiAgICBkZWZhdWx0VmFsdWU/OiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPlxuICApOiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPiB8IG51bGwgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ3JhYihjbCk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSA/IGRlZmF1bHRWYWx1ZSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5jb21wb25lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBlbnRpdHkgdGhhdCBoYXMgYmVlbiB0YWdnZWQgd2l0aCB0aGUgZ2l2ZW4gdGFnLCBvciByZXR1cm4gbnVsbDtcbiAgICovXG4gIGdldFRhZ2dlZCA9ICh0YWc6IFRhZyk6IEVudGl0eTxDVD4gfCBudWxsID0+IHtcbiAgICBjb25zdCB0YWdFbnRpdHlJZHMgPSB0aGlzLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgaWYgKHRhZ0VudGl0eUlkcykge1xuICAgICAgY29uc3QgZW50aXR5SWQgPSB0YWdFbnRpdHlJZHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG5cbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0dCBhbGwgZW50aXRpZXMgdGhhdCBoYXZlIGJlZW4gdGFnZ2VkIHdpdGggdGhlIGdpdmVuIHRhZy5cbiAgICogQHBhcmFtIHRhZyBBIHN0cmluZyBvciBudW1iZXIuXG4gICAqL1xuICBnZXRBbGxUYWdnZWQgPSAodGFnOiBUYWcpOiBFbnRpdHk8Q1Q+W10gPT4ge1xuICAgIGxldCBlbnRpdGllczogRW50aXR5PENUPltdID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNvbnN0IHRhZ0VudGl0eUlkcyA9IHRoaXMuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZyk7XG5cbiAgICBpZiAodGFnRW50aXR5SWRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIHRhZ0VudGl0eUlkcykge1xuICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG4gICAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW50aXRpZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGNvbXBvbmVudCBvbiB0aGUgZ2l2ZW4gZW50aXR5XG4gICAqL1xuICBzZXQgPSAoZWlkOiBFbnRpdHlJZCwgY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8Q1Q+KTogdGhpcyA9PiB7XG4gICAgY29uc3QgY2MgPVxuICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZWlkKSB8fCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIGNjLmFkZChjb21wb25lbnQpO1xuXG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZWlkLCBjYyk7XG5cbiAgICBmb3IgKGNvbnN0IFtjdEFyciwgZW50aXR5U2V0XSBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMpIHtcbiAgICAgIGlmICgoY3RBcnIgYXMgc3RyaW5nW10pLmV2ZXJ5KGNjLmhhc0J5TmFtZSkpIHtcbiAgICAgICAgZW50aXR5U2V0LmFkZChlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjb21wb25lbnQgZnJvbSB0aGUgZ2l2ZW4gZW50aXR5LlxuICAgKiBOT1RFOiBUaGlzIHdpbGwgY2hhbmdlIHdoYXQgc3lzdGVtcyB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgZW50aXR5LlxuICAgKi9cbiAgcmVtb3ZlID0gKGVpZDogRW50aXR5SWQsIGNUeXBlOiBDVCk6IHRoaXMgPT4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICAvLyByZW1vdmUgZW50aXR5IGZyb20gY3VycmVudCBlbnRpdGllc0J5Q1R5cGVzXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYy5yZW1vdmUoY1R5cGUpO1xuXG4gICAgLy8gTW92ZSBlbnRpdHlJZCB0byBuZXcgQ1R5cGVzIGlmIG5lZWRlZC5cbiAgICBmb3IgKGNvbnN0IFtjdEFyciwgZW50aXR5U2V0XSBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMpIHtcbiAgICAgIGlmICgoY3RBcnIgYXMgc3RyaW5nW10pLmV2ZXJ5KGNjLmhhc0J5TmFtZSkpIHtcbiAgICAgICAgZW50aXR5U2V0LmFkZChlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbHRlcm5hdGl2ZSBtZXRob2QgZm9yIGFkZGluZyBzeXN0ZW1zLlxuICAgKi9cbiAgYWRkU3lzdGVtKGNUeXBlczogQ1RbXSwgc3lzdGVtRnVuYzogU3lzdGVtRnVuYzxDVD4sIGZ1bmNOYW1lPzogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy5zeXN0ZW1zLmFkZChjVHlwZXMsIHN5c3RlbUZ1bmMsIGZ1bmNOYW1lKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVnaXN0ZXJFbnRpdHkoZW50aXR5OiBFbnRpdHk8Q1Q+KTogV29ybGQ8Q1Q+IHtcbiAgICBjb25zdCBjYyA9IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZW50aXR5LmlkLCBjYyk7XG4gICAgdGhpcy5lbnRpdGllcy5zZXQoZW50aXR5LmlkLCBlbnRpdHkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBjb21wb25lbnRzIHRoYXQgYmVsb25nIHRvIGFuIGVudGl0eS5cbiAgICovXG4gIGNsZWFyRW50aXR5Q29tcG9uZW50cyhlaWQ6IEVudGl0eUlkKTogdGhpcyB7XG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZWlkLCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKSk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eVNldCBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVpZCkpIHtcbiAgICAgICAgZW50aXR5U2V0LmRlbGV0ZShlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlbnRpdHkgdGhhdCBpcyBpbiB0aGUgd29ybGQuXG4gICAqIEJhc2ljYWxseSBqdXN0IG5ldyBFbnRpdHkod29ybGQpLCBidXQgc2F2ZXMgYW4gaW1wb3J0IG9mIEVudGl0eS5cbiAgICovXG4gIGNyZWF0ZUVudGl0eSgpOiBFbnRpdHk8Q1Q+IHtcbiAgICBjb25zdCBlbnRpdHkgPSBuZXcgRW50aXR5KHRoaXMpO1xuXG4gICAgcmV0dXJuIGVudGl0eTtcblxuICAgIC8vIFJlZ2lzdGVyIGVudGl0eSBoZXJlLi4uLlxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGVudGl0eS5cbiAgICogU2FtZSBhcyBlbnRpdHkuZGVzdHJveSgpLlxuICAgKi9cbiAgZGVzdHJveUVudGl0eShlaWQ6IEVudGl0eUlkKTogV29ybGQ8Q1Q+IHtcbiAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmRlbGV0ZShlaWQpO1xuICAgIHRoaXMuZW50aXRpZXMuZGVsZXRlKGVpZCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eVNldCBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVpZCkpIHtcbiAgICAgICAgZW50aXR5U2V0LmRlbGV0ZShlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbnkgdGFnIGFzc29jaWF0aW9ucyB3aXRoIGRlc3Ryb3llZCBlbnRpdGllcy5cbiAgICBmb3IgKGNvbnN0IFt0YWcsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5VGFncykge1xuICAgICAgaWYgKGVudGl0eVNldC5oYXMoZWlkKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVpZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRpdHlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLmVudGl0aWVzQnlUYWdzLmRlbGV0ZSh0YWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCJpbXBvcnQgV29ybGQgZnJvbSAnLi9Xb3JsZCc7XG4vLyBpbXBvcnQgeyBjcmVhdGVFbnRpdHkgfSBmcm9tICcuL0VudGl0eSc7XG5cbmV4cG9ydCB7XG4gIFdvcmxkLFxuICAvLyBjcmVhdGVFbnRpdHksXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n')}])}));