!function(Q,B){"object"==typeof exports&&"object"==typeof module?module.exports=B():"function"==typeof define&&define.amd?define("ecstatic",[],B):"object"==typeof exports?exports.ecstatic=B():Q.ecstatic=B()}(window,(function(){return function(Q){var B=window.webpackHotUpdateecstatic;window.webpackHotUpdateecstatic=function(Q,n){!function(Q,B){if(!V[Q]||!a[Q])return;for(var n in a[Q]=!1,B)Object.prototype.hasOwnProperty.call(B,n)&&(b[n]=B[n]);0==--G&&0===u&&Z()}(Q,n),B&&B(Q,n)};var n,t=!0,e="e6edf0a52252f3b6cd65",F={},U=[],I=[];function c(Q){var B=N[Q];if(!B)return E;var t=function(t){return B.hot.active?(N[t]?-1===N[t].parents.indexOf(Q)&&N[t].parents.push(Q):(U=[Q],n=t),-1===B.children.indexOf(t)&&B.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+Q),U=[]),E(t)},e=function(Q){return{configurable:!0,enumerable:!0,get:function(){return E[Q]},set:function(B){E[Q]=B}}};for(var F in E)Object.prototype.hasOwnProperty.call(E,F)&&"e"!==F&&"t"!==F&&Object.defineProperty(t,F,e(F));return t.e=function(Q){return"ready"===l&&g("prepare"),u++,E.e(Q).then(B,(function(Q){throw B(),Q}));function B(){u--,"prepare"===l&&(y[Q]||R(Q),0===u&&0===G&&Z())}},t.t=function(Q,B){return 1&B&&(Q=t(Q)),E.t(Q,-2&B)},t}function s(B){var t={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:n!==B,active:!0,accept:function(Q,B){if(void 0===Q)t._selfAccepted=!0;else if("function"==typeof Q)t._selfAccepted=Q;else if("object"==typeof Q)for(var n=0;n<Q.length;n++)t._acceptedDependencies[Q[n]]=B||function(){};else t._acceptedDependencies[Q]=B||function(){}},decline:function(Q){if(void 0===Q)t._selfDeclined=!0;else if("object"==typeof Q)for(var B=0;B<Q.length;B++)t._declinedDependencies[Q[B]]=!0;else t._declinedDependencies[Q]=!0},dispose:function(Q){t._disposeHandlers.push(Q)},addDisposeHandler:function(Q){t._disposeHandlers.push(Q)},removeDisposeHandler:function(Q){var B=t._disposeHandlers.indexOf(Q);B>=0&&t._disposeHandlers.splice(B,1)},invalidate:function(){switch(this._selfInvalidated=!0,l){case"idle":(b={})[B]=Q[B],g("ready");break;case"ready":m(B);break;case"prepare":case"check":case"dispose":case"apply":(o=o||[]).push(B)}},check:X,apply:r,status:function(Q){if(!Q)return l;i.push(Q)},addStatusHandler:function(Q){i.push(Q)},removeStatusHandler:function(Q){var B=i.indexOf(Q);B>=0&&i.splice(B,1)},data:F[B]};return n=void 0,t}var i=[],l="idle";function g(Q){l=Q;for(var B=0;B<i.length;B++)i[B].call(null,Q)}var d,b,C,o,G=0,u=0,y={},a={},V={};function x(Q){return+Q+""===Q?+Q:Q}function X(Q){if("idle"!==l)throw new Error("check() is only allowed in idle status");return t=Q,g("check"),(B=1e4,B=B||1e4,new Promise((function(Q,n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var t=new XMLHttpRequest,e=E.p+"hot/hot-update.json";t.open("GET",e,!0),t.timeout=B,t.send(null)}catch(Q){return n(Q)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)n(new Error("Manifest request to "+e+" timed out."));else if(404===t.status)Q();else if(200!==t.status&&304!==t.status)n(new Error("Manifest request to "+e+" failed."));else{try{var B=JSON.parse(t.responseText)}catch(Q){return void n(Q)}Q(B)}}}))).then((function(Q){if(!Q)return g(L()?"ready":"idle"),null;a={},y={},V=Q.c,C=Q.h,g("prepare");var B=new Promise((function(Q,B){d={resolve:Q,reject:B}}));b={};return R(0),"prepare"===l&&0===u&&0===G&&Z(),B}));var B}function R(Q){var B;V[Q]?(a[Q]=!0,G++,(B=document.createElement("script")).charset="utf-8",B.src=E.p+"hot/hot-update.js",document.head.appendChild(B)):y[Q]=!0}function Z(){g("ready");var Q=d;if(d=null,Q)if(t)Promise.resolve().then((function(){return r(t)})).then((function(B){Q.resolve(B)}),(function(B){Q.reject(B)}));else{var B=[];for(var n in b)Object.prototype.hasOwnProperty.call(b,n)&&B.push(x(n));Q.resolve(B)}}function r(B){if("ready"!==l)throw new Error("apply() is only allowed in ready status");return function B(t){var I,c,s,i,l;function d(Q){for(var B=[Q],n={},t=B.map((function(Q){return{chain:[Q],id:Q}}));t.length>0;){var e=t.pop(),F=e.id,U=e.chain;if((i=N[F])&&(!i.hot._selfAccepted||i.hot._selfInvalidated)){if(i.hot._selfDeclined)return{type:"self-declined",chain:U,moduleId:F};if(i.hot._main)return{type:"unaccepted",chain:U,moduleId:F};for(var I=0;I<i.parents.length;I++){var c=i.parents[I],s=N[c];if(s){if(s.hot._declinedDependencies[F])return{type:"declined",chain:U.concat([c]),moduleId:F,parentId:c};-1===B.indexOf(c)&&(s.hot._acceptedDependencies[F]?(n[c]||(n[c]=[]),G(n[c],[F])):(delete n[c],B.push(c),t.push({chain:U.concat([c]),id:c})))}}}}return{type:"accepted",moduleId:Q,outdatedModules:B,outdatedDependencies:n}}function G(Q,B){for(var n=0;n<B.length;n++){var t=B[n];-1===Q.indexOf(t)&&Q.push(t)}}L();var u={},y=[],a={},X=function(){console.warn("[HMR] unexpected require("+Z.moduleId+") to disposed module")};for(var R in b)if(Object.prototype.hasOwnProperty.call(b,R)){var Z;l=x(R),Z=b[R]?d(l):{type:"disposed",moduleId:R};var r=!1,m=!1,W=!1,p="";switch(Z.chain&&(p="\nUpdate propagation: "+Z.chain.join(" -> ")),Z.type){case"self-declined":t.onDeclined&&t.onDeclined(Z),t.ignoreDeclined||(r=new Error("Aborted because of self decline: "+Z.moduleId+p));break;case"declined":t.onDeclined&&t.onDeclined(Z),t.ignoreDeclined||(r=new Error("Aborted because of declined dependency: "+Z.moduleId+" in "+Z.parentId+p));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(Z),t.ignoreUnaccepted||(r=new Error("Aborted because "+l+" is not accepted"+p));break;case"accepted":t.onAccepted&&t.onAccepted(Z),m=!0;break;case"disposed":t.onDisposed&&t.onDisposed(Z),W=!0;break;default:throw new Error("Unexception type "+Z.type)}if(r)return g("abort"),Promise.reject(r);if(m)for(l in a[l]=b[l],G(y,Z.outdatedModules),Z.outdatedDependencies)Object.prototype.hasOwnProperty.call(Z.outdatedDependencies,l)&&(u[l]||(u[l]=[]),G(u[l],Z.outdatedDependencies[l]));W&&(G(y,[Z.moduleId]),a[l]=X)}var A,h=[];for(c=0;c<y.length;c++)l=y[c],N[l]&&N[l].hot._selfAccepted&&a[l]!==X&&!N[l].hot._selfInvalidated&&h.push({module:l,parents:N[l].parents.slice(),errorHandler:N[l].hot._selfAccepted});g("dispose"),Object.keys(V).forEach((function(Q){!1===V[Q]&&function(Q){delete installedChunks[Q]}(Q)}));var S,D,v=y.slice();for(;v.length>0;)if(l=v.pop(),i=N[l]){var Y={},H=i.hot._disposeHandlers;for(s=0;s<H.length;s++)(I=H[s])(Y);for(F[l]=Y,i.hot.active=!1,delete N[l],delete u[l],s=0;s<i.children.length;s++){var k=N[i.children[s]];k&&((A=k.parents.indexOf(l))>=0&&k.parents.splice(A,1))}}for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=N[l]))for(D=u[l],s=0;s<D.length;s++)S=D[s],(A=i.children.indexOf(S))>=0&&i.children.splice(A,1);g("apply"),void 0!==C&&(e=C,C=void 0);for(l in b=void 0,a)Object.prototype.hasOwnProperty.call(a,l)&&(Q[l]=a[l]);var T=null;for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=N[l])){D=u[l];var z=[];for(c=0;c<D.length;c++)if(S=D[c],I=i.hot._acceptedDependencies[S]){if(-1!==z.indexOf(I))continue;z.push(I)}for(c=0;c<z.length;c++){I=z[c];try{I(D)}catch(Q){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:l,dependencyId:D[c],error:Q}),t.ignoreErrored||T||(T=Q)}}}for(c=0;c<h.length;c++){var J=h[c];l=J.module,U=J.parents,n=l;try{E(l)}catch(Q){if("function"==typeof J.errorHandler)try{J.errorHandler(Q)}catch(B){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:l,error:B,originalError:Q}),t.ignoreErrored||T||(T=B),T||(T=Q)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:l,error:Q}),t.ignoreErrored||T||(T=Q)}}if(T)return g("fail"),Promise.reject(T);if(o)return B(t).then((function(Q){return y.forEach((function(B){Q.indexOf(B)<0&&Q.push(B)})),Q}));return g("idle"),new Promise((function(Q){Q(y)}))}(B=B||{})}function L(){if(o)return b||(b={}),o.forEach(m),o=void 0,!0}function m(B){Object.prototype.hasOwnProperty.call(b,B)||(b[B]=Q[B])}var N={};function E(B){if(N[B])return N[B].exports;var n=N[B]={i:B,l:!1,exports:{},hot:s(B),parents:(I=U,U=[],I),children:[]};return Q[B].call(n.exports,n,n.exports,c(B)),n.l=!0,n.exports}return E.m=Q,E.c=N,E.d=function(Q,B,n){E.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:n})},E.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},E.t=function(Q,B){if(1&B&&(Q=E(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var n=Object.create(null);if(E.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var t in Q)E.d(n,t,function(B){return Q[B]}.bind(null,t));return n},E.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return E.d(B,"a",B),B},E.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},E.p="/static/",E.h=function(){return e},c(0)(E.s=0)}([function(Q,B,n){Q.exports=n(1)},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "World", function() { return /* reexport */ World_World; });\n__webpack_require__.d(__webpack_exports__, "trackComponent", function() { return /* reexport */ trackComponent; });\n\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== \'undefined\' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \'undefined\' && typeof msCrypto.getRandomValues === \'function\' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error(\'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js\n/* harmony default export */ var regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js\n\n\nfunction validate(uuid) {\n  return typeof uuid === \'string\' && regex.test(uuid);\n}\n\n/* harmony default export */ var esm_browser_validate = (validate);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var stringify_i = 0; stringify_i < 256; ++stringify_i) {\n  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It\'s been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \'-\' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \'-\' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \'-\' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \'-\' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it\'s likely due to one\n  // of the following:\n  // - One or more input array values don\'t map to a hex octet (leading to\n  // "undefined" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!esm_browser_validate(uuid)) {\n    throw TypeError(\'Stringified UUID is invalid\');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ var esm_browser_stringify = (stringify);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return esm_browser_stringify(rnds);\n}\n\n/* harmony default export */ var esm_browser_v4 = (v4);\n// CONCATENATED MODULE: ./src/guards.ts\nfunction isComponentInstance(Class, comp) {\n  if (!comp) {\n    return false;\n  }\n\n  if (!(comp instanceof Class)) {\n    return false;\n  }\n\n  return true;\n}\n// CONCATENATED MODULE: ./src/ComponentCollection.ts\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n// CT is a Union, like `type = FirstComponent | SecondComponent`.\nclass ComponentCollection_ComponentCollection {\n  constructor() {\n    _defineProperty(this, "components", new Map());\n\n    _defineProperty(this, "add", component => {\n      this.components.set(component.constructor.name, component);\n    });\n\n    _defineProperty(this, "update", (cl, func) => {\n      const c = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, c)) {\n        const updatedComponent = func(c);\n        this.components.set(cl.name, updatedComponent);\n      }\n    });\n\n    _defineProperty(this, "remove", cType => {\n      this.components.delete(cType.name);\n    });\n\n    _defineProperty(this, "get", cl => {\n      const comp = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, comp)) {\n        return comp;\n      } else {\n        throw new Error(`ComponentCollection does not have component of type ${cl.name}`);\n      }\n    });\n\n    _defineProperty(this, "has", cType => {\n      return Array.isArray(cType) ? cType.every(ct => this.components.has(ct.name) === true) : this.components.has(cType.name);\n    });\n\n    _defineProperty(this, "hasByName", cName => {\n      return Array.isArray(cName) ? cName.every(ct => this.components.has(ct) === true) : this.components.has(cName);\n    });\n  }\n\n  /**\n   * Get the component type names that are currently being used in the collection.\n   */\n  get componentTypes() {\n    return [...this.components.keys()];\n  }\n  /**\n   * Get the current number of components that are in the collection.\n   */\n\n\n  get size() {\n    return this.components.size;\n  }\n\n  toDevComponents() {\n    const obj = {};\n\n    for (const [compName, comp] of this.components) {\n      obj[compName] = comp;\n    }\n\n    return obj;\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevEntity.ts\nfunction DevEntity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevEntity {\n  constructor(entity, world) {\n    DevEntity_defineProperty(this, "id", void 0);\n\n    DevEntity_defineProperty(this, "components", void 0);\n\n    DevEntity_defineProperty(this, "tags", void 0);\n\n    DevEntity_defineProperty(this, "systems", []);\n\n    this.id = entity.id;\n    this.components = entity.components.toDevComponents(), this.tags = [...entity.tags];\n    const compNames = Object.keys(this.components);\n\n    for (const [systemName, cNames] of world.systems.compNamesBySystemName) {\n      if (cNames.every(cName => compNames.includes(cName))) {\n        this.systems.push(systemName);\n      }\n    }\n  }\n\n  toTableRow() {\n    return {\n      id: this.id,\n      components: Object.keys(this.components).join(", "),\n      tags: this.tags.join(", "),\n      systems: this.systems.join(\', \')\n    };\n  }\n\n}\n\n/* harmony default export */ var src_DevEntity = (DevEntity);\n// CONCATENATED MODULE: ./src/SimpleFSM.ts\nfunction SimpleFSM_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass SimpleFSM {\n  constructor(initialState, transitions) {\n    SimpleFSM_defineProperty(this, "current", void 0);\n\n    SimpleFSM_defineProperty(this, "inital", void 0);\n\n    SimpleFSM_defineProperty(this, "transitions", void 0);\n\n    this.inital = initialState;\n    this.current = initialState;\n    this.transitions = transitions;\n  }\n\n  next(data) {\n    if (this.transitions[this.current]) {\n      this.current = this.transitions[this.current](data, this.current);\n    }\n  }\n\n  reset() {\n    this.current = this.inital;\n  }\n\n  is(checkState) {\n    return this.current === checkState;\n  }\n\n}\n// CONCATENATED MODULE: ./src/Entity.ts\nfunction Entity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n// import { CompTypes } from \'interfaces\';\n\n\nclass Entity_Entity {\n  constructor(world) {\n    Entity_defineProperty(this, "_id", void 0);\n\n    Entity_defineProperty(this, "_world", void 0);\n\n    Entity_defineProperty(this, "_error", void 0);\n\n    Entity_defineProperty(this, "_state", void 0);\n\n    this._id = esm_browser_v4();\n    this._world = world;\n    this._error = null;\n    this._state = new SimpleFSM("creating", {\n      creating: () => this._error ? "error" : "created",\n      created: () => "destroying",\n      destroying: () => this._error ? "error" : "destroyed",\n      destroyed: () => "destroyed",\n      error: () => "error"\n    });\n    /*\n    Registering with the World.\n    */\n\n    this._world.registerEntity(this);\n\n    this._state.next(); // created\n\n\n    this.onCreate();\n  }\n\n  get state() {\n    return this._state.current;\n  }\n\n  checkState(possibleState) {\n    return this._state.is(possibleState);\n  }\n  /* LifeCycle methods, meant to be overridden */\n\n\n  onCreate() {// abstract\n  }\n\n  onDestroy() {// abstract\n  }\n\n  onComponentAdd() {// abstract\n  }\n\n  onComponentUpdate() {// abstract\n  }\n\n  onComponentRemove() {// abstract\n  }\n  /**\n   * Add a component to an Entity, doh.\n   */\n\n\n  add(component) {\n    this._world.add(this._id, component);\n\n    return this;\n  }\n  /**\n   * Add a tag to a component\n   */\n\n\n  addTag(tag) {\n    const entitySet = this._world.entitiesByTags.has(tag) ? this._world.entitiesByTags.get(tag) : new Set();\n\n    if (entitySet) {\n      entitySet.add(this._id);\n\n      this._world.entitiesByTags.set(tag, entitySet);\n    }\n\n    return this;\n  }\n  /**\n   * Determines if an entity has a component related to it.\n   */\n\n\n  has(cType) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    return cc.has(cType);\n  }\n  /**\n   * Check to see if an entity tagged with a given tag.\n   */\n\n\n  hasTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        return entitySet.has(this._id);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get a component that belongs to an entity.\n   */\n\n\n  get(cl) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    const component = cc.get(cl);\n    return component;\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection\n   */\n\n\n  getAll() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Remove a component from an entity.\n   * @param cType A component class, eg MyComponent\n   */\n\n\n  remove(cType) {\n    this._world.remove(this._id, cType);\n\n    return this;\n  }\n  /**\n   * Remove a tag from an entity\n   */\n\n\n  removeTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        entitySet.delete(this._id);\n\n        if (entitySet.size === 0) {\n          this._world.entitiesByTags.delete(tag);\n        }\n      }\n    }\n\n    return this;\n  }\n  /** Clears all components from an Entity */\n\n\n  clear() {\n    this._world.clearEntityComponents(this._id);\n\n    return this;\n  }\n  /**\n   * Remove all tags on an entity\n   */\n\n\n  clearTags() {\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      entitySet.delete(this._id);\n\n      if (entitySet.size === 0) {\n        this._world.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n  destroy() {\n    if (!this._state.is("created")) {\n      throw new Error("Ecstatic: Unable to destroy if it isn\'t created, or already destroyed");\n    }\n\n    this._state.next(); // destroying\n    // This will probably be deferred so that Systems can work on it.\n\n\n    this._world.destroyEntity(this._id); // should return an error??\n\n\n    this.onDestroy(); // assuming for now that this is best done after actually removing the entity from the world.\n\n    if (this._state.is("destroying")) {\n      this._state.next(); // destroyed\n\n    } else if (this._state.is("error") && this._error) {// Do something with error!!\n    }\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get world() {\n    return this._world;\n  }\n\n  destroyImmediately() {// placeholder for method that doesn\'t wait for entity to go through the normal\n    // destory pipeline and process.\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection.\n   * Does the same thing as entityInstance.getAll().\n   */\n\n\n  get components() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Retrieves all the tags that have been added to this entity.\n   */\n\n\n  get tags() {\n    const tags = new Set();\n\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      if (entitySet.has(this._id)) {\n        tags.add(tag);\n      }\n    }\n\n    return tags;\n  }\n  /**\n   * Convert Entity to a DevEntity. Very helpful in for debugging.\n   */\n\n\n  toDevEntity() {\n    return new src_DevEntity(this, this._world);\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevTools.ts\nfunction DevTools_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevTools {\n  constructor(world) {\n    DevTools_defineProperty(this, "world", void 0);\n\n    this.world = world;\n  }\n  /**\n   * display the all systems of the world, and the components required by each system.\n   * Super helpful to use with console.table()\n   * @example\n   * ```\n   * console.table(world.dev.systemComponents);\n   * ```\n   */\n\n\n  get systemComponents() {\n    const compsBySystems = [];\n\n    for (const [system, compNames] of this.world.systems.compNamesBySystemName) {\n      compsBySystems.push({\n        system,\n        components: compNames.join(", ")\n      });\n    }\n\n    return compsBySystems;\n  }\n  /**\n   * Create an array of DevEntites. Can be very helpful for things like inspecting component state,\n   * and which systems will be called on an entity.\n   * @example\n   * ```\n   * console.table(world.dev.entities);\n   *\n   * // Pro tip! try displaying a table of entities with console.table and DevEntity.toTableRow().\n   * console.table(world.dev.entities.map(devEntity => devEntity.toTableRow()));\n   * ```\n   */\n\n\n  get entities() {\n    return [...this.world.entities.values()].map(e => e.toDevEntity());\n  }\n\n}\n\n/* harmony default export */ var src_DevTools = (DevTools);\n// CONCATENATED MODULE: ./src/Systems.ts\nfunction Systems_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/**\n * Arguments that are passed into a System function on each iteration.\n * This is how you acces things like the entity that particular entity to act on,\n * as well as some other helpful params like if the entity is the first or last entity\n * in the group of entities that being iterated over.\n */\n\nclass Systems_Systems {\n  // double check to make sure that maps are ordered.\n  constructor(world) {\n    Systems_defineProperty(this, "world", void 0);\n\n    Systems_defineProperty(this, "systemFuncBySystemName", void 0);\n\n    Systems_defineProperty(this, "compNamesBySystemName", void 0);\n\n    this.world = world;\n    this.systemFuncBySystemName = new Map();\n    this.compNamesBySystemName = new Map();\n  }\n\n  add(cTypes, systemFunc, funcName) {\n    const cNames = cTypes.map(ct => ct.name);\n    let name = systemFunc.name;\n\n    if (systemFunc.name === \'\') {\n      // Super brute force, and might lead to errors in the future, but for now\n      // using the stringified system function if the function doesn\'t already have a name.\n      // This is useful for anonymous functions used as a system function.\n      // Might be good to figure out how to get a hash of the function string.\n      name = systemFunc.toString().slice(0, 30);\n    }\n\n    if (funcName) {\n      name = funcName;\n    }\n\n    this.systemFuncBySystemName.set(name, systemFunc);\n    this.compNamesBySystemName.set(name, cNames);\n    this.world.entitiesByCTypes.set(cNames, new Set());\n    return this;\n  }\n\n  run() {\n    // TODO: Might be cool to add a way to stop the systems loop when in dev.\n    //       Maybe something like world.dev.stop() or pause().\n    for (const [funcName, systemFunc] of this.systemFuncBySystemName.entries()) {\n      let index = 0;\n      const size = this.world.entitiesByCTypes.size;\n      const cNames = this.compNamesBySystemName.get(funcName) || [];\n      const cTypeArrs = this.world.entitiesByCTypes.get(cNames) || new Set();\n\n      for (const eid of cTypeArrs) {\n        const args = {\n          entity: this.world.entities.get(eid) || new Entity_Entity(this.world),\n          components: this.world.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(),\n          world: this.world,\n          index,\n          size,\n          isFirst: index === 0,\n          isLast: index + 1 === size\n        };\n        systemFunc(args);\n        index += 1;\n      }\n    }\n  }\n\n}\n// CONCATENATED MODULE: ./src/TrackedComponent.ts\n// Waiting for Typescript 4.2 to come out so that Symbols are supporded keys.\nconst TrackedCompSymbolKeys = {\n  isTracked: Symbol.for("ecs.trackedComponent.isTracked"),\n  world: Symbol.for("ecs.trackedComponent.world"),\n  setWorld: Symbol.for("ecs.trackedComponent.setWorld"),\n  onAdd: Symbol.for("ecs.trackedComponent.onAdd"),\n  onUpdate: Symbol.for("ecs.trackedComponent.onUpdate"),\n  onRemove: Symbol.for("ecs.trackedComponent.onRemove")\n}; //@ts-ignore\n\nfunction createClassInstanceProxyHandlers(trackedEventHandlers) {\n  const updatedProps = new Set();\n  return {\n    set(component, property, value) {\n      updatedProps.add(property); //@ts-ignore\n\n      const world = component[TrackedCompSymbolKeys.world];\n      const previousVal = component[property];\n      component[property] = value;\n\n      if (trackedEventHandlers.onUpdate) {\n        trackedEventHandlers.onUpdate({\n          world,\n          component,\n          previousVal,\n          property\n        });\n      }\n\n      return true;\n    }\n\n  };\n}\n\nfunction trackComponent(CompClass, trackedEventHandlers) {\n  return new Proxy(CompClass, {\n    construct(Component, args) {\n      const component = new Component(...args); // const component = new Component(...args) as T & TrackedComponent<Class<T>>;\n      // const component = new Component(...args) as InstanceType<Class<T>>;\n      // For use in identifing a "tracked" class through the proxy.\n      //@ts-ignore\n\n      component[TrackedCompSymbolKeys.isTracked] = true; //@ts-ignore\n\n      component[TrackedCompSymbolKeys.setWorld] = world => {\n        //@ts-ignore\n        component[TrackedCompSymbolKeys.world] = world;\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onAdd] = (world, entity) => {\n        if (trackedEventHandlers.onAdd) {\n          trackedEventHandlers.onAdd({\n            component,\n            world,\n            entity\n          });\n        }\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onRemove] = (world, entity) => {\n        if (trackedEventHandlers.onRemove) {\n          trackedEventHandlers.onRemove({\n            component,\n            world,\n            entity\n          });\n        }\n      };\n\n      return new Proxy(component, createClassInstanceProxyHandlers(trackedEventHandlers));\n    }\n\n  });\n}\n// CONCATENATED MODULE: ./src/World.ts\nfunction World_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nclass World_World {\n  constructor() {\n    World_defineProperty(this, "componentCollections", new Map());\n\n    World_defineProperty(this, "entities", new Map());\n\n    World_defineProperty(this, "entitiesByCTypes", new Map());\n\n    World_defineProperty(this, "entitiesByTags", new Map());\n\n    World_defineProperty(this, "systems", void 0);\n\n    World_defineProperty(this, "dev", void 0);\n\n    World_defineProperty(this, "find", predicate => {\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "findAll", predicate => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "locate", cl => {\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "locateAll", cl => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "grab", cl => {\n      const entity = this.locate(cl);\n\n      if (entity) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n        return {\n          entity,\n          component\n        };\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabBy", (cl, predicate) => {\n      const entities = this.locateAll(cl); // const entities = this.locateAll((cl as unknown) as CT);\n\n      for (const entity of entities) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n\n        if (predicate(component)) {\n          return {\n            component,\n            entity\n          };\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabAll", cl => {\n      const entities = this.locateAll(cl);\n      return entities.map(entity => {\n        return {\n          entity,\n          component: entity.components.get(cl)\n        };\n      });\n    });\n\n    World_defineProperty(this, "get", (eid, cl) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      return cc.get(cl);\n    });\n\n    World_defineProperty(this, "getComponent", (cl, defaultValue) => {\n      const result = this.grab(cl);\n\n      if (!result) {\n        return defaultValue ? defaultValue : null;\n      }\n\n      return result.component;\n    });\n\n    World_defineProperty(this, "getTagged", tag => {\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        const entityId = tagEntityIds.values().next().value;\n        const entity = this.entities.get(entityId);\n\n        if (entity) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "getAllTagged", tag => {\n      let entities = []; // eslint-disable-line\n\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        for (const entityId of tagEntityIds) {\n          const entity = this.entities.get(entityId);\n\n          if (entity) {\n            entities.push(entity);\n          }\n        }\n      }\n\n      return entities;\n    });\n\n    World_defineProperty(this, "add", (eid, component) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      cc.add(component);\n      this.componentCollections.set(eid, cc);\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      } // @ts-ignore\n\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        // @ts-ignore\n        component[TrackedCompSymbolKeys.setWorld](this);\n        const entity = this.entities.get(eid);\n\n        if (!entity) {\n          throw new Error(`world.add: Unable to locate entity. eid: ${eid}`);\n        } // @ts-ignore\n\n\n        component[TrackedCompSymbolKeys.onAdd](this, entity);\n      }\n\n      return this;\n    });\n\n    World_defineProperty(this, "remove", (eid, cType) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(); // need to get component instance...\n\n      const component = cc.get(cType); // @ts-ignore\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        const entity = this.entities.get(eid);\n\n        if (!entity) {\n          throw new Error(`world.remove: Unable to locate entity. eid: ${eid}, cType: ${cType.name}`);\n        } // @ts-ignore\n\n\n        component[TrackedCompSymbolKeys.onRemove](this, entity);\n      } // remove entity from current entitiesByCTypes\n\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.delete(eid);\n        }\n      }\n\n      cc.remove(cType); // Move entityId to new CTypes if needed.\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      return this;\n    });\n\n    this.dev = new src_DevTools(this);\n    this.systems = new Systems_Systems(this);\n  }\n  /**\n   * "finds" a single entity based on a predicate\n   */\n\n\n  /**\n   * Alternative method for adding systems.\n   */\n  addSystem(cTypes, systemFunc, funcName) {\n    this.systems.add(cTypes, systemFunc, funcName);\n    return this;\n  }\n\n  registerEntity(entity) {\n    const cc = new ComponentCollection_ComponentCollection();\n    this.componentCollections.set(entity.id, cc);\n    this.entities.set(entity.id, entity);\n    return this;\n  }\n  /**\n   * Remove all components that belong to an entity.\n   */\n\n\n  clearEntityComponents(eid) {\n    this.componentCollections.set(eid, new ComponentCollection_ComponentCollection());\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Create an entity that is in the world.\n   * Basically just new Entity(world), but saves an import of Entity.\n   */\n\n\n  createEntity() {\n    const entity = new Entity_Entity(this);\n    return entity; // Register entity here....\n  }\n  /**\n   * Destroys an entity.\n   * Same as entity.destroy().\n   */\n\n\n  destroyEntity(eid) {\n    this.componentCollections.delete(eid);\n    this.entities.delete(eid);\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    } // remove any tag associations with destroyed entities.\n\n\n    for (const [tag, entitySet] of this.entitiesByTags) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n\n      if (entitySet.size === 0) {\n        this.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n}\n// CONCATENATED MODULE: ./src/index.ts\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY3N0YXRpYy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzP2Q4ZjgiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzPzQwZDYiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzA2ZTQiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3N0cmluZ2lmeS5qcz81OGNmIiwid2VicGFjazovL2Vjc3RhdGljLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz9lYzI2Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL2d1YXJkcy50cz8zYjU3Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL0NvbXBvbmVudENvbGxlY3Rpb24udHM/NTFjNCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZFbnRpdHkudHM/ZDE0MiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9TaW1wbGVGU00udHM/NDY5OSIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9FbnRpdHkudHM/YWM2OCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZUb29scy50cz9lMDFhIiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL1N5c3RlbXMudHM/YTYxMyIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9UcmFja2VkQ29tcG9uZW50LnRzP2JhMjciLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9zcmMvV29ybGQudHM/Y2MwYiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9pbmRleC50cz9mZmI0Il0sIm5hbWVzIjpbImlzQ29tcG9uZW50SW5zdGFuY2UiLCJDbGFzcyIsImNvbXAiLCJDb21wb25lbnRDb2xsZWN0aW9uIiwiTWFwIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInNldCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNsIiwiZnVuYyIsImMiLCJnZXQiLCJ1cGRhdGVkQ29tcG9uZW50IiwiY1R5cGUiLCJkZWxldGUiLCJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwiY3QiLCJoYXMiLCJjTmFtZSIsImNvbXBvbmVudFR5cGVzIiwia2V5cyIsInNpemUiLCJ0b0RldkNvbXBvbmVudHMiLCJvYmoiLCJjb21wTmFtZSIsIkRldkVudGl0eSIsImVudGl0eSIsIndvcmxkIiwiaWQiLCJ0YWdzIiwiY29tcE5hbWVzIiwiT2JqZWN0Iiwic3lzdGVtTmFtZSIsImNOYW1lcyIsInN5c3RlbXMiLCJjb21wTmFtZXNCeVN5c3RlbU5hbWUiLCJpbmNsdWRlcyIsInB1c2giLCJ0b1RhYmxlUm93Iiwiam9pbiIsIlNpbXBsZUZTTSIsImluaXRpYWxTdGF0ZSIsInRyYW5zaXRpb25zIiwiaW5pdGFsIiwiY3VycmVudCIsIm5leHQiLCJkYXRhIiwicmVzZXQiLCJpcyIsImNoZWNrU3RhdGUiLCJFbnRpdHkiLCJfaWQiLCJ1dWlkdjQiLCJfd29ybGQiLCJfZXJyb3IiLCJfc3RhdGUiLCJjcmVhdGluZyIsImNyZWF0ZWQiLCJkZXN0cm95aW5nIiwiZGVzdHJveWVkIiwiZXJyb3IiLCJyZWdpc3RlckVudGl0eSIsIm9uQ3JlYXRlIiwic3RhdGUiLCJwb3NzaWJsZVN0YXRlIiwib25EZXN0cm95Iiwib25Db21wb25lbnRBZGQiLCJvbkNvbXBvbmVudFVwZGF0ZSIsIm9uQ29tcG9uZW50UmVtb3ZlIiwiYWRkIiwiYWRkVGFnIiwidGFnIiwiZW50aXR5U2V0IiwiZW50aXRpZXNCeVRhZ3MiLCJTZXQiLCJjYyIsImNvbXBvbmVudENvbGxlY3Rpb25zIiwiaGFzVGFnIiwiZ2V0QWxsIiwicmVtb3ZlIiwicmVtb3ZlVGFnIiwiY2xlYXIiLCJjbGVhckVudGl0eUNvbXBvbmVudHMiLCJjbGVhclRhZ3MiLCJlbnRyaWVzIiwiZGVzdHJveSIsImRlc3Ryb3lFbnRpdHkiLCJkZXN0cm95SW1tZWRpYXRlbHkiLCJ0b0RldkVudGl0eSIsIkRldlRvb2xzIiwic3lzdGVtQ29tcG9uZW50cyIsImNvbXBzQnlTeXN0ZW1zIiwic3lzdGVtIiwiZW50aXRpZXMiLCJ2YWx1ZXMiLCJtYXAiLCJlIiwiU3lzdGVtcyIsInN5c3RlbUZ1bmNCeVN5c3RlbU5hbWUiLCJjVHlwZXMiLCJzeXN0ZW1GdW5jIiwiZnVuY05hbWUiLCJ0b1N0cmluZyIsInNsaWNlIiwiZW50aXRpZXNCeUNUeXBlcyIsInJ1biIsImluZGV4IiwiY1R5cGVBcnJzIiwiZWlkIiwiYXJncyIsImlzRmlyc3QiLCJpc0xhc3QiLCJUcmFja2VkQ29tcFN5bWJvbEtleXMiLCJpc1RyYWNrZWQiLCJTeW1ib2wiLCJmb3IiLCJzZXRXb3JsZCIsIm9uQWRkIiwib25VcGRhdGUiLCJvblJlbW92ZSIsImNyZWF0ZUNsYXNzSW5zdGFuY2VQcm94eUhhbmRsZXJzIiwidHJhY2tlZEV2ZW50SGFuZGxlcnMiLCJ1cGRhdGVkUHJvcHMiLCJwcm9wZXJ0eSIsInZhbHVlIiwicHJldmlvdXNWYWwiLCJ0cmFja0NvbXBvbmVudCIsIkNvbXBDbGFzcyIsIlByb3h5IiwiY29uc3RydWN0IiwiQ29tcG9uZW50IiwiV29ybGQiLCJwcmVkaWNhdGUiLCJyZXN1bHRzIiwibG9jYXRlIiwibG9jYXRlQWxsIiwiZGVmYXVsdFZhbHVlIiwicmVzdWx0IiwiZ3JhYiIsInRhZ0VudGl0eUlkcyIsImVudGl0eUlkIiwiY3RBcnIiLCJoYXNCeU5hbWUiLCJkZXYiLCJhZGRTeXN0ZW0iLCJjcmVhdGVFbnRpdHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7O0FDbEJlLHdEQUFjLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEdBQUcseUNBQXlDLEU7O0FDQXJHOztBQUUvQjtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDOztBQUVlLGlFQUFRLEU7O0FDTmM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxXQUFDLEtBQUssQ0FBQyxXQUFDLE9BQU8sR0FBRyxXQUFDO0FBQzVCLGtCQUFrQixXQUFDO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseWdCQUF5Z0I7QUFDemdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU8sb0JBQVE7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRWUsbUVBQVMsRTs7QUM3Qkc7QUFDWTs7QUFFdkM7QUFDQTtBQUNBLCtDQUErQyxHQUFHLElBQUk7O0FBRXREO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLHFCQUFTO0FBQ2xCOztBQUVlLHFEQUFFLEU7O0FDdkJWLFNBQVNBLG1CQUFULENBQ0xDLEtBREssRUFFTEMsSUFGSyxFQUcrQjtBQUNwQyxNQUFJLENBQUNBLElBQUwsRUFBVztBQUNULFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQUksRUFBRUEsSUFBSSxZQUFZRCxLQUFsQixDQUFKLEVBQThCO0FBQzVCLFdBQU8sS0FBUDtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNELEM7Ozs7QUNiRDtBQUtBO0FBQ2UsTUFBTUUsdUNBQU4sQ0FBOEI7QUFBQTtBQUFBLHdDQUNYLElBQUlDLEdBQUosRUFEVzs7QUFBQSxpQ0FLcENDLFNBQUQsSUFBeUI7QUFDN0IsV0FBS0MsVUFBTCxDQUFnQkMsR0FBaEIsQ0FBMEJGLFNBQU4sQ0FBaUJHLFdBQWpCLENBQTZCQyxJQUFqRCxFQUF1REosU0FBdkQ7QUFDRCxLQVAwQzs7QUFBQSxvQ0FTbEMsQ0FDUEssRUFETyxFQUVQQyxJQUZPLEtBR0U7QUFDVCxZQUFNQyxDQUFDLEdBQUcsS0FBS04sVUFBTCxDQUFnQk8sR0FBaEIsQ0FBb0JILEVBQUUsQ0FBQ0QsSUFBdkIsQ0FBVjs7QUFFQSxVQUFJVCxtQkFBbUIsQ0FBQ1UsRUFBRCxFQUFLRSxDQUFMLENBQXZCLEVBQWdDO0FBQzlCLGNBQU1FLGdCQUFnQixHQUFHSCxJQUFJLENBQUNDLENBQUQsQ0FBN0I7QUFDQSxhQUFLTixVQUFMLENBQWdCQyxHQUFoQixDQUFvQkcsRUFBRSxDQUFDRCxJQUF2QixFQUE2QkssZ0JBQTdCO0FBQ0Q7QUFDRixLQW5CMEM7O0FBQUEsb0NBeUJqQ0MsS0FBRCxJQUF1QztBQUM5QyxXQUFLVCxVQUFMLENBQWdCVSxNQUFoQixDQUF1QkQsS0FBSyxDQUFDTixJQUE3QjtBQUNELEtBM0IwQzs7QUFBQSxpQ0FxQ3RCQyxFQUFmLElBQThDO0FBQ2xELFlBQU1SLElBQUksR0FBRyxLQUFLSSxVQUFMLENBQWdCTyxHQUFoQixDQUFvQkgsRUFBRSxDQUFDRCxJQUF2QixDQUFiOztBQUVBLFVBQUlULG1CQUFtQixDQUFJVSxFQUFKLEVBQVFSLElBQVIsQ0FBdkIsRUFBc0M7QUFDcEMsZUFBT0EsSUFBUDtBQUNELE9BRkQsTUFFTztBQUNMLGNBQU0sSUFBSWUsS0FBSixDQUNILHVEQUFzRFAsRUFBRSxDQUFDRCxJQUFLLEVBRDNELENBQU47QUFHRDtBQUNGLEtBL0MwQzs7QUFBQSxpQ0FpRXBDTSxLQUFELElBQW1FO0FBQ3ZFLGFBQU9HLEtBQUssQ0FBQ0MsT0FBTixDQUFjSixLQUFkLElBQ0hBLEtBQUssQ0FBQ0ssS0FBTixDQUFhQyxFQUFELElBQVEsS0FBS2YsVUFBTCxDQUFnQmdCLEdBQWhCLENBQW9CRCxFQUFFLENBQUNaLElBQXZCLE1BQWlDLElBQXJELENBREcsR0FFSCxLQUFLSCxVQUFMLENBQWdCZ0IsR0FBaEIsQ0FBb0JQLEtBQUssQ0FBQ04sSUFBMUIsQ0FGSjtBQUdELEtBckUwQzs7QUFBQSx1Q0E2RTlCYyxLQUFELElBQXVDO0FBQ2pELGFBQU9MLEtBQUssQ0FBQ0MsT0FBTixDQUFjSSxLQUFkLElBQ0hBLEtBQUssQ0FBQ0gsS0FBTixDQUFZQyxFQUFFLElBQUksS0FBS2YsVUFBTCxDQUFnQmdCLEdBQWhCLENBQW9CRCxFQUFwQixNQUE0QixJQUE5QyxDQURHLEdBRUgsS0FBS2YsVUFBTCxDQUFnQmdCLEdBQWhCLENBQW9CQyxLQUFwQixDQUZKO0FBR0QsS0FqRjBDO0FBQUE7O0FBbUYzQztBQUNGO0FBQ0E7QUFDb0IsTUFBZEMsY0FBYyxHQUFhO0FBQzdCLFdBQU8sQ0FBQyxHQUFHLEtBQUtsQixVQUFMLENBQWdCbUIsSUFBaEIsRUFBSixDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7OztBQUNVLE1BQUpDLElBQUksR0FBVztBQUNqQixXQUFPLEtBQUtwQixVQUFMLENBQWdCb0IsSUFBdkI7QUFDRDs7QUFFREMsaUJBQWUsR0FBdUI7QUFDcEMsVUFBTUMsR0FBdUIsR0FBRyxFQUFoQzs7QUFDQSxTQUFLLE1BQU0sQ0FBQ0MsUUFBRCxFQUFXM0IsSUFBWCxDQUFYLElBQStCLEtBQUtJLFVBQXBDLEVBQWdEO0FBQzlDc0IsU0FBRyxDQUFDQyxRQUFELENBQUgsR0FBZ0IzQixJQUFoQjtBQUNEOztBQUVELFdBQU8wQixHQUFQO0FBQ0Q7O0FBeEcwQyxDOzs7O0FDSzdDLE1BQU1FLFNBQU4sQ0FBb0I7QUFTbEJ0QixhQUFXLENBQUN1QixNQUFELEVBQXFCQyxLQUFyQixFQUF1QztBQUFBOztBQUFBOztBQUFBOztBQUFBLDhDQUY5QixFQUU4Qjs7QUFDaEQsU0FBS0MsRUFBTCxHQUFVRixNQUFNLENBQUNFLEVBQWpCO0FBQ0EsU0FBSzNCLFVBQUwsR0FBa0J5QixNQUFNLENBQUN6QixVQUFQLENBQWtCcUIsZUFBbEIsRUFBbEIsRUFDQSxLQUFLTyxJQUFMLEdBQVksQ0FBQyxHQUFHSCxNQUFNLENBQUNHLElBQVgsQ0FEWjtBQUdBLFVBQU1DLFNBQVMsR0FBR0MsTUFBTSxDQUFDWCxJQUFQLENBQVksS0FBS25CLFVBQWpCLENBQWxCOztBQUVBLFNBQUssTUFBTSxDQUFDK0IsVUFBRCxFQUFhQyxNQUFiLENBQVgsSUFBbUNOLEtBQUssQ0FBQ08sT0FBTixDQUFjQyxxQkFBakQsRUFBd0U7QUFDdEUsVUFBSUYsTUFBTSxDQUFDbEIsS0FBUCxDQUFjRyxLQUFELElBQVdZLFNBQVMsQ0FBQ00sUUFBVixDQUFtQmxCLEtBQW5CLENBQXhCLENBQUosRUFBd0Q7QUFDdEQsYUFBS2dCLE9BQUwsQ0FBYUcsSUFBYixDQUFrQkwsVUFBbEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRURNLFlBQVUsR0FBc0I7QUFDOUIsV0FBTztBQUNMVixRQUFFLEVBQUUsS0FBS0EsRUFESjtBQUVMM0IsZ0JBQVUsRUFBRThCLE1BQU0sQ0FBQ1gsSUFBUCxDQUFZLEtBQUtuQixVQUFqQixFQUE2QnNDLElBQTdCLENBQWtDLElBQWxDLENBRlA7QUFHTFYsVUFBSSxFQUFFLEtBQUtBLElBQUwsQ0FBVVUsSUFBVixDQUFlLElBQWYsQ0FIRDtBQUlMTCxhQUFPLEVBQUUsS0FBS0EsT0FBTCxDQUFhSyxJQUFiLENBQWtCLElBQWxCO0FBSkosS0FBUDtBQU1EOztBQTlCaUI7O0FBaUNMZCwyREFBZixFOzs7O0FDckNlLE1BQU1lLFNBQU4sQ0FBZ0Q7QUFPN0RyQyxhQUFXLENBQUNzQyxZQUFELEVBQWtCQyxXQUFsQixFQUFrRDtBQUFBOztBQUFBOztBQUFBOztBQUMzRCxTQUFLQyxNQUFMLEdBQWNGLFlBQWQ7QUFDQSxTQUFLRyxPQUFMLEdBQWVILFlBQWY7QUFDQSxTQUFLQyxXQUFMLEdBQW1CQSxXQUFuQjtBQUNEOztBQUVERyxNQUFJLENBQUNDLElBQUQsRUFBaUI7QUFDbkIsUUFBSSxLQUFLSixXQUFMLENBQWlCLEtBQUtFLE9BQXRCLENBQUosRUFBb0M7QUFDbEMsV0FBS0EsT0FBTCxHQUFlLEtBQUtGLFdBQUwsQ0FBaUIsS0FBS0UsT0FBdEIsRUFBK0JFLElBQS9CLEVBQXFDLEtBQUtGLE9BQTFDLENBQWY7QUFDRDtBQUNGOztBQUVERyxPQUFLLEdBQVM7QUFDWixTQUFLSCxPQUFMLEdBQWUsS0FBS0QsTUFBcEI7QUFDRDs7QUFFREssSUFBRSxDQUFDQyxVQUFELEVBQXlCO0FBQ3pCLFdBQU8sS0FBS0wsT0FBTCxLQUFpQkssVUFBeEI7QUFDRDs7QUF6QjRELEM7Ozs7QUNQL0Q7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQVdlLE1BQU1DLGFBQU4sQ0FBaUI7QUFROUIvQyxhQUFXLENBQUN3QixLQUFELEVBQW1CO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQzVCLFNBQUt3QixHQUFMLEdBQVdDLGNBQU0sRUFBakI7QUFDQSxTQUFLQyxNQUFMLEdBQWMxQixLQUFkO0FBRUEsU0FBSzJCLE1BQUwsR0FBYyxJQUFkO0FBRUEsU0FBS0MsTUFBTCxHQUFjLElBQUlmLFNBQUosQ0FBMkIsVUFBM0IsRUFBdUM7QUFDbkRnQixjQUFRLEVBQUUsTUFBTyxLQUFLRixNQUFMLEdBQWMsT0FBZCxHQUF3QixTQURVO0FBRW5ERyxhQUFPLEVBQUUsTUFBTSxZQUZvQztBQUduREMsZ0JBQVUsRUFBRSxNQUFPLEtBQUtKLE1BQUwsR0FBYyxPQUFkLEdBQXdCLFdBSFE7QUFJbkRLLGVBQVMsRUFBRSxNQUFNLFdBSmtDO0FBS25EQyxXQUFLLEVBQUUsTUFBTTtBQUxzQyxLQUF2QyxDQUFkO0FBUUE7QUFDSjtBQUNBOztBQUNJLFNBQUtQLE1BQUwsQ0FBWVEsY0FBWixDQUEyQixJQUEzQjs7QUFFQSxTQUFLTixNQUFMLENBQVlWLElBQVosR0FuQjRCLENBbUJUOzs7QUFFbkIsU0FBS2lCLFFBQUw7QUFFRDs7QUFFUSxNQUFMQyxLQUFLLEdBQWdCO0FBQ3ZCLFdBQU8sS0FBS1IsTUFBTCxDQUFZWCxPQUFuQjtBQUNEOztBQUVESyxZQUFVLENBQUNlLGFBQUQsRUFBc0M7QUFDOUMsV0FBTyxLQUFLVCxNQUFMLENBQVlQLEVBQVosQ0FBZWdCLGFBQWYsQ0FBUDtBQUNEO0FBRUQ7OztBQUVBRixVQUFRLEdBQVMsQ0FDZjtBQUNEOztBQUVERyxXQUFTLEdBQVMsQ0FDaEI7QUFDRDs7QUFFREMsZ0JBQWMsR0FBUyxDQUNyQjtBQUNEOztBQUVEQyxtQkFBaUIsR0FBUyxDQUN4QjtBQUNEOztBQUVEQyxtQkFBaUIsR0FBUyxDQUN4QjtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDRUMsS0FBRyxDQUFDckUsU0FBRCxFQUFzQjtBQUN2QixTQUFLcUQsTUFBTCxDQUFZZ0IsR0FBWixDQUFnQixLQUFLbEIsR0FBckIsRUFBMEJuRCxTQUExQjs7QUFFQSxXQUFPLElBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ0VzRSxRQUFNLENBQUNDLEdBQUQsRUFBaUI7QUFDckIsVUFBTUMsU0FBUyxHQUFHLEtBQUtuQixNQUFMLENBQVlvQixjQUFaLENBQTJCeEQsR0FBM0IsQ0FBK0JzRCxHQUEvQixJQUNkLEtBQUtsQixNQUFMLENBQVlvQixjQUFaLENBQTJCakUsR0FBM0IsQ0FBK0IrRCxHQUEvQixDQURjLEdBRWQsSUFBSUcsR0FBSixFQUZKOztBQUlBLFFBQUlGLFNBQUosRUFBZTtBQUNiQSxlQUFTLENBQUNILEdBQVYsQ0FBYyxLQUFLbEIsR0FBbkI7O0FBQ0EsV0FBS0UsTUFBTCxDQUFZb0IsY0FBWixDQUEyQnZFLEdBQTNCLENBQStCcUUsR0FBL0IsRUFBb0NDLFNBQXBDO0FBQ0Q7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7OztBQUNFdkQsS0FBRyxDQUFDUCxLQUFELEVBQXVDO0FBQ3hDLFVBQU1pRSxFQUFFLEdBQ04sS0FBS3RCLE1BQUwsQ0FBWXVCLG9CQUFaLENBQWlDcEUsR0FBakMsQ0FBcUMsS0FBSzJDLEdBQTFDLEtBQ0EsSUFBSXJELHVDQUFKLEVBRkY7QUFJQSxXQUFPNkUsRUFBRSxDQUFDMUQsR0FBSCxDQUFPUCxLQUFQLENBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ0VtRSxRQUFNLENBQUNOLEdBQUQsRUFBb0I7QUFDeEIsUUFBSSxLQUFLbEIsTUFBTCxDQUFZb0IsY0FBWixDQUEyQnhELEdBQTNCLENBQStCc0QsR0FBL0IsQ0FBSixFQUF5QztBQUN2QyxZQUFNQyxTQUFTLEdBQUcsS0FBS25CLE1BQUwsQ0FBWW9CLGNBQVosQ0FBMkJqRSxHQUEzQixDQUErQitELEdBQS9CLENBQWxCOztBQUNBLFVBQUlDLFNBQUosRUFBZTtBQUNiLGVBQU9BLFNBQVMsQ0FBQ3ZELEdBQVYsQ0FBYyxLQUFLa0MsR0FBbkIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxLQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7OztBQUNFM0MsS0FBRyxDQUFlSCxFQUFmLEVBQWlFO0FBQ2xFLFVBQU1zRSxFQUFFLEdBQ04sS0FBS3RCLE1BQUwsQ0FBWXVCLG9CQUFaLENBQWlDcEUsR0FBakMsQ0FBcUMsS0FBSzJDLEdBQTFDLEtBQ0EsSUFBSXJELHVDQUFKLEVBRkY7QUFJQSxVQUFNRSxTQUFTLEdBQUcyRSxFQUFFLENBQUNuRSxHQUFILENBQVVILEVBQVYsQ0FBbEI7QUFFQSxXQUFPTCxTQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7OztBQUNFOEUsUUFBTSxHQUE0QjtBQUNoQyxXQUNFLEtBQUt6QixNQUFMLENBQVl1QixvQkFBWixDQUFpQ3BFLEdBQWpDLENBQXFDLEtBQUsyQyxHQUExQyxLQUNBLElBQUlyRCx1Q0FBSixFQUZGO0FBSUQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTs7O0FBQ0VpRixRQUFNLENBQUNyRSxLQUFELEVBQW9DO0FBQ3hDLFNBQUsyQyxNQUFMLENBQVkwQixNQUFaLENBQW1CLEtBQUs1QixHQUF4QixFQUE2QnpDLEtBQTdCOztBQUVBLFdBQU8sSUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDRXNFLFdBQVMsQ0FBQ1QsR0FBRCxFQUFpQjtBQUN4QixRQUFJLEtBQUtsQixNQUFMLENBQVlvQixjQUFaLENBQTJCeEQsR0FBM0IsQ0FBK0JzRCxHQUEvQixDQUFKLEVBQXlDO0FBQ3ZDLFlBQU1DLFNBQVMsR0FBRyxLQUFLbkIsTUFBTCxDQUFZb0IsY0FBWixDQUEyQmpFLEdBQTNCLENBQStCK0QsR0FBL0IsQ0FBbEI7O0FBRUEsVUFBSUMsU0FBSixFQUFlO0FBQ2JBLGlCQUFTLENBQUM3RCxNQUFWLENBQWlCLEtBQUt3QyxHQUF0Qjs7QUFFQSxZQUFJcUIsU0FBUyxDQUFDbkQsSUFBVixLQUFtQixDQUF2QixFQUEwQjtBQUN4QixlQUFLZ0MsTUFBTCxDQUFZb0IsY0FBWixDQUEyQjlELE1BQTNCLENBQWtDNEQsR0FBbEM7QUFDRDtBQUNGO0FBQ0Y7O0FBQ0QsV0FBTyxJQUFQO0FBQ0Q7QUFFRDs7O0FBQ0FVLE9BQUssR0FBUztBQUNaLFNBQUs1QixNQUFMLENBQVk2QixxQkFBWixDQUFrQyxLQUFLL0IsR0FBdkM7O0FBRUEsV0FBTyxJQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7OztBQUNFZ0MsV0FBUyxHQUFTO0FBQ2hCLFNBQUssTUFBTSxDQUFDWixHQUFELEVBQU1DLFNBQU4sQ0FBWCxJQUErQixLQUFLbkIsTUFBTCxDQUFZb0IsY0FBWixDQUEyQlcsT0FBM0IsRUFBL0IsRUFBcUU7QUFDbkVaLGVBQVMsQ0FBQzdELE1BQVYsQ0FBaUIsS0FBS3dDLEdBQXRCOztBQUVBLFVBQUlxQixTQUFTLENBQUNuRCxJQUFWLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLGFBQUtnQyxNQUFMLENBQVlvQixjQUFaLENBQTJCOUQsTUFBM0IsQ0FBa0M0RCxHQUFsQztBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7O0FBRURjLFNBQU8sR0FBUztBQUNkLFFBQUksQ0FBQyxLQUFLOUIsTUFBTCxDQUFZUCxFQUFaLENBQWUsU0FBZixDQUFMLEVBQWdDO0FBQzlCLFlBQU0sSUFBSXBDLEtBQUosQ0FDSix1RUFESSxDQUFOO0FBR0Q7O0FBRUQsU0FBSzJDLE1BQUwsQ0FBWVYsSUFBWixHQVBjLENBT007QUFFcEI7OztBQUNBLFNBQUtRLE1BQUwsQ0FBWWlDLGFBQVosQ0FBMEIsS0FBS25DLEdBQS9CLEVBVmMsQ0FVdUI7OztBQUVyQyxTQUFLYyxTQUFMLEdBWmMsQ0FZSTs7QUFFbEIsUUFBSSxLQUFLVixNQUFMLENBQVlQLEVBQVosQ0FBZSxZQUFmLENBQUosRUFBa0M7QUFDaEMsV0FBS08sTUFBTCxDQUFZVixJQUFaLEdBRGdDLENBQ1o7O0FBQ3JCLEtBRkQsTUFFTyxJQUFJLEtBQUtVLE1BQUwsQ0FBWVAsRUFBWixDQUFlLE9BQWYsS0FBMkIsS0FBS00sTUFBcEMsRUFBNEMsQ0FDakQ7QUFDRDtBQUNGOztBQUVLLE1BQUYxQixFQUFFLEdBQVc7QUFDZixXQUFPLEtBQUt1QixHQUFaO0FBQ0Q7O0FBRVEsTUFBTHhCLEtBQUssR0FBYztBQUNyQixXQUFPLEtBQUswQixNQUFaO0FBQ0Q7O0FBRURrQyxvQkFBa0IsR0FBUyxDQUN6QjtBQUNBO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTs7O0FBQ2dCLE1BQVZ0RixVQUFVLEdBQTRCO0FBQ3hDLFdBQ0UsS0FBS29ELE1BQUwsQ0FBWXVCLG9CQUFaLENBQWlDcEUsR0FBakMsQ0FBcUMsS0FBSzJDLEdBQTFDLEtBQ0EsSUFBSXJELHVDQUFKLEVBRkY7QUFJRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ1UsTUFBSitCLElBQUksR0FBYTtBQUNuQixVQUFNQSxJQUFJLEdBQUcsSUFBSTZDLEdBQUosRUFBYjs7QUFDQSxTQUFLLE1BQU0sQ0FBQ0gsR0FBRCxFQUFNQyxTQUFOLENBQVgsSUFBK0IsS0FBS25CLE1BQUwsQ0FBWW9CLGNBQVosQ0FBMkJXLE9BQTNCLEVBQS9CLEVBQXFFO0FBQ25FLFVBQUlaLFNBQVMsQ0FBQ3ZELEdBQVYsQ0FBYyxLQUFLa0MsR0FBbkIsQ0FBSixFQUE2QjtBQUMzQnRCLFlBQUksQ0FBQ3dDLEdBQUwsQ0FBU0UsR0FBVDtBQUNEO0FBQ0Y7O0FBRUQsV0FBTzFDLElBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ0UyRCxhQUFXLEdBQWtCO0FBQzNCLFdBQU8sSUFBSS9ELGFBQUosQ0FBa0IsSUFBbEIsRUFBd0IsS0FBSzRCLE1BQTdCLENBQVA7QUFDRDs7QUExUDZCLEM7Ozs7QUNUaEMsTUFBTW9DLFFBQU4sQ0FBbUI7QUFHakJ0RixhQUFXLENBQUN3QixLQUFELEVBQW1CO0FBQUE7O0FBQzVCLFNBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNEO0FBQ0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ3NCLE1BQWhCK0QsZ0JBQWdCLEdBQXFCO0FBQ3ZDLFVBQU1DLGNBQWMsR0FBRyxFQUF2Qjs7QUFFQSxTQUFLLE1BQU0sQ0FBQ0MsTUFBRCxFQUFTOUQsU0FBVCxDQUFYLElBQWtDLEtBQUtILEtBQUwsQ0FBV08sT0FBWCxDQUFtQkMscUJBQXJELEVBQTRFO0FBQzFFd0Qsb0JBQWMsQ0FBQ3RELElBQWYsQ0FBb0I7QUFBRXVELGNBQUY7QUFBVTNGLGtCQUFVLEVBQUU2QixTQUFTLENBQUNTLElBQVYsQ0FBZSxJQUFmO0FBQXRCLE9BQXBCO0FBQ0Q7O0FBRUQsV0FBT29ELGNBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVjLE1BQVJFLFFBQVEsR0FBb0I7QUFDOUIsV0FBTyxDQUFDLEdBQUcsS0FBS2xFLEtBQUwsQ0FBV2tFLFFBQVgsQ0FBb0JDLE1BQXBCLEVBQUosRUFBa0NDLEdBQWxDLENBQXVDQyxDQUFELElBQU9BLENBQUMsQ0FBQ1IsV0FBRixFQUE3QyxDQUFQO0FBQ0Q7O0FBdENnQjs7QUF5Q0pDLHlEQUFmLEU7Ozs7QUNsREE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFvQ2UsTUFBTVEsZUFBTixDQUFrQjtBQUdzQjtBQUlyRDlGLGFBQVcsQ0FBQ3dCLEtBQUQsRUFBbUI7QUFBQTs7QUFBQTs7QUFBQTs7QUFDNUIsU0FBS0EsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS3VFLHNCQUFMLEdBQThCLElBQUluRyxHQUFKLEVBQTlCO0FBQ0EsU0FBS29DLHFCQUFMLEdBQTZCLElBQUlwQyxHQUFKLEVBQTdCO0FBQ0Q7O0FBRURzRSxLQUFHLENBQUM4QixNQUFELEVBQWlDQyxVQUFqQyxFQUE2REMsUUFBN0QsRUFBc0Y7QUFDdkYsVUFBTXBFLE1BQU0sR0FBR2tFLE1BQU0sQ0FBQ0osR0FBUCxDQUFZL0UsRUFBRCxJQUFRQSxFQUFFLENBQUNaLElBQXRCLENBQWY7QUFHQSxRQUFJQSxJQUFJLEdBQUdnRyxVQUFVLENBQUNoRyxJQUF0Qjs7QUFDQSxRQUFJZ0csVUFBVSxDQUFDaEcsSUFBWCxLQUFvQixFQUF4QixFQUE0QjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxVQUFJLEdBQUdnRyxVQUFVLENBQUNFLFFBQVgsR0FBc0JDLEtBQXRCLENBQTRCLENBQTVCLEVBQStCLEVBQS9CLENBQVA7QUFDRDs7QUFFRCxRQUFJRixRQUFKLEVBQWM7QUFDWmpHLFVBQUksR0FBR2lHLFFBQVA7QUFDRDs7QUFFRCxTQUFLSCxzQkFBTCxDQUE0QmhHLEdBQTVCLENBQWdDRSxJQUFoQyxFQUFzQ2dHLFVBQXRDO0FBQ0EsU0FBS2pFLHFCQUFMLENBQTJCakMsR0FBM0IsQ0FBK0JFLElBQS9CLEVBQXFDNkIsTUFBckM7QUFDQSxTQUFLTixLQUFMLENBQVc2RSxnQkFBWCxDQUE0QnRHLEdBQTVCLENBQWdDK0IsTUFBaEMsRUFBd0MsSUFBSXlDLEdBQUosRUFBeEM7QUFFQSxXQUFPLElBQVA7QUFDRDs7QUFFRCtCLEtBQUcsR0FBUztBQUVWO0FBQ0E7QUFDQSxTQUFLLE1BQU0sQ0FDVEosUUFEUyxFQUVURCxVQUZTLENBQVgsSUFHSyxLQUFLRixzQkFBTCxDQUE0QmQsT0FBNUIsRUFITCxFQUc0QztBQUMxQyxVQUFJc0IsS0FBSyxHQUFHLENBQVo7QUFDQSxZQUFNckYsSUFBSSxHQUFHLEtBQUtNLEtBQUwsQ0FBVzZFLGdCQUFYLENBQTRCbkYsSUFBekM7QUFDQSxZQUFNWSxNQUFNLEdBQUcsS0FBS0UscUJBQUwsQ0FBMkIzQixHQUEzQixDQUErQjZGLFFBQS9CLEtBQTRDLEVBQTNEO0FBQ0EsWUFBTU0sU0FBUyxHQUFHLEtBQUtoRixLQUFMLENBQVc2RSxnQkFBWCxDQUE0QmhHLEdBQTVCLENBQWdDeUIsTUFBaEMsS0FBMkMsSUFBSXlDLEdBQUosRUFBN0Q7O0FBRUEsV0FBSyxNQUFNa0MsR0FBWCxJQUFrQkQsU0FBbEIsRUFBNkI7QUFDM0IsY0FBTUUsSUFBd0IsR0FBRztBQUMvQm5GLGdCQUFNLEVBQUUsS0FBS0MsS0FBTCxDQUFXa0UsUUFBWCxDQUFvQnJGLEdBQXBCLENBQXdCb0csR0FBeEIsS0FBZ0MsSUFBSTFELGFBQUosQ0FBZSxLQUFLdkIsS0FBcEIsQ0FEVDtBQUUvQjFCLG9CQUFVLEVBQ1IsS0FBSzBCLEtBQUwsQ0FBV2lELG9CQUFYLENBQWdDcEUsR0FBaEMsQ0FBb0NvRyxHQUFwQyxLQUNBLElBQUk5Ryx1Q0FBSixFQUo2QjtBQUsvQjZCLGVBQUssRUFBRSxLQUFLQSxLQUxtQjtBQU0vQitFLGVBTitCO0FBTy9CckYsY0FQK0I7QUFRL0J5RixpQkFBTyxFQUFFSixLQUFLLEtBQUssQ0FSWTtBQVMvQkssZ0JBQU0sRUFBRUwsS0FBSyxHQUFHLENBQVIsS0FBY3JGO0FBVFMsU0FBakM7QUFZQStFLGtCQUFVLENBQUNTLElBQUQsQ0FBVjtBQUVBSCxhQUFLLElBQUksQ0FBVDtBQUNEO0FBQ0Y7QUFDRjs7QUFwRThCLEM7O0FDMUNqQztBQUNPLE1BQU1NLHFCQUFxQixHQUFHO0FBQ25DQyxXQUFTLEVBQUVDLE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLGdDQUFYLENBRHdCO0FBRW5DeEYsT0FBSyxFQUFFdUYsTUFBTSxDQUFDQyxHQUFQLENBQVcsNEJBQVgsQ0FGNEI7QUFHbkNDLFVBQVEsRUFBRUYsTUFBTSxDQUFDQyxHQUFQLENBQVcsK0JBQVgsQ0FIeUI7QUFJbkNFLE9BQUssRUFBRUgsTUFBTSxDQUFDQyxHQUFQLENBQVcsNEJBQVgsQ0FKNEI7QUFLbkNHLFVBQVEsRUFBRUosTUFBTSxDQUFDQyxHQUFQLENBQVcsK0JBQVgsQ0FMeUI7QUFNbkNJLFVBQVEsRUFBRUwsTUFBTSxDQUFDQyxHQUFQLENBQVcsK0JBQVg7QUFOeUIsQ0FBOUIsQyxDQVNQOztBQStDQSxTQUFTSyxnQ0FBVCxDQUNFQyxvQkFERixFQUVxQjtBQUNuQixRQUFNQyxZQUFZLEdBQUcsSUFBSWhELEdBQUosRUFBckI7QUFDQSxTQUFPO0FBQ0x4RSxPQUFHLENBQ0RGLFNBREMsRUFFRDJILFFBRkMsRUFHREMsS0FIQyxFQUlEO0FBQ0FGLGtCQUFZLENBQUNyRCxHQUFiLENBQWlCc0QsUUFBakIsRUFEQSxDQUdBOztBQUNBLFlBQU1oRyxLQUFLLEdBQUczQixTQUFTLENBQ3JCZ0gscUJBQXFCLENBQUNyRixLQURELENBQXZCO0FBSUEsWUFBTWtHLFdBQVcsR0FBRzdILFNBQVMsQ0FBQzJILFFBQUQsQ0FBN0I7QUFFQTNILGVBQVMsQ0FBQzJILFFBQUQsQ0FBVCxHQUFzQkMsS0FBdEI7O0FBRUEsVUFBSUgsb0JBQW9CLENBQUNILFFBQXpCLEVBQW1DO0FBQ2pDRyw0QkFBb0IsQ0FBQ0gsUUFBckIsQ0FBOEI7QUFDNUIzRixlQUQ0QjtBQUU1QjNCLG1CQUY0QjtBQUc1QjZILHFCQUg0QjtBQUk1QkY7QUFKNEIsU0FBOUI7QUFNRDs7QUFFRCxhQUFPLElBQVA7QUFDRDs7QUEzQkksR0FBUDtBQTZCRDs7QUFFTSxTQUFTRyxjQUFULENBQ0xDLFNBREssRUFFTE4sb0JBRkssRUFHaUI7QUFDdEIsU0FBTyxJQUFJTyxLQUFKLENBQVVELFNBQVYsRUFBcUI7QUFDMUJFLGFBQVMsQ0FBQ0MsU0FBRCxFQUFpQnJCLElBQWpCLEVBQTRCO0FBQ25DLFlBQU03RyxTQUFTLEdBQUcsSUFBSWtJLFNBQUosQ0FBYyxHQUFHckIsSUFBakIsQ0FBbEIsQ0FEbUMsQ0FFbkM7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E3RyxlQUFTLENBQUNnSCxxQkFBcUIsQ0FBQ0MsU0FBdkIsQ0FBVCxHQUE2QyxJQUE3QyxDQVBtQyxDQVNuQzs7QUFDQWpILGVBQVMsQ0FBQ2dILHFCQUFxQixDQUFDSSxRQUF2QixDQUFULEdBQ0V6RixLQUQwQyxJQUV2QztBQUNIO0FBQ0EzQixpQkFBUyxDQUFDZ0gscUJBQXFCLENBQUNyRixLQUF2QixDQUFULEdBQXlDQSxLQUF6QztBQUNELE9BTEQsQ0FWbUMsQ0FpQm5DOzs7QUFDQTNCLGVBQVMsQ0FBQ2dILHFCQUFxQixDQUFDSyxLQUF2QixDQUFULEdBQXlDLENBQ3ZDMUYsS0FEdUMsRUFFdkNELE1BRnVDLEtBR3BDO0FBQ0gsWUFBSStGLG9CQUFvQixDQUFDSixLQUF6QixFQUFnQztBQUM5QkksOEJBQW9CLENBQUNKLEtBQXJCLENBQTJCO0FBQUVySCxxQkFBRjtBQUFhMkIsaUJBQWI7QUFBb0JEO0FBQXBCLFdBQTNCO0FBQ0Q7QUFDRixPQVBELENBbEJtQyxDQTJCbkM7OztBQUNBMUIsZUFBUyxDQUFDZ0gscUJBQXFCLENBQUNPLFFBQXZCLENBQVQsR0FBNEMsQ0FDMUM1RixLQUQwQyxFQUUxQ0QsTUFGMEMsS0FHdkM7QUFDSCxZQUFJK0Ysb0JBQW9CLENBQUNGLFFBQXpCLEVBQW1DO0FBQ2pDRSw4QkFBb0IsQ0FBQ0YsUUFBckIsQ0FBOEI7QUFBRXZILHFCQUFGO0FBQWEyQixpQkFBYjtBQUFvQkQ7QUFBcEIsV0FBOUI7QUFDRDtBQUNGLE9BUEQ7O0FBU0EsYUFBTyxJQUFJc0csS0FBSixDQUNMaEksU0FESyxFQUVMd0gsZ0NBQWdDLENBQUNDLG9CQUFELENBRjNCLENBQVA7QUFJRDs7QUExQ3lCLEdBQXJCLENBQVA7QUE0Q0QsQzs7OztBQy9JRDtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSWUsTUFBTVUsV0FBTixDQUFnQjtBQWE3QmhJLGFBQVcsR0FBRztBQUFBLHVEQVppRCxJQUFJSixHQUFKLEVBWWpEOztBQUFBLDJDQVZ3QixJQUFJQSxHQUFKLEVBVXhCOztBQUFBLG1EQVJtQyxJQUFJQSxHQUFKLEVBUW5DOztBQUFBLGlEQU40QixJQUFJQSxHQUFKLEVBTTVCOztBQUFBOztBQUFBOztBQUFBLHVDQVFOcUksU0FBRCxJQUFtRTtBQUN4RSxXQUFLLE1BQU0xRyxNQUFYLElBQXFCLEtBQUttRSxRQUFMLENBQWNDLE1BQWQsRUFBckIsRUFBNkM7QUFDM0MsWUFBSXNDLFNBQVMsQ0FBQzFHLE1BQUQsQ0FBYixFQUF1QjtBQUNyQixpQkFBT0EsTUFBUDtBQUNEO0FBQ0Y7O0FBRUQsYUFBTyxJQUFQO0FBQ0QsS0FoQmE7O0FBQUEsMENBcUJIMEcsU0FBRCxJQUE4RDtBQUN0RSxZQUFNQyxPQUFxQixHQUFHLEVBQTlCOztBQUVBLFdBQUssTUFBTTNHLE1BQVgsSUFBcUIsS0FBS21FLFFBQUwsQ0FBY0MsTUFBZCxFQUFyQixFQUE2QztBQUMzQyxZQUFJc0MsU0FBUyxDQUFDMUcsTUFBRCxDQUFiLEVBQXVCO0FBQ3JCMkcsaUJBQU8sQ0FBQ2hHLElBQVIsQ0FBYVgsTUFBYjtBQUNEO0FBQ0Y7O0FBRUQsYUFBTzJHLE9BQVA7QUFDRCxLQS9CYTs7QUFBQSx5Q0FvQ0poSSxFQUFELElBQTBFO0FBQ2pGLFdBQUssTUFBTXFCLE1BQVgsSUFBcUIsS0FBS21FLFFBQUwsQ0FBY0MsTUFBZCxFQUFyQixFQUE2QztBQUMzQyxZQUFJcEUsTUFBTSxDQUFDekIsVUFBUCxDQUFrQmdCLEdBQWxCLENBQXNCWixFQUF0QixDQUFKLEVBQStCO0FBQzdCLGlCQUFPcUIsTUFBUDtBQUNEO0FBQ0Y7O0FBRUQsYUFBTyxJQUFQO0FBQ0QsS0E1Q2E7O0FBQUEsNENBaUREckIsRUFBRCxJQUFxRTtBQUMvRSxZQUFNZ0ksT0FBcUIsR0FBRyxFQUE5Qjs7QUFFQSxXQUFLLE1BQU0zRyxNQUFYLElBQXFCLEtBQUttRSxRQUFMLENBQWNDLE1BQWQsRUFBckIsRUFBNkM7QUFDM0MsWUFBSXBFLE1BQU0sQ0FBQ3pCLFVBQVAsQ0FBa0JnQixHQUFsQixDQUFzQlosRUFBdEIsQ0FBSixFQUErQjtBQUM3QmdJLGlCQUFPLENBQUNoRyxJQUFSLENBQWFYLE1BQWI7QUFDRDtBQUNGOztBQUVELGFBQU8yRyxPQUFQO0FBQ0QsS0EzRGE7O0FBQUEsdUNBcUVaaEksRUFESyxJQUUyQztBQUNoRCxZQUFNcUIsTUFBTSxHQUFHLEtBQUs0RyxNQUFMLENBQVlqSSxFQUFaLENBQWY7O0FBRUEsVUFBSXFCLE1BQUosRUFBWTtBQUNWLGNBQU1pRCxFQUFFLEdBQ04sS0FBS0Msb0JBQUwsQ0FBMEJwRSxHQUExQixDQUE4QmtCLE1BQU0sQ0FBQ0UsRUFBckMsS0FDQSxJQUFJOUIsdUNBQUosRUFGRjtBQUlBLGNBQU1FLFNBQVMsR0FBRzJFLEVBQUUsQ0FBQ25FLEdBQUgsQ0FBVUgsRUFBVixDQUFsQjtBQUVBLGVBQU87QUFDTHFCLGdCQURLO0FBRUwxQjtBQUZLLFNBQVA7QUFJRDs7QUFFRCxhQUFPLElBQVA7QUFDRCxLQXZGYTs7QUFBQSx5Q0FpR0wsQ0FDUEssRUFETyxFQUVQK0gsU0FGTyxLQUd5QztBQUNoRCxZQUFNdkMsUUFBUSxHQUFHLEtBQUswQyxTQUFMLENBQWVsSSxFQUFmLENBQWpCLENBRGdELENBRWhEOztBQUVBLFdBQUssTUFBTXFCLE1BQVgsSUFBcUJtRSxRQUFyQixFQUErQjtBQUM3QixjQUFNbEIsRUFBRSxHQUNOLEtBQUtDLG9CQUFMLENBQTBCcEUsR0FBMUIsQ0FBOEJrQixNQUFNLENBQUNFLEVBQXJDLEtBQ0EsSUFBSTlCLHVDQUFKLEVBRkY7QUFJQSxjQUFNRSxTQUFTLEdBQUcyRSxFQUFFLENBQUNuRSxHQUFILENBQVVILEVBQVYsQ0FBbEI7O0FBRUEsWUFBSStILFNBQVMsQ0FBQ3BJLFNBQUQsQ0FBYixFQUEwQjtBQUN4QixpQkFBTztBQUNMQSxxQkFESztBQUVMMEI7QUFGSyxXQUFQO0FBSUQ7QUFDRjs7QUFFRCxhQUFPLElBQVA7QUFDRCxLQXhIYTs7QUFBQSwwQ0E4SFpyQixFQURRLElBRW1DO0FBQzNDLFlBQU13RixRQUFRLEdBQUcsS0FBSzBDLFNBQUwsQ0FBZWxJLEVBQWYsQ0FBakI7QUFFQSxhQUFPd0YsUUFBUSxDQUFDRSxHQUFULENBQWNyRSxNQUFELElBQVk7QUFDOUIsZUFBTztBQUNMQSxnQkFESztBQUVMMUIsbUJBQVMsRUFBRTBCLE1BQU0sQ0FBQ3pCLFVBQVAsQ0FBa0JPLEdBQWxCLENBQXlCSCxFQUF6QjtBQUZOLFNBQVA7QUFJRCxPQUxNLENBQVA7QUFNRCxLQXhJYTs7QUFBQSxzQ0ErSVIsQ0FBZXVHLEdBQWYsRUFBOEJ2RyxFQUE5QixLQUE2RDtBQUNqRSxZQUFNc0UsRUFBRSxHQUNOLEtBQUtDLG9CQUFMLENBQTBCcEUsR0FBMUIsQ0FBOEJvRyxHQUE5QixLQUFzQyxJQUFJOUcsdUNBQUosRUFEeEM7QUFHQSxhQUFPNkUsRUFBRSxDQUFDbkUsR0FBSCxDQUFVSCxFQUFWLENBQVA7QUFDRCxLQXBKYTs7QUFBQSwrQ0E0SkMsQ0FDYkEsRUFEYSxFQUVibUksWUFGYSxLQUdBO0FBQ2IsWUFBTUMsTUFBTSxHQUFHLEtBQUtDLElBQUwsQ0FBVXJJLEVBQVYsQ0FBZjs7QUFFQSxVQUFJLENBQUNvSSxNQUFMLEVBQWE7QUFDWCxlQUFPRCxZQUFZLEdBQUdBLFlBQUgsR0FBa0IsSUFBckM7QUFDRDs7QUFFRCxhQUFPQyxNQUFNLENBQUN6SSxTQUFkO0FBQ0QsS0F2S2E7O0FBQUEsNENBNEtEdUUsR0FBRCxJQUFpQztBQUMzQyxZQUFNb0UsWUFBWSxHQUFHLEtBQUtsRSxjQUFMLENBQW9CakUsR0FBcEIsQ0FBd0IrRCxHQUF4QixDQUFyQjs7QUFFQSxVQUFJb0UsWUFBSixFQUFrQjtBQUNoQixjQUFNQyxRQUFRLEdBQUdELFlBQVksQ0FBQzdDLE1BQWIsR0FBc0JqRCxJQUF0QixHQUE2QitFLEtBQTlDO0FBRUEsY0FBTWxHLE1BQU0sR0FBRyxLQUFLbUUsUUFBTCxDQUFjckYsR0FBZCxDQUFrQm9JLFFBQWxCLENBQWY7O0FBRUEsWUFBSWxILE1BQUosRUFBWTtBQUNWLGlCQUFPQSxNQUFQO0FBQ0Q7QUFDRjs7QUFFRCxhQUFPLElBQVA7QUFDRCxLQTFMYTs7QUFBQSwrQ0FnTUU2QyxHQUFELElBQTRCO0FBQ3pDLFVBQUlzQixRQUFzQixHQUFHLEVBQTdCLENBRHlDLENBQ1I7O0FBRWpDLFlBQU04QyxZQUFZLEdBQUcsS0FBS2xFLGNBQUwsQ0FBb0JqRSxHQUFwQixDQUF3QitELEdBQXhCLENBQXJCOztBQUVBLFVBQUlvRSxZQUFKLEVBQWtCO0FBQ2hCLGFBQUssTUFBTUMsUUFBWCxJQUF1QkQsWUFBdkIsRUFBcUM7QUFDbkMsZ0JBQU1qSCxNQUFNLEdBQUcsS0FBS21FLFFBQUwsQ0FBY3JGLEdBQWQsQ0FBa0JvSSxRQUFsQixDQUFmOztBQUNBLGNBQUlsSCxNQUFKLEVBQVk7QUFDVm1FLG9CQUFRLENBQUN4RCxJQUFULENBQWNYLE1BQWQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsYUFBT21FLFFBQVA7QUFDRCxLQS9NYTs7QUFBQSxzQ0FvTlIsQ0FBZWUsR0FBZixFQUE4QjVHLFNBQTlCLEtBQXFEO0FBQ3pELFlBQU0yRSxFQUFFLEdBQ04sS0FBS0Msb0JBQUwsQ0FBMEJwRSxHQUExQixDQUE4Qm9HLEdBQTlCLEtBQXNDLElBQUk5Ryx1Q0FBSixFQUR4QztBQUdBNkUsUUFBRSxDQUFDTixHQUFILENBQU9yRSxTQUFQO0FBRUEsV0FBSzRFLG9CQUFMLENBQTBCMUUsR0FBMUIsQ0FBOEIwRyxHQUE5QixFQUFtQ2pDLEVBQW5DOztBQUVBLFdBQUssTUFBTSxDQUFDa0UsS0FBRCxFQUFRckUsU0FBUixDQUFYLElBQWlDLEtBQUtnQyxnQkFBdEMsRUFBd0Q7QUFDdEQsWUFBS3FDLEtBQUQsQ0FBb0I5SCxLQUFwQixDQUEwQjRELEVBQUUsQ0FBQ21FLFNBQTdCLENBQUosRUFBNkM7QUFDM0N0RSxtQkFBUyxDQUFDSCxHQUFWLENBQWN1QyxHQUFkO0FBQ0Q7QUFDRixPQVp3RCxDQWN6RDs7O0FBQ0EsVUFBSTVHLFNBQVMsQ0FBQ2dILHFCQUFxQixDQUFDQyxTQUF2QixDQUFiLEVBQWdEO0FBQzlDO0FBQ0FqSCxpQkFBUyxDQUFDZ0gscUJBQXFCLENBQUNJLFFBQXZCLENBQVQsQ0FBMEMsSUFBMUM7QUFFQSxjQUFNMUYsTUFBTSxHQUFHLEtBQUttRSxRQUFMLENBQWNyRixHQUFkLENBQWtCb0csR0FBbEIsQ0FBZjs7QUFFQSxZQUFJLENBQUNsRixNQUFMLEVBQWE7QUFDWCxnQkFBTSxJQUFJZCxLQUFKLENBQVcsNENBQTJDZ0csR0FBSSxFQUExRCxDQUFOO0FBQ0QsU0FSNkMsQ0FVOUM7OztBQUNBNUcsaUJBQVMsQ0FBQ2dILHFCQUFxQixDQUFDSyxLQUF2QixDQUFULENBQXVDLElBQXZDLEVBQTZDM0YsTUFBN0M7QUFDRDs7QUFFRCxhQUFPLElBQVA7QUFDRCxLQWxQYTs7QUFBQSx5Q0F3UEwsQ0FBQ2tGLEdBQUQsRUFBZ0JsRyxLQUFoQixLQUFzRDtBQUM3RCxZQUFNaUUsRUFBRSxHQUNOLEtBQUtDLG9CQUFMLENBQTBCcEUsR0FBMUIsQ0FBOEJvRyxHQUE5QixLQUFzQyxJQUFJOUcsdUNBQUosRUFEeEMsQ0FENkQsQ0FJN0Q7O0FBQ0EsWUFBTUUsU0FBUyxHQUFHMkUsRUFBRSxDQUFDbkUsR0FBSCxDQUFPRSxLQUFQLENBQWxCLENBTDZELENBTzdEOztBQUNBLFVBQUlWLFNBQVMsQ0FBQ2dILHFCQUFxQixDQUFDQyxTQUF2QixDQUFiLEVBQWdEO0FBQzlDLGNBQU12RixNQUFNLEdBQUcsS0FBS21FLFFBQUwsQ0FBY3JGLEdBQWQsQ0FBa0JvRyxHQUFsQixDQUFmOztBQUVBLFlBQUksQ0FBQ2xGLE1BQUwsRUFBYTtBQUNYLGdCQUFNLElBQUlkLEtBQUosQ0FBVywrQ0FBOENnRyxHQUFJLFlBQVdsRyxLQUFLLENBQUNOLElBQUssRUFBbkYsQ0FBTjtBQUNELFNBTDZDLENBTzlDOzs7QUFDQUosaUJBQVMsQ0FBQ2dILHFCQUFxQixDQUFDTyxRQUF2QixDQUFULENBQTBDLElBQTFDLEVBQWdEN0YsTUFBaEQ7QUFDRCxPQWpCNEQsQ0FtQjdEOzs7QUFDQSxXQUFLLE1BQU0sQ0FBQ21ILEtBQUQsRUFBUXJFLFNBQVIsQ0FBWCxJQUFpQyxLQUFLZ0MsZ0JBQXRDLEVBQXdEO0FBQ3RELFlBQUtxQyxLQUFELENBQW9COUgsS0FBcEIsQ0FBMEI0RCxFQUFFLENBQUNtRSxTQUE3QixDQUFKLEVBQTZDO0FBQzNDdEUsbUJBQVMsQ0FBQzdELE1BQVYsQ0FBaUJpRyxHQUFqQjtBQUNEO0FBQ0Y7O0FBRURqQyxRQUFFLENBQUNJLE1BQUgsQ0FBVXJFLEtBQVYsRUExQjZELENBNEI3RDs7QUFDQSxXQUFLLE1BQU0sQ0FBQ21JLEtBQUQsRUFBUXJFLFNBQVIsQ0FBWCxJQUFpQyxLQUFLZ0MsZ0JBQXRDLEVBQXdEO0FBQ3RELFlBQUtxQyxLQUFELENBQW9COUgsS0FBcEIsQ0FBMEI0RCxFQUFFLENBQUNtRSxTQUE3QixDQUFKLEVBQTZDO0FBQzNDdEUsbUJBQVMsQ0FBQ0gsR0FBVixDQUFjdUMsR0FBZDtBQUNEO0FBQ0Y7O0FBRUQsYUFBTyxJQUFQO0FBQ0QsS0E1UmE7O0FBQ1osU0FBS21DLEdBQUwsR0FBVyxJQUFJdEQsWUFBSixDQUFhLElBQWIsQ0FBWDtBQUNBLFNBQUt2RCxPQUFMLEdBQWUsSUFBSStELGVBQUosQ0FBWSxJQUFaLENBQWY7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBdVJFO0FBQ0Y7QUFDQTtBQUNFK0MsV0FBUyxDQUFDN0MsTUFBRCxFQUFpQ0MsVUFBakMsRUFBNkRDLFFBQTdELEVBQXNGO0FBQzdGLFNBQUtuRSxPQUFMLENBQWFtQyxHQUFiLENBQWlCOEIsTUFBakIsRUFBeUJDLFVBQXpCLEVBQXFDQyxRQUFyQztBQUVBLFdBQU8sSUFBUDtBQUNEOztBQUVEeEMsZ0JBQWMsQ0FBQ25DLE1BQUQsRUFBZ0M7QUFDNUMsVUFBTWlELEVBQUUsR0FBRyxJQUFJN0UsdUNBQUosRUFBWDtBQUVBLFNBQUs4RSxvQkFBTCxDQUEwQjFFLEdBQTFCLENBQThCd0IsTUFBTSxDQUFDRSxFQUFyQyxFQUF5QytDLEVBQXpDO0FBQ0EsU0FBS2tCLFFBQUwsQ0FBYzNGLEdBQWQsQ0FBa0J3QixNQUFNLENBQUNFLEVBQXpCLEVBQTZCRixNQUE3QjtBQUVBLFdBQU8sSUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDRXdELHVCQUFxQixDQUFDMEIsR0FBRCxFQUFzQjtBQUN6QyxTQUFLaEMsb0JBQUwsQ0FBMEIxRSxHQUExQixDQUE4QjBHLEdBQTlCLEVBQW1DLElBQUk5Ryx1Q0FBSixFQUFuQzs7QUFFQSxTQUFLLE1BQU0wRSxTQUFYLElBQXdCLEtBQUtnQyxnQkFBTCxDQUFzQlYsTUFBdEIsRUFBeEIsRUFBd0Q7QUFDdEQsVUFBSXRCLFNBQVMsQ0FBQ3ZELEdBQVYsQ0FBYzJGLEdBQWQsQ0FBSixFQUF3QjtBQUN0QnBDLGlCQUFTLENBQUM3RCxNQUFWLENBQWlCaUcsR0FBakI7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7OztBQUNFcUMsY0FBWSxHQUFlO0FBQ3pCLFVBQU12SCxNQUFNLEdBQUcsSUFBSXdCLGFBQUosQ0FBVyxJQUFYLENBQWY7QUFFQSxXQUFPeEIsTUFBUCxDQUh5QixDQUt6QjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7OztBQUNFNEQsZUFBYSxDQUFDc0IsR0FBRCxFQUEyQjtBQUN0QyxTQUFLaEMsb0JBQUwsQ0FBMEJqRSxNQUExQixDQUFpQ2lHLEdBQWpDO0FBQ0EsU0FBS2YsUUFBTCxDQUFjbEYsTUFBZCxDQUFxQmlHLEdBQXJCOztBQUVBLFNBQUssTUFBTXBDLFNBQVgsSUFBd0IsS0FBS2dDLGdCQUFMLENBQXNCVixNQUF0QixFQUF4QixFQUF3RDtBQUN0RCxVQUFJdEIsU0FBUyxDQUFDdkQsR0FBVixDQUFjMkYsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCcEMsaUJBQVMsQ0FBQzdELE1BQVYsQ0FBaUJpRyxHQUFqQjtBQUNEO0FBQ0YsS0FScUMsQ0FVdEM7OztBQUNBLFNBQUssTUFBTSxDQUFDckMsR0FBRCxFQUFNQyxTQUFOLENBQVgsSUFBK0IsS0FBS0MsY0FBcEMsRUFBb0Q7QUFDbEQsVUFBSUQsU0FBUyxDQUFDdkQsR0FBVixDQUFjMkYsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCcEMsaUJBQVMsQ0FBQzdELE1BQVYsQ0FBaUJpRyxHQUFqQjtBQUNEOztBQUVELFVBQUlwQyxTQUFTLENBQUNuRCxJQUFWLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLGFBQUtvRCxjQUFMLENBQW9COUQsTUFBcEIsQ0FBMkI0RCxHQUEzQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7O0FBbFg0QixDOztBQ1YvQjtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbnZhciBnZXRSYW5kb21WYWx1ZXM7XG52YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyIsImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG52YXIgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIpIHtcbiAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHZhciB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyIsImV4cG9ydCBmdW5jdGlvbiBpc0NvbXBvbmVudEluc3RhbmNlPFQ+KFxuICBDbGFzczogbmV3ICguLi5hcmdzOiBhbnkpID0+IFQsXG4gIGNvbXA6IGFueVxuKTogY29tcCBpcyBJbnN0YW5jZVR5cGU8dHlwZW9mIENsYXNzPiB7XG4gIGlmICghY29tcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDbGFzcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCB7IGlzQ29tcG9uZW50SW5zdGFuY2UgfSBmcm9tIFwiLi9ndWFyZHNcIjtcblxudHlwZSBDb21wTmFtZSA9IHN0cmluZztcbnR5cGUgQ2xhc3NDb25zdHJ1Y3RvcjxUPiA9IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQgfTtcblxuLy8gQ1QgaXMgYSBVbmlvbiwgbGlrZSBgdHlwZSA9IEZpcnN0Q29tcG9uZW50IHwgU2Vjb25kQ29tcG9uZW50YC5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgY29tcG9uZW50czogTWFwPENvbXBOYW1lLCBDVD4gPSBuZXcgTWFwKCk7XG5cbiAgLy8gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnRcbiAgLy8gYWRkID0gKGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPENUW2tleW9mIENUXT4pOiB2b2lkID0+IHtcbiAgYWRkID0gKGNvbXBvbmVudDogQ1QpOiB2b2lkID0+IHtcbiAgICB0aGlzLmNvbXBvbmVudHMuc2V0KCg8YW55PmNvbXBvbmVudCkuY29uc3RydWN0b3IubmFtZSwgY29tcG9uZW50KTtcbiAgfTtcblxuICB1cGRhdGUgPSA8VCBleHRlbmRzIENUPihcbiAgICBjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPixcbiAgICBmdW5jOiAoYzogVCkgPT4gVFxuICApOiB2b2lkID0+IHtcbiAgICBjb25zdCBjID0gdGhpcy5jb21wb25lbnRzLmdldChjbC5uYW1lKTtcblxuICAgIGlmIChpc0NvbXBvbmVudEluc3RhbmNlKGNsLCBjKSkge1xuICAgICAgY29uc3QgdXBkYXRlZENvbXBvbmVudCA9IGZ1bmMoYyk7XG4gICAgICB0aGlzLmNvbXBvbmVudHMuc2V0KGNsLm5hbWUsIHVwZGF0ZWRDb21wb25lbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gY1R5cGUgQ2xhc3Mgb2YgY29tcG9uZW50IHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZSA9IChjVHlwZTogQ2xhc3NDb25zdHJ1Y3RvcjxDVD4pOiB2b2lkID0+IHtcbiAgICB0aGlzLmNvbXBvbmVudHMuZGVsZXRlKGNUeXBlLm5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBjb21wb25lbnQgdGhhdCBtYXRjaGVzIHRoZSBwYXNzZWQgY2xhc3MuXG4gICAqIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGNvbXBvbmVudFxuICAgKiBkb2Vzbid0IGV4aXN0IGluIHRoZSBjb2xsZWN0aW9uLCBzbyBpZiB5b3UgZG9uJ3Qga25vdyBpZiBpdCdzIHNhZmVcbiAgICogdG8gZ2V0IGEgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHRlc3Qgd2l0aCBoYXMoKSBvciBoYXNCeU5hbWUoKSBmaXJzdC5cbiAgICogWW91IGhhdmUgYmVlbiB3YXJuZWQuXG4gICAqIEBwYXJhbSBjbCBjb21wb25lbnQgQ2xhc3MgcmVmZXJlbmNlLlxuICAgKi9cbiAgZ2V0ID0gPFQgZXh0ZW5kcyBDVD4oY2w6IENsYXNzQ29uc3RydWN0b3I8VD4pOiBUID0+IHtcbiAgICBjb25zdCBjb21wID0gdGhpcy5jb21wb25lbnRzLmdldChjbC5uYW1lKTtcblxuICAgIGlmIChpc0NvbXBvbmVudEluc3RhbmNlPFQ+KGNsLCBjb21wKSkge1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvbXBvbmVudENvbGxlY3Rpb24gZG9lcyBub3QgaGF2ZSBjb21wb25lbnQgb2YgdHlwZSAke2NsLm5hbWV9YFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUG9zc2libGUgb3RoZXIgd2F5IHRvIHdyaXRlIGEgZ2V0IG1ldGhvZCB0aGF0IG1haW50YWlucyB0aGUgdHlwZSBvZiB0aGVcbiAgLy8gQ29tcG9uZW50IHRocm91Z2hvdXQuIEtlZXBpbmcgYXJvdW5kIGZvciBub3cgYXJlIGEgcmVmZXJlbmNlLlxuICAvLyBnZXQ8VSBleHRlbmRzIENUPihjb21wQ2xhc3M6IENsYXNzPFU+KTogVSB7XG4gIC8vICAgaWYgKCF0aGlzLmNvbXBvbmVudHMuaGFzKGNvbXBDbGFzcy5uYW1lKSkge1xuICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAvLyAgICAgICBgQ29tcG9uZW50Q29sbGVjdGlvbiBkb2VzIG5vdCBoYXZlIGNvbXBvbmVudCBvZiB0eXBlICR7Y29tcENsYXNzLm5hbWV9YFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICByZXR1cm4gdGhpcy5jb21wb25lbnRzLmdldChjb21wQ2xhc3MubmFtZSkhIGFzIHVua25vd24gYXMgVTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBUZXN0IHRvIHNlZSBpZiB0aGUgY29sbGVjdGlvbiBjb250YWlucyBhIHNwZWNpZmljIENsYXNzIG9yIENsYXNzZXMuXG4gICAqIEBwYXJhbSBjVHlwZSBjb21wb25lbnQgQ2xhc3MsIG9yIGFycmF5IG9mIGNvbXBvbmVudCBDbGFzc2VzLlxuICAgKi9cbiAgaGFzID0gKGNUeXBlOiBDbGFzc0NvbnN0cnVjdG9yPENUPiB8IENsYXNzQ29uc3RydWN0b3I8Q1Q+W10pOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjVHlwZSlcbiAgICAgID8gY1R5cGUuZXZlcnkoKGN0KSA9PiB0aGlzLmNvbXBvbmVudHMuaGFzKGN0Lm5hbWUpID09PSB0cnVlKVxuICAgICAgOiB0aGlzLmNvbXBvbmVudHMuaGFzKGNUeXBlLm5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHRvIHNlZSBpZiB0aGUgY29sbGVjdGlvbiBoYXMgYSBjb21wb25lbnQgaW5zdGFuY2UgYmFzZWQgb24gYVxuICAgKiBjbGFzcyBuYW1lLiBTb21lIGJ1aWxkIHN0ZXBzL21pbmlmaWVycyB3aWxsIGNoYW5nZSB0aGUgbmFtZSBvZiBDbGFzc2VzLFxuICAgKiBzbyBpdCdzIHVzdWFsbHkgYmVzdCB0byBwYXNzIGluIGEgTXlDbGFzcy5uYW1lIGluc3RlYWQgb2YgJ015Q2xhc3MnLlxuICAgKiBAcGFyYW0gY05hbWUgVGhlIG5hbWUgb2YgYSBDbGFzcywgb3IgYXJyYXkgb2YgQ2xhc3MgbmFtZXMuXG4gICAqL1xuICBoYXNCeU5hbWUgPSAoY05hbWU6IHN0cmluZyB8IHN0cmluZ1tdKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY05hbWUpXG4gICAgICA/IGNOYW1lLmV2ZXJ5KGN0ID0+IHRoaXMuY29tcG9uZW50cy5oYXMoY3QpID09PSB0cnVlKVxuICAgICAgOiB0aGlzLmNvbXBvbmVudHMuaGFzKGNOYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb21wb25lbnQgdHlwZSBuYW1lcyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgdXNlZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIGdldCBjb21wb25lbnRUeXBlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmNvbXBvbmVudHMua2V5cygpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGNvbXBvbmVudHMgdGhhdCBhcmUgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqL1xuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuc2l6ZTtcbiAgfVxuXG4gIHRvRGV2Q29tcG9uZW50cygpOiBSZWNvcmQ8c3RyaW5nLCBDVD4ge1xuICAgIGNvbnN0IG9iajogUmVjb3JkPHN0cmluZywgQ1Q+ID0ge307XG4gICAgZm9yIChjb25zdCBbY29tcE5hbWUsIGNvbXBdIG9mIHRoaXMuY29tcG9uZW50cykge1xuICAgICAgb2JqW2NvbXBOYW1lXSA9IGNvbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxuIiwiaW1wb3J0IFdvcmxkIGZyb20gXCIuL1dvcmxkXCI7XG5pbXBvcnQgRW50aXR5IGZyb20gXCIuL0VudGl0eVwiO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSBcIi4vVGFnXCI7XG5cbmludGVyZmFjZSBEZXZFbnRpdHlUYWJsZVJvdyB7XG4gIGlkOiBzdHJpbmc7XG4gIGNvbXBvbmVudHM6IHN0cmluZztcbiAgdGFnczogc3RyaW5nO1xuICBzeXN0ZW1zOiBzdHJpbmc7XG59XG5cbmNsYXNzIERldkVudGl0eTxDVD4ge1xuICBpZDogc3RyaW5nO1xuXG4gIGNvbXBvbmVudHM6IFJlY29yZDxzdHJpbmcsIENUPjtcblxuICB0YWdzOiBUYWdbXTtcblxuICBzeXN0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGVudGl0eTogRW50aXR5PENUPiwgd29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMuaWQgPSBlbnRpdHkuaWQ7XG4gICAgdGhpcy5jb21wb25lbnRzID0gZW50aXR5LmNvbXBvbmVudHMudG9EZXZDb21wb25lbnRzKCksXG4gICAgdGhpcy50YWdzID0gWy4uLmVudGl0eS50YWdzXTtcblxuICAgIGNvbnN0IGNvbXBOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuY29tcG9uZW50cyk7XG5cbiAgICBmb3IgKGNvbnN0IFtzeXN0ZW1OYW1lLCBjTmFtZXNdIG9mIHdvcmxkLnN5c3RlbXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lKSB7XG4gICAgICBpZiAoY05hbWVzLmV2ZXJ5KChjTmFtZSkgPT4gY29tcE5hbWVzLmluY2x1ZGVzKGNOYW1lKSkpIHtcbiAgICAgICAgdGhpcy5zeXN0ZW1zLnB1c2goc3lzdGVtTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdG9UYWJsZVJvdygpOiBEZXZFbnRpdHlUYWJsZVJvdyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgY29tcG9uZW50czogT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRzKS5qb2luKFwiLCBcIiksXG4gICAgICB0YWdzOiB0aGlzLnRhZ3Muam9pbihcIiwgXCIpLFxuICAgICAgc3lzdGVtczogdGhpcy5zeXN0ZW1zLmpvaW4oJywgJyksXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZXZFbnRpdHk7XG4iLCJleHBvcnQgdHlwZSBTdGF0ZSA9IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbDtcblxuZXhwb3J0IHR5cGUgVHJhbnNpdGlvbnM8UyBleHRlbmRzIFN0YXRlLCBEPiA9IFJlY29yZDxcbiAgUyxcbiAgKGRhdGE6IEQgfCB1bmRlZmluZWQsIGN1cnJlbnQ6IFMpID0+IFNcbj47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpbXBsZUZTTTxTIGV4dGVuZHMgU3RhdGUsIEQgPSB1bmRlZmluZWQ+IHtcbiAgY3VycmVudDogUztcblxuICBpbml0YWw6IFM7XG5cbiAgdHJhbnNpdGlvbnM6IFRyYW5zaXRpb25zPFMsIEQ+O1xuXG4gIGNvbnN0cnVjdG9yKGluaXRpYWxTdGF0ZTogUywgdHJhbnNpdGlvbnM6IFRyYW5zaXRpb25zPFMsIEQ+KSB7XG4gICAgdGhpcy5pbml0YWwgPSBpbml0aWFsU3RhdGU7XG4gICAgdGhpcy5jdXJyZW50ID0gaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcbiAgfVxuXG4gIG5leHQoZGF0YT86IEQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uc1t0aGlzLmN1cnJlbnRdKSB7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnRyYW5zaXRpb25zW3RoaXMuY3VycmVudF0oZGF0YSwgdGhpcy5jdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmluaXRhbDtcbiAgfVxuXG4gIGlzKGNoZWNrU3RhdGU6IFMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09PSBjaGVja1N0YXRlO1xuICB9XG59XG4iLCJpbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IFdvcmxkLCB7IENsYXNzQ29uc3RydWN0b3IgfSBmcm9tIFwiLi9Xb3JsZFwiO1xuaW1wb3J0IENvbXBvbmVudENvbGxlY3Rpb24gZnJvbSBcIi4vQ29tcG9uZW50Q29sbGVjdGlvblwiO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSBcIi4vVGFnXCI7XG4vLyBpbXBvcnQgeyBDb21wVHlwZXMgfSBmcm9tICdpbnRlcmZhY2VzJztcbmltcG9ydCBEZXZFbnRpdHkgZnJvbSBcIi4vRGV2RW50aXR5XCI7XG5cbmltcG9ydCBTaW1wbGVGU00gZnJvbSBcIi4vU2ltcGxlRlNNXCI7XG5cbmV4cG9ydCB0eXBlIEVudGl0eUlkID0gc3RyaW5nO1xuXG50eXBlIEVudGl0eVN0YXRlID1cbiAgfCBcImNyZWF0aW5nXCJcbiAgfCBcImNyZWF0ZWRcIlxuICB8IFwiZGVzdHJveWluZ1wiXG4gIHwgXCJkZXN0cm95ZWRcIlxuICB8IFwiZXJyb3JcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50aXR5PENUPiB7XG4gIHByaXZhdGUgX2lkOiBzdHJpbmc7XG4gIHByaXZhdGUgX3dvcmxkOiBXb3JsZDxDVD47XG5cbiAgcHJpdmF0ZSBfZXJyb3I6IEVycm9yIHwgbnVsbDtcblxuICBwcml2YXRlIF9zdGF0ZTogU2ltcGxlRlNNPEVudGl0eVN0YXRlPjtcblxuICBjb25zdHJ1Y3Rvcih3b3JsZDogV29ybGQ8Q1Q+KSB7XG4gICAgdGhpcy5faWQgPSB1dWlkdjQoKTtcbiAgICB0aGlzLl93b3JsZCA9IHdvcmxkO1xuXG4gICAgdGhpcy5fZXJyb3IgPSBudWxsO1xuXG4gICAgdGhpcy5fc3RhdGUgPSBuZXcgU2ltcGxlRlNNPEVudGl0eVN0YXRlPihcImNyZWF0aW5nXCIsIHtcbiAgICAgIGNyZWF0aW5nOiAoKSA9PiAodGhpcy5fZXJyb3IgPyBcImVycm9yXCIgOiBcImNyZWF0ZWRcIiksXG4gICAgICBjcmVhdGVkOiAoKSA9PiBcImRlc3Ryb3lpbmdcIixcbiAgICAgIGRlc3Ryb3lpbmc6ICgpID0+ICh0aGlzLl9lcnJvciA/IFwiZXJyb3JcIiA6IFwiZGVzdHJveWVkXCIpLFxuICAgICAgZGVzdHJveWVkOiAoKSA9PiBcImRlc3Ryb3llZFwiLFxuICAgICAgZXJyb3I6ICgpID0+IFwiZXJyb3JcIixcbiAgICB9KTtcblxuICAgIC8qXG4gICAgUmVnaXN0ZXJpbmcgd2l0aCB0aGUgV29ybGQuXG4gICAgKi9cbiAgICB0aGlzLl93b3JsZC5yZWdpc3RlckVudGl0eSh0aGlzKTtcblxuICAgIHRoaXMuX3N0YXRlLm5leHQoKSAvLyBjcmVhdGVkXG5cbiAgICB0aGlzLm9uQ3JlYXRlKCk7XG5cbiAgfVxuXG4gIGdldCBzdGF0ZSgpOiBFbnRpdHlTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmN1cnJlbnQ7XG4gIH1cblxuICBjaGVja1N0YXRlKHBvc3NpYmxlU3RhdGU6IEVudGl0eVN0YXRlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmlzKHBvc3NpYmxlU3RhdGUpO1xuICB9XG5cbiAgLyogTGlmZUN5Y2xlIG1ldGhvZHMsIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4gKi9cblxuICBvbkNyZWF0ZSgpOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25EZXN0cm95KCk6IHZvaWQge1xuICAgIC8vIGFic3RyYWN0XG4gIH1cblxuICBvbkNvbXBvbmVudEFkZCgpOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25Db21wb25lbnRVcGRhdGUoKTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIG9uQ29tcG9uZW50UmVtb3ZlKCk6IHZvaWQge1xuICAgIC8vIGFic3RyYWN0XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgY29tcG9uZW50IHRvIGFuIEVudGl0eSwgZG9oLlxuICAgKi9cbiAgYWRkKGNvbXBvbmVudDogQ1QpOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5hZGQodGhpcy5faWQsIGNvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0YWcgdG8gYSBjb21wb25lbnRcbiAgICovXG4gIGFkZFRhZyh0YWc6IFRhZyk6IHRoaXMge1xuICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmhhcyh0YWcpXG4gICAgICA/IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpXG4gICAgICA6IG5ldyBTZXQ8RW50aXR5SWQ+KCk7XG5cbiAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICBlbnRpdHlTZXQuYWRkKHRoaXMuX2lkKTtcbiAgICAgIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLnNldCh0YWcsIGVudGl0eVNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhbiBlbnRpdHkgaGFzIGEgY29tcG9uZW50IHJlbGF0ZWQgdG8gaXQuXG4gICAqL1xuICBoYXMoY1R5cGU6IENsYXNzQ29uc3RydWN0b3I8Q1Q+KTogYm9vbGVhbiB7XG4gICAgY29uc3QgY2MgPVxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICByZXR1cm4gY2MuaGFzKGNUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgYW4gZW50aXR5IHRhZ2dlZCB3aXRoIGEgZ2l2ZW4gdGFnLlxuICAgKi9cbiAgaGFzVGFnKHRhZzogVGFnKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmhhcyh0YWcpKSB7XG4gICAgICBjb25zdCBlbnRpdHlTZXQgPSB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5nZXQodGFnKTtcbiAgICAgIGlmIChlbnRpdHlTZXQpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eVNldC5oYXModGhpcy5faWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBjb21wb25lbnQgdGhhdCBiZWxvbmdzIHRvIGFuIGVudGl0eS5cbiAgICovXG4gIGdldDxUIGV4dGVuZHMgQ1Q+KGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+KTogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHxcbiAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvblxuICAgKi9cbiAgZ2V0QWxsKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNvbXBvbmVudCBmcm9tIGFuIGVudGl0eS5cbiAgICogQHBhcmFtIGNUeXBlIEEgY29tcG9uZW50IGNsYXNzLCBlZyBNeUNvbXBvbmVudFxuICAgKi9cbiAgcmVtb3ZlKGNUeXBlOiBDbGFzc0NvbnN0cnVjdG9yPENUPik6IHRoaXMge1xuICAgIHRoaXMuX3dvcmxkLnJlbW92ZSh0aGlzLl9pZCwgY1R5cGUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdGFnIGZyb20gYW4gZW50aXR5XG4gICAqL1xuICByZW1vdmVUYWcodGFnOiBUYWcpOiB0aGlzIHtcbiAgICBpZiAodGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuaGFzKHRhZykpIHtcbiAgICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICAgIGlmIChlbnRpdHlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENsZWFycyBhbGwgY29tcG9uZW50cyBmcm9tIGFuIEVudGl0eSAqL1xuICBjbGVhcigpOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5jbGVhckVudGl0eUNvbXBvbmVudHModGhpcy5faWQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0YWdzIG9uIGFuIGVudGl0eVxuICAgKi9cbiAgY2xlYXJUYWdzKCk6IHRoaXMge1xuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5lbnRyaWVzKCkpIHtcbiAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICBpZiAoZW50aXR5U2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fc3RhdGUuaXMoXCJjcmVhdGVkXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRWNzdGF0aWM6IFVuYWJsZSB0byBkZXN0cm95IGlmIGl0IGlzbid0IGNyZWF0ZWQsIG9yIGFscmVhZHkgZGVzdHJveWVkXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUubmV4dCgpOyAvLyBkZXN0cm95aW5nXG5cbiAgICAvLyBUaGlzIHdpbGwgcHJvYmFibHkgYmUgZGVmZXJyZWQgc28gdGhhdCBTeXN0ZW1zIGNhbiB3b3JrIG9uIGl0LlxuICAgIHRoaXMuX3dvcmxkLmRlc3Ryb3lFbnRpdHkodGhpcy5faWQpOyAvLyBzaG91bGQgcmV0dXJuIGFuIGVycm9yPz9cblxuICAgIHRoaXMub25EZXN0cm95KCk7IC8vIGFzc3VtaW5nIGZvciBub3cgdGhhdCB0aGlzIGlzIGJlc3QgZG9uZSBhZnRlciBhY3R1YWxseSByZW1vdmluZyB0aGUgZW50aXR5IGZyb20gdGhlIHdvcmxkLlxuXG4gICAgaWYgKHRoaXMuX3N0YXRlLmlzKFwiZGVzdHJveWluZ1wiKSkge1xuICAgICAgdGhpcy5fc3RhdGUubmV4dCgpOyAvLyBkZXN0cm95ZWRcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlLmlzKFwiZXJyb3JcIikgJiYgdGhpcy5fZXJyb3IpIHtcbiAgICAgIC8vIERvIHNvbWV0aGluZyB3aXRoIGVycm9yISFcbiAgICB9XG4gIH1cblxuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cblxuICBnZXQgd29ybGQoKTogV29ybGQ8Q1Q+IHtcbiAgICByZXR1cm4gdGhpcy5fd29ybGQ7XG4gIH1cblxuICBkZXN0cm95SW1tZWRpYXRlbHkoKTogdm9pZCB7XG4gICAgLy8gcGxhY2Vob2xkZXIgZm9yIG1ldGhvZCB0aGF0IGRvZXNuJ3Qgd2FpdCBmb3IgZW50aXR5IHRvIGdvIHRocm91Z2ggdGhlIG5vcm1hbFxuICAgIC8vIGRlc3RvcnkgcGlwZWxpbmUgYW5kIHByb2Nlc3MuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvbi5cbiAgICogRG9lcyB0aGUgc2FtZSB0aGluZyBhcyBlbnRpdHlJbnN0YW5jZS5nZXRBbGwoKS5cbiAgICovXG4gIGdldCBjb21wb25lbnRzKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgdGhlIHRhZ3MgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhpcyBlbnRpdHkuXG4gICAqL1xuICBnZXQgdGFncygpOiBTZXQ8VGFnPiB7XG4gICAgY29uc3QgdGFncyA9IG5ldyBTZXQ8VGFnPigpO1xuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKHRoaXMuX2lkKSkge1xuICAgICAgICB0YWdzLmFkZCh0YWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YWdzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgRW50aXR5IHRvIGEgRGV2RW50aXR5LiBWZXJ5IGhlbHBmdWwgaW4gZm9yIGRlYnVnZ2luZy5cbiAgICovXG4gIHRvRGV2RW50aXR5KCk6IERldkVudGl0eTxDVD4ge1xuICAgIHJldHVybiBuZXcgRGV2RW50aXR5PENUPih0aGlzLCB0aGlzLl93b3JsZCk7XG4gIH1cbn1cbiIsImltcG9ydCBXb3JsZCBmcm9tICcuL1dvcmxkJztcbmltcG9ydCBEZXZFbnRpdHkgZnJvbSAnLi9EZXZFbnRpdHknO1xuXG5pbnRlcmZhY2UgRGV2U3lzdGVtQ29tcHMge1xuICBzeXN0ZW06IHN0cmluZztcbiAgY29tcG9uZW50czogc3RyaW5nO1xufVxuXG5cbmNsYXNzIERldlRvb2xzPENUPiB7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgfVxuICAvKipcbiAgICogZGlzcGxheSB0aGUgYWxsIHN5c3RlbXMgb2YgdGhlIHdvcmxkLCBhbmQgdGhlIGNvbXBvbmVudHMgcmVxdWlyZWQgYnkgZWFjaCBzeXN0ZW0uXG4gICAqIFN1cGVyIGhlbHBmdWwgdG8gdXNlIHdpdGggY29uc29sZS50YWJsZSgpXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zb2xlLnRhYmxlKHdvcmxkLmRldi5zeXN0ZW1Db21wb25lbnRzKTtcbiAgICogYGBgXG4gICAqL1xuICBnZXQgc3lzdGVtQ29tcG9uZW50cygpOiBEZXZTeXN0ZW1Db21wc1tdIHtcbiAgICBjb25zdCBjb21wc0J5U3lzdGVtcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBbc3lzdGVtLCBjb21wTmFtZXNdIG9mIHRoaXMud29ybGQuc3lzdGVtcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUpIHtcbiAgICAgIGNvbXBzQnlTeXN0ZW1zLnB1c2goeyBzeXN0ZW0sIGNvbXBvbmVudHM6IGNvbXBOYW1lcy5qb2luKFwiLCBcIikgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBzQnlTeXN0ZW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhcnJheSBvZiBEZXZFbnRpdGVzLiBDYW4gYmUgdmVyeSBoZWxwZnVsIGZvciB0aGluZ3MgbGlrZSBpbnNwZWN0aW5nIGNvbXBvbmVudCBzdGF0ZSxcbiAgICogYW5kIHdoaWNoIHN5c3RlbXMgd2lsbCBiZSBjYWxsZWQgb24gYW4gZW50aXR5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMpO1xuICAgKlxuICAgKiAvLyBQcm8gdGlwISB0cnkgZGlzcGxheWluZyBhIHRhYmxlIG9mIGVudGl0aWVzIHdpdGggY29uc29sZS50YWJsZSBhbmQgRGV2RW50aXR5LnRvVGFibGVSb3coKS5cbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMubWFwKGRldkVudGl0eSA9PiBkZXZFbnRpdHkudG9UYWJsZVJvdygpKSk7XG4gICAqIGBgYFxuICAgKi9cblxuICBnZXQgZW50aXRpZXMoKTogRGV2RW50aXR5PENUPltdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMud29ybGQuZW50aXRpZXMudmFsdWVzKCldLm1hcCgoZSkgPT4gZS50b0RldkVudGl0eSgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZXZUb29scztcbiIsImltcG9ydCBFbnRpdHksIHsgRW50aXR5SWQgfSBmcm9tIFwiLi9FbnRpdHlcIjtcbmltcG9ydCBXb3JsZCwgeyBDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSBcIi4vV29ybGRcIjtcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gXCIuL0NvbXBvbmVudENvbGxlY3Rpb25cIjtcblxuLyoqXG4gKiBBcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIGludG8gYSBTeXN0ZW0gZnVuY3Rpb24gb24gZWFjaCBpdGVyYXRpb24uXG4gKiBUaGlzIGlzIGhvdyB5b3UgYWNjZXMgdGhpbmdzIGxpa2UgdGhlIGVudGl0eSB0aGF0IHBhcnRpY3VsYXIgZW50aXR5IHRvIGFjdCBvbixcbiAqIGFzIHdlbGwgYXMgc29tZSBvdGhlciBoZWxwZnVsIHBhcmFtcyBsaWtlIGlmIHRoZSBlbnRpdHkgaXMgdGhlIGZpcnN0IG9yIGxhc3QgZW50aXR5XG4gKiBpbiB0aGUgZ3JvdXAgb2YgZW50aXRpZXMgdGhhdCBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5c3RlbUZ1bmNBcmdzPENUPiB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBlbnRpdHkgYmVpbmcgaXRlcmF0ZWQuXG4gICAqL1xuICBlbnRpdHk6IEVudGl0eTxDVD47XG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB0aGF0IGJlbG9uZyB0byB0aGUgZW50aXR5XG4gICAqL1xuICBjb21wb25lbnRzOiBDb21wb25lbnRDb2xsZWN0aW9uPENUPjtcbiAgLyoqXG4gICAqIFRoZSBXb3JsZCBpbnN0YW5jZS5cbiAgICogVXNlIHRoaXMgdG8gYWNjZXNzIG90aGVyIGVudGl0aWVzLlxuICAgKi9cbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICAvKipcbiAgICogSXMgdGhlIGZpcnN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogSGVscGZ1bCBmb3Igc2V0dGluZyB1cCBzdGF0ZSB0aGF0IGlzIHRoZSBzYW1lIGZvciBhbGwgZW50aXRpZXMgb25seSBvbmNlLlxuICAgKi9cbiAgaXNGaXJzdDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIElzIHRoZSBsYXN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogQ2FuIGJlIGhlbHBmdWwgdG8gdGVhciBkb3duIGFueXRoaW5nIHRoYXQgc2hvdWxkIGJlIGRlYWx0IHdpdGggYWZ0ZXIgYWxsIHRoZSBlbnRpdGVzIGhhdmUgcmFuLlxuICAgKi9cbiAgaXNMYXN0OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBzeXN0ZW0gaXMgcnVuLlxuICovXG5leHBvcnQgdHlwZSBTeXN0ZW1GdW5jPENUPiA9IChcbiAgc3l0ZW1GdW5jQXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+XG4pID0+IHZvaWQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbXM8Q1Q+IHtcbiAgd29ybGQ6IFdvcmxkPENUPjtcblxuICBzeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lOiBNYXA8c3RyaW5nLCBTeXN0ZW1GdW5jPENUPj47IC8vIGRvdWJsZSBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBtYXBzIGFyZSBvcmRlcmVkLlxuXG4gIGNvbXBOYW1lc0J5U3lzdGVtTmFtZTogTWFwPHN0cmluZywgc3RyaW5nW10+O1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZDxDVD4pIHtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5zeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgYWRkKGNUeXBlczogQ2xhc3NDb25zdHJ1Y3RvcjxDVD5bXSwgc3lzdGVtRnVuYzogU3lzdGVtRnVuYzxDVD4sIGZ1bmNOYW1lPzogc3RyaW5nKTogdGhpcyB7XG4gICAgY29uc3QgY05hbWVzID0gY1R5cGVzLm1hcCgoY3QpID0+IGN0Lm5hbWUpO1xuXG4gICAgXG4gICAgbGV0IG5hbWUgPSBzeXN0ZW1GdW5jLm5hbWU7XG4gICAgaWYgKHN5c3RlbUZ1bmMubmFtZSA9PT0gJycpIHtcbiAgICAgIC8vIFN1cGVyIGJydXRlIGZvcmNlLCBhbmQgbWlnaHQgbGVhZCB0byBlcnJvcnMgaW4gdGhlIGZ1dHVyZSwgYnV0IGZvciBub3dcbiAgICAgIC8vIHVzaW5nIHRoZSBzdHJpbmdpZmllZCBzeXN0ZW0gZnVuY3Rpb24gaWYgdGhlIGZ1bmN0aW9uIGRvZXNuJ3QgYWxyZWFkeSBoYXZlIGEgbmFtZS5cbiAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIHVzZWQgYXMgYSBzeXN0ZW0gZnVuY3Rpb24uXG4gICAgICAvLyBNaWdodCBiZSBnb29kIHRvIGZpZ3VyZSBvdXQgaG93IHRvIGdldCBhIGhhc2ggb2YgdGhlIGZ1bmN0aW9uIHN0cmluZy5cbiAgICAgIG5hbWUgPSBzeXN0ZW1GdW5jLnRvU3RyaW5nKCkuc2xpY2UoMCwgMzApO1xuICAgIH1cblxuICAgIGlmIChmdW5jTmFtZSkge1xuICAgICAgbmFtZSA9IGZ1bmNOYW1lO1xuICAgIH1cblxuICAgIHRoaXMuc3lzdGVtRnVuY0J5U3lzdGVtTmFtZS5zZXQobmFtZSwgc3lzdGVtRnVuYyk7XG4gICAgdGhpcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUuc2V0KG5hbWUsIGNOYW1lcyk7XG4gICAgdGhpcy53b3JsZC5lbnRpdGllc0J5Q1R5cGVzLnNldChjTmFtZXMsIG5ldyBTZXQ8RW50aXR5SWQ+KCkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBydW4oKTogdm9pZCB7XG5cbiAgICAvLyBUT0RPOiBNaWdodCBiZSBjb29sIHRvIGFkZCBhIHdheSB0byBzdG9wIHRoZSBzeXN0ZW1zIGxvb3Agd2hlbiBpbiBkZXYuXG4gICAgLy8gICAgICAgTWF5YmUgc29tZXRoaW5nIGxpa2Ugd29ybGQuZGV2LnN0b3AoKSBvciBwYXVzZSgpLlxuICAgIGZvciAoY29uc3QgW1xuICAgICAgZnVuY05hbWUsXG4gICAgICBzeXN0ZW1GdW5jLFxuICAgIF0gb2YgdGhpcy5zeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lLmVudHJpZXMoKSkge1xuICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLndvcmxkLmVudGl0aWVzQnlDVHlwZXMuc2l6ZTtcbiAgICAgIGNvbnN0IGNOYW1lcyA9IHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lLmdldChmdW5jTmFtZSkgfHwgW107XG4gICAgICBjb25zdCBjVHlwZUFycnMgPSB0aGlzLndvcmxkLmVudGl0aWVzQnlDVHlwZXMuZ2V0KGNOYW1lcykgfHwgbmV3IFNldCgpO1xuXG4gICAgICBmb3IgKGNvbnN0IGVpZCBvZiBjVHlwZUFycnMpIHtcbiAgICAgICAgY29uc3QgYXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+ID0ge1xuICAgICAgICAgIGVudGl0eTogdGhpcy53b3JsZC5lbnRpdGllcy5nZXQoZWlkKSB8fCBuZXcgRW50aXR5PENUPih0aGlzLndvcmxkKSxcbiAgICAgICAgICBjb21wb25lbnRzOlxuICAgICAgICAgICAgdGhpcy53b3JsZC5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZWlkKSB8fFxuICAgICAgICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCksXG4gICAgICAgICAgd29ybGQ6IHRoaXMud29ybGQsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBpc0ZpcnN0OiBpbmRleCA9PT0gMCxcbiAgICAgICAgICBpc0xhc3Q6IGluZGV4ICsgMSA9PT0gc2l6ZSxcbiAgICAgICAgfTtcblxuICAgICAgICBzeXN0ZW1GdW5jKGFyZ3MpO1xuXG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgV29ybGQsIHsgQ2xhc3NDb25zdHJ1Y3RvciB9IGZyb20gXCIuL1dvcmxkXCI7XG5pbXBvcnQgRW50aXR5IGZyb20gXCIuL0VudGl0eVwiO1xuXG4vLyBXYWl0aW5nIGZvciBUeXBlc2NyaXB0IDQuMiB0byBjb21lIG91dCBzbyB0aGF0IFN5bWJvbHMgYXJlIHN1cHBvcmRlZCBrZXlzLlxuZXhwb3J0IGNvbnN0IFRyYWNrZWRDb21wU3ltYm9sS2V5cyA9IHtcbiAgaXNUcmFja2VkOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQuaXNUcmFja2VkXCIpLFxuICB3b3JsZDogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50LndvcmxkXCIpLFxuICBzZXRXb3JsZDogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50LnNldFdvcmxkXCIpLFxuICBvbkFkZDogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50Lm9uQWRkXCIpLFxuICBvblVwZGF0ZTogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50Lm9uVXBkYXRlXCIpLFxuICBvblJlbW92ZTogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50Lm9uUmVtb3ZlXCIpLFxufSBhcyBjb25zdDtcblxuLy9AdHMtaWdub3JlXG50eXBlIFRyYWNrZWRDb21wb25lbnQ8Q1Q+ID0ge1xuICBuZXcgKC4uLmFyZ3M6IGFueVtdKTogQ1Q7XG5cbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMuaXNUcmFja2VkXTogYm9vbGVhbjtcbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMuc2V0V29ybGRdOiAod29ybGQ6IFdvcmxkPENUPikgPT4gdm9pZDtcbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMud29ybGRdOiBXb3JsZDxDVD47XG4gIC8vQHRzLWlnbm9yZVxuICBbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uQWRkXTogKFxuICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgZW50aXR5OiBFbnRpdHk8Q1Q+XG4gICkgPT4gdm9pZDtcbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMub25SZW1vdmVdOiAoXG4gICAgd29ybGQ6IFdvcmxkPENUPixcbiAgICBlbnRpdHk6IEVudGl0eTxDVD5cbiAgKSA9PiB2b2lkO1xufTtcblxuaW50ZXJmYWNlIEFkZEV2ZW50QXJnczxDVD4ge1xuICBjb21wb25lbnQ6IENUO1xuICBlbnRpdHk6IEVudGl0eTxDVD47XG4gIHdvcmxkOiBXb3JsZDxDVD47XG59XG5cbmludGVyZmFjZSBVcGRhdGVFdmVudEFyZ3M8Q1Q+IHtcbiAgY29tcG9uZW50OiBDVDtcbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgcHJldmlvdXNWYWw6IENUW2tleW9mIENUXTtcbiAgcHJvcGVydHk6IGtleW9mIENUO1xufVxuXG5pbnRlcmZhY2UgUmVtb3ZlRXZlbnRBcmdzPENUPiB7XG4gIGNvbXBvbmVudDogQ1Q7XG4gIGVudGl0eTogRW50aXR5PENUPjtcbiAgd29ybGQ6IFdvcmxkPENUPjtcbn1cblxuaW50ZXJmYWNlIFRyYWNrZWRFdmVudEhhbmRsZXJzPENUPiB7XG4gIG9uQWRkPzogKGFyZ3M6IEFkZEV2ZW50QXJnczxDVD4pID0+IHZvaWQ7XG4gIG9uVXBkYXRlPzogKGFyZ3M6IFVwZGF0ZUV2ZW50QXJnczxDVD4pID0+IHZvaWQ7XG4gIG9uUmVtb3ZlPzogKGFyZ3M6IFJlbW92ZUV2ZW50QXJnczxDVD4pID0+IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzSW5zdGFuY2VQcm94eUhhbmRsZXJzPENUPihcbiAgdHJhY2tlZEV2ZW50SGFuZGxlcnM6IFRyYWNrZWRFdmVudEhhbmRsZXJzPENUPlxuKTogUHJveHlIYW5kbGVyPGFueT4ge1xuICBjb25zdCB1cGRhdGVkUHJvcHMgPSBuZXcgU2V0KCk7XG4gIHJldHVybiB7XG4gICAgc2V0KFxuICAgICAgY29tcG9uZW50OiBDVCxcbiAgICAgIHByb3BlcnR5OiBrZXlvZiBDVCxcbiAgICAgIHZhbHVlOiBDVFtrZXlvZiBDVF1cbiAgICApIHtcbiAgICAgIHVwZGF0ZWRQcm9wcy5hZGQocHJvcGVydHkpO1xuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHdvcmxkID0gY29tcG9uZW50W1xuICAgICAgICBUcmFja2VkQ29tcFN5bWJvbEtleXMud29ybGRcbiAgICAgIF0gYXMgV29ybGQ8Q1Q+O1xuXG4gICAgICBjb25zdCBwcmV2aW91c1ZhbCA9IGNvbXBvbmVudFtwcm9wZXJ0eV07XG5cbiAgICAgIGNvbXBvbmVudFtwcm9wZXJ0eV0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHRyYWNrZWRFdmVudEhhbmRsZXJzLm9uVXBkYXRlKSB7XG4gICAgICAgIHRyYWNrZWRFdmVudEhhbmRsZXJzLm9uVXBkYXRlKHtcbiAgICAgICAgICB3b3JsZCxcbiAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgcHJldmlvdXNWYWwsXG4gICAgICAgICAgcHJvcGVydHksXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tDb21wb25lbnQ8Q1Q+KFxuICBDb21wQ2xhc3M6IENsYXNzQ29uc3RydWN0b3I8Q1Q+LFxuICB0cmFja2VkRXZlbnRIYW5kbGVyczogVHJhY2tlZEV2ZW50SGFuZGxlcnM8Q1Q+XG4pOiBUcmFja2VkQ29tcG9uZW50PENUPiB7XG4gIHJldHVybiBuZXcgUHJveHkoQ29tcENsYXNzLCB7XG4gICAgY29uc3RydWN0KENvbXBvbmVudDogYW55LCBhcmdzOiBhbnkpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoLi4uYXJncykgYXMgQ1QgJiBUcmFja2VkQ29tcG9uZW50PENUPjtcbiAgICAgIC8vIGNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoLi4uYXJncykgYXMgVCAmIFRyYWNrZWRDb21wb25lbnQ8Q2xhc3M8VD4+O1xuICAgICAgLy8gY29uc3QgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudCguLi5hcmdzKSBhcyBJbnN0YW5jZVR5cGU8Q2xhc3M8VD4+O1xuXG4gICAgICAvLyBGb3IgdXNlIGluIGlkZW50aWZpbmcgYSBcInRyYWNrZWRcIiBjbGFzcyB0aHJvdWdoIHRoZSBwcm94eS5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5pc1RyYWNrZWRdID0gdHJ1ZTtcblxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLnNldFdvcmxkXSA9IChcbiAgICAgICAgd29ybGQ6IFdvcmxkPENUPlxuICAgICAgKSA9PiB7XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLndvcmxkXSA9IHdvcmxkO1xuICAgICAgfTtcblxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uQWRkXSA9IChcbiAgICAgICAgd29ybGQ6IFdvcmxkPENUPixcbiAgICAgICAgZW50aXR5OiBFbnRpdHk8Q1Q+XG4gICAgICApID0+IHtcbiAgICAgICAgaWYgKHRyYWNrZWRFdmVudEhhbmRsZXJzLm9uQWRkKSB7XG4gICAgICAgICAgdHJhY2tlZEV2ZW50SGFuZGxlcnMub25BZGQoeyBjb21wb25lbnQsIHdvcmxkLCBlbnRpdHkgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vblJlbW92ZV0gPSAoXG4gICAgICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgICAgIGVudGl0eTogRW50aXR5PENUPlxuICAgICAgKSA9PiB7XG4gICAgICAgIGlmICh0cmFja2VkRXZlbnRIYW5kbGVycy5vblJlbW92ZSkge1xuICAgICAgICAgIHRyYWNrZWRFdmVudEhhbmRsZXJzLm9uUmVtb3ZlKHsgY29tcG9uZW50LCB3b3JsZCwgZW50aXR5IH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb3h5KFxuICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIGNyZWF0ZUNsYXNzSW5zdGFuY2VQcm94eUhhbmRsZXJzKHRyYWNrZWRFdmVudEhhbmRsZXJzKVxuICAgICAgKTtcbiAgICB9LFxuICB9KTtcbn1cbiIsImltcG9ydCBFbnRpdHksIHsgRW50aXR5SWQgfSBmcm9tIFwiLi9FbnRpdHlcIjtcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gXCIuL0NvbXBvbmVudENvbGxlY3Rpb25cIjtcbmltcG9ydCB7IFRhZyB9IGZyb20gXCIuL1RhZ1wiO1xuaW1wb3J0IHsgU3lzdGVtRnVuYyB9IGZyb20gXCIuL1N5c3RlbXNcIjtcbmltcG9ydCBEZXZUb29scyBmcm9tIFwiLi9EZXZUb29sc1wiO1xuaW1wb3J0IFN5c3RlbXMgZnJvbSAnLi9TeXN0ZW1zJztcbmltcG9ydCB7IFRyYWNrZWRDb21wU3ltYm9sS2V5cyB9IGZyb20gJy4vVHJhY2tlZENvbXBvbmVudCc7XG5cbmV4cG9ydCB0eXBlIENsYXNzQ29uc3RydWN0b3I8VD4gPSB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUIH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdvcmxkPENUPiB7XG4gIGNvbXBvbmVudENvbGxlY3Rpb25zOiBNYXA8RW50aXR5SWQsIENvbXBvbmVudENvbGxlY3Rpb248Q1Q+PiA9IG5ldyBNYXAoKTtcblxuICBlbnRpdGllczogTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+PiA9IG5ldyBNYXAoKTtcblxuICBlbnRpdGllc0J5Q1R5cGVzOiBNYXA8c3RyaW5nW10sIFNldDxFbnRpdHlJZD4+ID0gbmV3IE1hcCgpO1xuXG4gIGVudGl0aWVzQnlUYWdzOiBNYXA8VGFnLCBTZXQ8RW50aXR5SWQ+PiA9IG5ldyBNYXAoKTtcblxuICBzeXN0ZW1zOiBTeXN0ZW1zPENUPjtcblxuICBkZXY6IERldlRvb2xzPENUPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRldiA9IG5ldyBEZXZUb29scyh0aGlzKTtcbiAgICB0aGlzLnN5c3RlbXMgPSBuZXcgU3lzdGVtcyh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcImZpbmRzXCIgYSBzaW5nbGUgZW50aXR5IGJhc2VkIG9uIGEgcHJlZGljYXRlXG4gICAqL1xuICBmaW5kID0gKHByZWRpY2F0ZTogKGVudGl0eTogRW50aXR5PENUPikgPT4gYm9vbGVhbik6IEVudGl0eTxDVD4gfCBudWxsID0+IHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogXCJmaW5kc1wiIGFsbCBlbnRpdGllcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSwga2luZGEgbGlrZSBmaWx0ZXIuXG4gICAqL1xuICBmaW5kQWxsID0gKHByZWRpY2F0ZTogKGVudGl0eTogRW50aXR5PENUPikgPT4gYm9vbGVhbik6IEVudGl0eTxDVD5bXSA9PiB7XG4gICAgY29uc3QgcmVzdWx0czogRW50aXR5PENUPltdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGVudGl0eSkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFwibG9jYXRlc1wiIGEgc2luZ2xlIGVudGl0eSBiYXNlZCBvbiBpdHMgQ29tcG9uZW50cy5cbiAgICovXG4gIGxvY2F0ZSA9IChjbDogQ2xhc3NDb25zdHJ1Y3RvcjxDVD4gfCBDbGFzc0NvbnN0cnVjdG9yPENUPltdKTogRW50aXR5PENUPiB8IG51bGwgPT4ge1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHkuY29tcG9uZW50cy5oYXMoY2wpKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvY2F0ZXMgYWxsIGVudGl0aWVzIHRoYXQgY29udGFpbiB0aGUgY29tcG9uZW50cyBuYW1lZFxuICAgKi9cbiAgbG9jYXRlQWxsID0gKGNsOiBDbGFzc0NvbnN0cnVjdG9yPENUPiB8IENsYXNzQ29uc3RydWN0b3I8Q1Q+W10pOiBFbnRpdHk8Q1Q+W10gPT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6IEVudGl0eTxDVD5bXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVudGl0eS5jb21wb25lbnRzLmhhcyhjbCkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdyYWJzIHRoZSBmaXJzdCBlbnRpdHksIGFuZCBpdHMgcmVsYXRlZCBjb21wb25lbnQsIHRoYXQgbWF0Y2hlcyB0aGUgY29tcG9uZW50IHR5cGUuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zdCB7IGVudGl0eSwgY29tcG9uZW50IH0gPSB3b3JsZC5ncmFiKE15Q29tcG9uZW50KTtcbiAgICogYGBgXG4gICAqL1xuICBncmFiID0gPFQgZXh0ZW5kcyBDVD4oXG4gICAgY2w6IENsYXNzQ29uc3RydWN0b3I8VD5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogVCB9IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgZW50aXR5ID0gdGhpcy5sb2NhdGUoY2wpO1xuXG4gICAgaWYgKGVudGl0eSkge1xuICAgICAgY29uc3QgY2MgPVxuICAgICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlbnRpdHkuaWQpIHx8XG4gICAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgICBjb25zdCBjb21wb25lbnQgPSBjYy5nZXQ8VD4oY2wpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbnRpdHksXG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdyYWIgc2luZ2xlIGNvbXBvbmVudCBiYXNlZCBvbiBjb21wb25lbnQgdHlwZSBhbmQgcHJlZGljYXRlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHsgZW50aXR5LCBjb21wb25lbnQgfSA9IHdvcmxkLmdyYWJCeShGaXJzdENvbXBvbmVudCwgKGNvbXApID0+IGNvbXAuaWQgPT0gJ2F3ZXNvbWUnKVxuICAgKiBgYGBcbiAgICovXG4gIGdyYWJCeSA9IDxUIGV4dGVuZHMgQ1Q+KFxuICAgIGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+LFxuICAgIHByZWRpY2F0ZTogKGNvbXA6IFQpID0+IGJvb2xlYW5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogVCB9IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgZW50aXRpZXMgPSB0aGlzLmxvY2F0ZUFsbChjbCk7XG4gICAgLy8gY29uc3QgZW50aXRpZXMgPSB0aGlzLmxvY2F0ZUFsbCgoY2wgYXMgdW5rbm93bikgYXMgQ1QpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGNjID1cbiAgICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZW50aXR5LmlkKSB8fFxuICAgICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgICAgaWYgKHByZWRpY2F0ZShjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgIGVudGl0eSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR3JhYiBhbGwgdGhlIGNvbXBvbmVudHMgcHJpbWFyaWx5LCBhbmQgdGhlIGVudGl0aWVzIGlmIG5lZWRlZFxuICAgKi9cbiAgZ3JhYkFsbCA9IDxUIGV4dGVuZHMgQ1Q+KFxuICAgIGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+XG4gICk6IHsgZW50aXR5OiBFbnRpdHk8Q1Q+OyBjb21wb25lbnQ6IFQgfVtdID0+IHtcbiAgICBjb25zdCBlbnRpdGllcyA9IHRoaXMubG9jYXRlQWxsKGNsKTtcblxuICAgIHJldHVybiBlbnRpdGllcy5tYXAoKGVudGl0eSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW50aXR5LFxuICAgICAgICBjb21wb25lbnQ6IGVudGl0eS5jb21wb25lbnRzLmdldDxUPihjbCksXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRPRE86IEFkZCBncmFiQWxsQnkgbWV0aG9kXG5cbiAgLyoqXG4gICAqIEdpdmVuIGFuIGVudGl0eSBpZCBhbmQgY29tcG9uZW50VHlwZSwgcmV0dXJucyBjb21wb25lbnRcbiAgICovXG4gIGdldCA9IDxUIGV4dGVuZHMgQ1Q+KGVpZDogRW50aXR5SWQsIGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+KTogVCA9PiB7XG4gICAgY29uc3QgY2MgPVxuICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZWlkKSB8fCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIHJldHVybiBjYy5nZXQ8VD4oY2wpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIGFuZCBnZXQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGEgY29tcG9uZW50LCB3aXRob3V0IGFueSBhc3NvY2lhdGVkIGVudGl0aWVzLlxuICAgKiBIZWxwZnVsIGlzIHlvdSBrbm93IHRoYXQgb25seSBvbmUgaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgZXhpc3RzIGFjcm9zcyBhbGwgZW50aXRpZXMuXG4gICAqIEBwYXJhbSBjbCBDb21wb25lbnQgQ2xhc3MgQ29udHJ1Y3RvclxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEEgZGVmYXVsdCBjb21wb25lbnQgaW5zdGFuY2UgaWYgbm8gY29tcG9uZW50cyBhcmUgZm91bmQuXG4gICAqL1xuICBnZXRDb21wb25lbnQgPSA8VCBleHRlbmRzIENUPihcbiAgICBjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPixcbiAgICBkZWZhdWx0VmFsdWU/OiBUXG4gICk6IFQgfCBudWxsID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdyYWIoY2wpO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgPyBkZWZhdWx0VmFsdWUgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuY29tcG9uZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gZW50aXR5IHRoYXQgaGFzIGJlZW4gdGFnZ2VkIHdpdGggdGhlIGdpdmVuIHRhZywgb3IgcmV0dXJuIG51bGw7XG4gICAqL1xuICBnZXRUYWdnZWQgPSAodGFnOiBUYWcpOiBFbnRpdHk8Q1Q+IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgdGFnRW50aXR5SWRzID0gdGhpcy5lbnRpdGllc0J5VGFncy5nZXQodGFnKTtcblxuICAgIGlmICh0YWdFbnRpdHlJZHMpIHtcbiAgICAgIGNvbnN0IGVudGl0eUlkID0gdGFnRW50aXR5SWRzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZW50aXR5SWQpO1xuXG4gICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHQgYWxsIGVudGl0aWVzIHRoYXQgaGF2ZSBiZWVuIHRhZ2dlZCB3aXRoIHRoZSBnaXZlbiB0YWcuXG4gICAqIEBwYXJhbSB0YWcgQSBzdHJpbmcgb3IgbnVtYmVyLlxuICAgKi9cbiAgZ2V0QWxsVGFnZ2VkID0gKHRhZzogVGFnKTogRW50aXR5PENUPltdID0+IHtcbiAgICBsZXQgZW50aXRpZXM6IEVudGl0eTxDVD5bXSA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjb25zdCB0YWdFbnRpdHlJZHMgPSB0aGlzLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgaWYgKHRhZ0VudGl0eUlkcykge1xuICAgICAgZm9yIChjb25zdCBlbnRpdHlJZCBvZiB0YWdFbnRpdHlJZHMpIHtcbiAgICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZW50aXR5SWQpO1xuICAgICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgICAgZW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudGl0aWVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjb21wb25lbnQgb24gdGhlIGdpdmVuIGVudGl0eVxuICAgKi9cbiAgYWRkID0gPFQgZXh0ZW5kcyBDVD4oZWlkOiBFbnRpdHlJZCwgY29tcG9uZW50OiBUKTogdGhpcyA9PiB7XG4gICAgY29uc3QgY2MgPVxuICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZWlkKSB8fCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIGNjLmFkZChjb21wb25lbnQpO1xuXG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZWlkLCBjYyk7XG5cbiAgICBmb3IgKGNvbnN0IFtjdEFyciwgZW50aXR5U2V0XSBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMpIHtcbiAgICAgIGlmICgoY3RBcnIgYXMgc3RyaW5nW10pLmV2ZXJ5KGNjLmhhc0J5TmFtZSkpIHtcbiAgICAgICAgZW50aXR5U2V0LmFkZChlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5pc1RyYWNrZWRdKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLnNldFdvcmxkXSh0aGlzKTtcblxuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZWlkKTtcblxuICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3b3JsZC5hZGQ6IFVuYWJsZSB0byBsb2NhdGUgZW50aXR5LiBlaWQ6ICR7ZWlkfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uQWRkXSh0aGlzLCBlbnRpdHkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjb21wb25lbnQgZnJvbSB0aGUgZ2l2ZW4gZW50aXR5LlxuICAgKiBOT1RFOiBUaGlzIHdpbGwgY2hhbmdlIHdoYXQgc3lzdGVtcyB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgZW50aXR5LlxuICAgKi9cbiAgcmVtb3ZlID0gKGVpZDogRW50aXR5SWQsIGNUeXBlOiBDbGFzc0NvbnN0cnVjdG9yPENUPik6IHRoaXMgPT4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICAvLyBuZWVkIHRvIGdldCBjb21wb25lbnQgaW5zdGFuY2UuLi5cbiAgICBjb25zdCBjb21wb25lbnQgPSBjYy5nZXQoY1R5cGUpO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmlzVHJhY2tlZF0pIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW50aXRpZXMuZ2V0KGVpZCk7XG5cbiAgICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgd29ybGQucmVtb3ZlOiBVbmFibGUgdG8gbG9jYXRlIGVudGl0eS4gZWlkOiAke2VpZH0sIGNUeXBlOiAke2NUeXBlLm5hbWV9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMub25SZW1vdmVdKHRoaXMsIGVudGl0eSk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGVudGl0eSBmcm9tIGN1cnJlbnQgZW50aXRpZXNCeUNUeXBlc1xuICAgIGZvciAoY29uc3QgW2N0QXJyLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcykge1xuICAgICAgaWYgKChjdEFyciBhcyBzdHJpbmdbXSkuZXZlcnkoY2MuaGFzQnlOYW1lKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2MucmVtb3ZlKGNUeXBlKTtcblxuICAgIC8vIE1vdmUgZW50aXR5SWQgdG8gbmV3IENUeXBlcyBpZiBuZWVkZWQuXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5hZGQoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWx0ZXJuYXRpdmUgbWV0aG9kIGZvciBhZGRpbmcgc3lzdGVtcy5cbiAgICovXG4gIGFkZFN5c3RlbShjVHlwZXM6IENsYXNzQ29uc3RydWN0b3I8Q1Q+W10sIHN5c3RlbUZ1bmM6IFN5c3RlbUZ1bmM8Q1Q+LCBmdW5jTmFtZT86IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMuc3lzdGVtcy5hZGQoY1R5cGVzLCBzeXN0ZW1GdW5jLCBmdW5jTmFtZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlZ2lzdGVyRW50aXR5KGVudGl0eTogRW50aXR5PENUPik6IFdvcmxkPENUPiB7XG4gICAgY29uc3QgY2MgPSBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVudGl0eS5pZCwgY2MpO1xuICAgIHRoaXMuZW50aXRpZXMuc2V0KGVudGl0eS5pZCwgZW50aXR5KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgY29tcG9uZW50cyB0aGF0IGJlbG9uZyB0byBhbiBlbnRpdHkuXG4gICAqL1xuICBjbGVhckVudGl0eUNvbXBvbmVudHMoZWlkOiBFbnRpdHlJZCk6IHRoaXMge1xuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVpZCwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCkpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHlTZXQgb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZW50aXR5U2V0LmhhcyhlaWQpKSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZW50aXR5IHRoYXQgaXMgaW4gdGhlIHdvcmxkLlxuICAgKiBCYXNpY2FsbHkganVzdCBuZXcgRW50aXR5KHdvcmxkKSwgYnV0IHNhdmVzIGFuIGltcG9ydCBvZiBFbnRpdHkuXG4gICAqL1xuICBjcmVhdGVFbnRpdHkoKTogRW50aXR5PENUPiB7XG4gICAgY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eSh0aGlzKTtcblxuICAgIHJldHVybiBlbnRpdHk7XG5cbiAgICAvLyBSZWdpc3RlciBlbnRpdHkgaGVyZS4uLi5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBlbnRpdHkuXG4gICAqIFNhbWUgYXMgZW50aXR5LmRlc3Ryb3koKS5cbiAgICovXG4gIGRlc3Ryb3lFbnRpdHkoZWlkOiBFbnRpdHlJZCk6IFdvcmxkPENUPiB7XG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5kZWxldGUoZWlkKTtcbiAgICB0aGlzLmVudGl0aWVzLmRlbGV0ZShlaWQpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHlTZXQgb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZW50aXR5U2V0LmhhcyhlaWQpKSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYW55IHRhZyBhc3NvY2lhdGlvbnMgd2l0aCBkZXN0cm95ZWQgZW50aXRpZXMuXG4gICAgZm9yIChjb25zdCBbdGFnLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeVRhZ3MpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVpZCkpIHtcbiAgICAgICAgZW50aXR5U2V0LmRlbGV0ZShlaWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW50aXR5U2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbnRpdGllc0J5VGFncy5kZWxldGUodGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiaW1wb3J0IFdvcmxkIGZyb20gJy4vV29ybGQnO1xuaW1wb3J0IHsgdHJhY2tDb21wb25lbnQgfSBmcm9tICcuL1RyYWNrZWRDb21wb25lbnQnO1xuXG5leHBvcnQge1xuICBXb3JsZCxcbiAgdHJhY2tDb21wb25lbnQsXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n')}])}));