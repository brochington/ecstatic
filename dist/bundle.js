!function(Q,B){"object"==typeof exports&&"object"==typeof module?module.exports=B():"function"==typeof define&&define.amd?define("ecstatic",[],B):"object"==typeof exports?exports.ecstatic=B():Q.ecstatic=B()}(window,(function(){return function(Q){var B=window.webpackHotUpdateecstatic;window.webpackHotUpdateecstatic=function(Q,n){!function(Q,B){if(!V[Q]||!a[Q])return;for(var n in a[Q]=!1,B)Object.prototype.hasOwnProperty.call(B,n)&&(b[n]=B[n]);0==--C&&0===u&&R()}(Q,n),B&&B(Q,n)};var n,t=!0,e="7ca919a7ee0bca19d8d9",F={},c=[],I=[];function U(Q){var B=m[Q];if(!B)return p;var t=function(t){return B.hot.active?(m[t]?-1===m[t].parents.indexOf(Q)&&m[t].parents.push(Q):(c=[Q],n=t),-1===B.children.indexOf(t)&&B.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+Q),c=[]),p(t)},e=function(Q){return{configurable:!0,enumerable:!0,get:function(){return p[Q]},set:function(B){p[Q]=B}}};for(var F in p)Object.prototype.hasOwnProperty.call(p,F)&&"e"!==F&&"t"!==F&&Object.defineProperty(t,F,e(F));return t.e=function(Q){return"ready"===l&&g("prepare"),u++,p.e(Q).then(B,(function(Q){throw B(),Q}));function B(){u--,"prepare"===l&&(y[Q]||x(Q),0===u&&0===C&&R())}},t.t=function(Q,B){return 1&B&&(Q=t(Q)),p.t(Q,-2&B)},t}function s(B){var t={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:n!==B,active:!0,accept:function(Q,B){if(void 0===Q)t._selfAccepted=!0;else if("function"==typeof Q)t._selfAccepted=Q;else if("object"==typeof Q)for(var n=0;n<Q.length;n++)t._acceptedDependencies[Q[n]]=B||function(){};else t._acceptedDependencies[Q]=B||function(){}},decline:function(Q){if(void 0===Q)t._selfDeclined=!0;else if("object"==typeof Q)for(var B=0;B<Q.length;B++)t._declinedDependencies[Q[B]]=!0;else t._declinedDependencies[Q]=!0},dispose:function(Q){t._disposeHandlers.push(Q)},addDisposeHandler:function(Q){t._disposeHandlers.push(Q)},removeDisposeHandler:function(Q){var B=t._disposeHandlers.indexOf(Q);B>=0&&t._disposeHandlers.splice(B,1)},invalidate:function(){switch(this._selfInvalidated=!0,l){case"idle":(b={})[B]=Q[B],g("ready");break;case"ready":E(B);break;case"prepare":case"check":case"dispose":case"apply":(G=G||[]).push(B)}},check:X,apply:r,status:function(Q){if(!Q)return l;i.push(Q)},addStatusHandler:function(Q){i.push(Q)},removeStatusHandler:function(Q){var B=i.indexOf(Q);B>=0&&i.splice(B,1)},data:F[B]};return n=void 0,t}var i=[],l="idle";function g(Q){l=Q;for(var B=0;B<i.length;B++)i[B].call(null,Q)}var d,b,o,G,C=0,u=0,y={},a={},V={};function Z(Q){return+Q+""===Q?+Q:Q}function X(Q){if("idle"!==l)throw new Error("check() is only allowed in idle status");return t=Q,g("check"),(B=1e4,B=B||1e4,new Promise((function(Q,n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var t=new XMLHttpRequest,e=p.p+"hot/hot-update.json";t.open("GET",e,!0),t.timeout=B,t.send(null)}catch(Q){return n(Q)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)n(new Error("Manifest request to "+e+" timed out."));else if(404===t.status)Q();else if(200!==t.status&&304!==t.status)n(new Error("Manifest request to "+e+" failed."));else{try{var B=JSON.parse(t.responseText)}catch(Q){return void n(Q)}Q(B)}}}))).then((function(Q){if(!Q)return g(N()?"ready":"idle"),null;a={},y={},V=Q.c,o=Q.h,g("prepare");var B=new Promise((function(Q,B){d={resolve:Q,reject:B}}));b={};return x(0),"prepare"===l&&0===u&&0===C&&R(),B}));var B}function x(Q){var B;V[Q]?(a[Q]=!0,C++,(B=document.createElement("script")).charset="utf-8",B.src=p.p+"hot/hot-update.js",document.head.appendChild(B)):y[Q]=!0}function R(){g("ready");var Q=d;if(d=null,Q)if(t)Promise.resolve().then((function(){return r(t)})).then((function(B){Q.resolve(B)}),(function(B){Q.reject(B)}));else{var B=[];for(var n in b)Object.prototype.hasOwnProperty.call(b,n)&&B.push(Z(n));Q.resolve(B)}}function r(B){if("ready"!==l)throw new Error("apply() is only allowed in ready status");return function B(t){var I,U,s,i,l;function d(Q){for(var B=[Q],n={},t=B.map((function(Q){return{chain:[Q],id:Q}}));t.length>0;){var e=t.pop(),F=e.id,c=e.chain;if((i=m[F])&&(!i.hot._selfAccepted||i.hot._selfInvalidated)){if(i.hot._selfDeclined)return{type:"self-declined",chain:c,moduleId:F};if(i.hot._main)return{type:"unaccepted",chain:c,moduleId:F};for(var I=0;I<i.parents.length;I++){var U=i.parents[I],s=m[U];if(s){if(s.hot._declinedDependencies[F])return{type:"declined",chain:c.concat([U]),moduleId:F,parentId:U};-1===B.indexOf(U)&&(s.hot._acceptedDependencies[F]?(n[U]||(n[U]=[]),C(n[U],[F])):(delete n[U],B.push(U),t.push({chain:c.concat([U]),id:U})))}}}}return{type:"accepted",moduleId:Q,outdatedModules:B,outdatedDependencies:n}}function C(Q,B){for(var n=0;n<B.length;n++){var t=B[n];-1===Q.indexOf(t)&&Q.push(t)}}N();var u={},y=[],a={},X=function(){console.warn("[HMR] unexpected require("+R.moduleId+") to disposed module")};for(var x in b)if(Object.prototype.hasOwnProperty.call(b,x)){var R;l=Z(x),R=b[x]?d(l):{type:"disposed",moduleId:x};var r=!1,E=!1,L=!1,W="";switch(R.chain&&(W="\nUpdate propagation: "+R.chain.join(" -> ")),R.type){case"self-declined":t.onDeclined&&t.onDeclined(R),t.ignoreDeclined||(r=new Error("Aborted because of self decline: "+R.moduleId+W));break;case"declined":t.onDeclined&&t.onDeclined(R),t.ignoreDeclined||(r=new Error("Aborted because of declined dependency: "+R.moduleId+" in "+R.parentId+W));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(R),t.ignoreUnaccepted||(r=new Error("Aborted because "+l+" is not accepted"+W));break;case"accepted":t.onAccepted&&t.onAccepted(R),E=!0;break;case"disposed":t.onDisposed&&t.onDisposed(R),L=!0;break;default:throw new Error("Unexception type "+R.type)}if(r)return g("abort"),Promise.reject(r);if(E)for(l in a[l]=b[l],C(y,R.outdatedModules),R.outdatedDependencies)Object.prototype.hasOwnProperty.call(R.outdatedDependencies,l)&&(u[l]||(u[l]=[]),C(u[l],R.outdatedDependencies[l]));L&&(C(y,[R.moduleId]),a[l]=X)}var h,A=[];for(U=0;U<y.length;U++)l=y[U],m[l]&&m[l].hot._selfAccepted&&a[l]!==X&&!m[l].hot._selfInvalidated&&A.push({module:l,parents:m[l].parents.slice(),errorHandler:m[l].hot._selfAccepted});g("dispose"),Object.keys(V).forEach((function(Q){!1===V[Q]&&function(Q){delete installedChunks[Q]}(Q)}));var D,v,S=y.slice();for(;S.length>0;)if(l=S.pop(),i=m[l]){var Y={},H=i.hot._disposeHandlers;for(s=0;s<H.length;s++)(I=H[s])(Y);for(F[l]=Y,i.hot.active=!1,delete m[l],delete u[l],s=0;s<i.children.length;s++){var T=m[i.children[s]];T&&((h=T.parents.indexOf(l))>=0&&T.parents.splice(h,1))}}for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=m[l]))for(v=u[l],s=0;s<v.length;s++)D=v[s],(h=i.children.indexOf(D))>=0&&i.children.splice(h,1);g("apply"),void 0!==o&&(e=o,o=void 0);for(l in b=void 0,a)Object.prototype.hasOwnProperty.call(a,l)&&(Q[l]=a[l]);var z=null;for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=m[l])){v=u[l];var J=[];for(U=0;U<v.length;U++)if(D=v[U],I=i.hot._acceptedDependencies[D]){if(-1!==J.indexOf(I))continue;J.push(I)}for(U=0;U<J.length;U++){I=J[U];try{I(v)}catch(Q){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:l,dependencyId:v[U],error:Q}),t.ignoreErrored||z||(z=Q)}}}for(U=0;U<A.length;U++){var f=A[U];l=f.module,c=f.parents,n=l;try{p(l)}catch(Q){if("function"==typeof f.errorHandler)try{f.errorHandler(Q)}catch(B){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:l,error:B,originalError:Q}),t.ignoreErrored||z||(z=B),z||(z=Q)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:l,error:Q}),t.ignoreErrored||z||(z=Q)}}if(z)return g("fail"),Promise.reject(z);if(G)return B(t).then((function(Q){return y.forEach((function(B){Q.indexOf(B)<0&&Q.push(B)})),Q}));return g("idle"),new Promise((function(Q){Q(y)}))}(B=B||{})}function N(){if(G)return b||(b={}),G.forEach(E),G=void 0,!0}function E(B){Object.prototype.hasOwnProperty.call(b,B)||(b[B]=Q[B])}var m={};function p(B){if(m[B])return m[B].exports;var n=m[B]={i:B,l:!1,exports:{},hot:s(B),parents:(I=c,c=[],I),children:[]};return Q[B].call(n.exports,n,n.exports,U(B)),n.l=!0,n.exports}return p.m=Q,p.c=m,p.d=function(Q,B,n){p.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:n})},p.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},p.t=function(Q,B){if(1&B&&(Q=p(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var n=Object.create(null);if(p.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var t in Q)p.d(n,t,function(B){return Q[B]}.bind(null,t));return n},p.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return p.d(B,"a",B),B},p.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},p.p="/static/",p.h=function(){return e},U(0)(p.s=0)}([function(Q,B,n){Q.exports=n(1)},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "World", function() { return /* reexport */ World_World; });\n__webpack_require__.d(__webpack_exports__, "createEntity", function() { return /* reexport */ createEntity; });\n__webpack_require__.d(__webpack_exports__, "createSystem", function() { return /* reexport */ createSystem; });\n\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== \'undefined\' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \'undefined\' && typeof msCrypto.getRandomValues === \'function\' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error(\'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js\n/* harmony default export */ var regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js\n\n\nfunction validate(uuid) {\n  return typeof uuid === \'string\' && regex.test(uuid);\n}\n\n/* harmony default export */ var esm_browser_validate = (validate);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var stringify_i = 0; stringify_i < 256; ++stringify_i) {\n  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It\'s been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \'-\' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \'-\' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \'-\' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \'-\' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it\'s likely due to one\n  // of the following:\n  // - One or more input array values don\'t map to a hex octet (leading to\n  // "undefined" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!esm_browser_validate(uuid)) {\n    throw TypeError(\'Stringified UUID is invalid\');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ var esm_browser_stringify = (stringify);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return esm_browser_stringify(rnds);\n}\n\n/* harmony default export */ var esm_browser_v4 = (v4);\n// CONCATENATED MODULE: ./src/guards.ts\n// export function classIsCompType(cl: any)\nfunction isComponentInstance(Class, comp) {\n  if (!comp) {\n    return false;\n  }\n\n  if (!(comp instanceof Class)) {\n    return false;\n  }\n\n  return true;\n}\nfunction isComponentName(possibleName, entitiesByCTypes) {\n  // string\n  if (typeof possibleName !== \'string\') {\n    return false;\n  }\n\n  for (const a of entitiesByCTypes.keys()) {\n    if (a.includes(possibleName)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n// CONCATENATED MODULE: ./src/ComponentCollection.ts\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n// CT is a Union, like `type = typeof FirstComponent | typeof SecondComponent`.\nclass ComponentCollection_ComponentCollection {\n  constructor() {\n    _defineProperty(this, "components", new Map());\n\n    _defineProperty(this, "add", component => {\n      this.components.set(component.constructor.name, component);\n    });\n\n    _defineProperty(this, "update", (cl, func) => {\n      const c = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, c)) {\n        const updatedComponent = func(c);\n        this.components.set(cl.name, updatedComponent);\n      }\n    });\n\n    _defineProperty(this, "remove", cType => {\n      this.components.delete(cType.name);\n    });\n\n    _defineProperty(this, "get", cl => {\n      const comp = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, comp)) {\n        return comp;\n      } else {\n        throw new Error(`ComponentCollection does not have component of type ${cl.name}`);\n      }\n    });\n\n    _defineProperty(this, "has", cType => {\n      return Array.isArray(cType) ? cType.every(ct => this.components.has(ct.name) === true) : this.components.has(cType.name);\n    });\n\n    _defineProperty(this, "hasByName", cName => {\n      return Array.isArray(cName) ? cName.every(ct => this.components.has(ct) === true) : this.components.has(cName);\n    });\n  }\n\n  /**\n   * Get the component type names that are currently being used in the collection.\n   */\n  get componentTypes() {\n    return [...this.components.keys()];\n  }\n  /**\n   * Get the current number of components that are in the collection.\n   */\n\n\n  get size() {\n    return this.components.size;\n  }\n\n  toDevComponents() {\n    const obj = {};\n\n    for (const [compName, comp] of this.components) {\n      obj[compName] = comp;\n    }\n\n    return obj;\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevEntity.ts\nfunction DevEntity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevEntity {\n  constructor(entity, world) {\n    DevEntity_defineProperty(this, "id", void 0);\n\n    DevEntity_defineProperty(this, "components", void 0);\n\n    DevEntity_defineProperty(this, "tags", void 0);\n\n    DevEntity_defineProperty(this, "systems", []);\n\n    this.id = entity.id;\n    this.components = entity.components.toDevComponents(), this.tags = [...entity.tags];\n    const compNames = Object.keys(this.components);\n\n    for (const [systemName, cNames] of world.compNamesBySystemName) {\n      if (cNames.every(cName => compNames.includes(cName))) {\n        this.systems.push(systemName);\n      }\n    }\n  }\n\n  toTableRow() {\n    return {\n      id: this.id,\n      components: Object.keys(this.components).join(", "),\n      tags: this.tags.join(", "),\n      systems: this.systems.join(\', \')\n    };\n  }\n\n}\n\n/* harmony default export */ var src_DevEntity = (DevEntity);\n// CONCATENATED MODULE: ./src/Entity.ts\nfunction Entity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nclass Entity_Entity {\n  constructor(world) {\n    Entity_defineProperty(this, "_id", void 0);\n\n    Entity_defineProperty(this, "_world", void 0);\n\n    this._id = esm_browser_v4();\n    this._world = world;\n    /*\n    Registering with the World.\n    */\n\n    this._world.registerEntity(this);\n  }\n  /**\n   * Add a component to an Entity, doh.\n   */\n\n\n  add(component) {\n    this._world.set(this._id, component);\n\n    return this;\n  }\n  /**\n   * Add a tag to a component\n   */\n\n\n  addTag(tag) {\n    const entitySet = this._world.entitiesByTags.has(tag) ? this._world.entitiesByTags.get(tag) : new Set();\n\n    if (entitySet) {\n      entitySet.add(this._id);\n\n      this._world.entitiesByTags.set(tag, entitySet);\n    }\n\n    return this;\n  }\n  /**\n   * Determines if an entity has a component related to it.\n   */\n\n\n  has(cType) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    return cc.has(cType);\n  }\n  /**\n   * Check to see if an entity tagged with a given tag.\n   */\n\n\n  hasTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        return entitySet.has(this._id);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get a component that belongs to an entity.\n   */\n\n\n  get(cl) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    const component = cc.get(cl);\n    return component;\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection\n   */\n\n\n  getAll() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Remove a component from an entity.\n   * @param cType A component class, eg MyComponent\n   */\n\n\n  remove(cType) {\n    this._world.remove(this._id, cType);\n\n    return this;\n  }\n  /**\n   * Remove a tag from an entity\n   */\n\n\n  removeTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        entitySet.delete(this._id);\n\n        if (entitySet.size === 0) {\n          this._world.entitiesByTags.delete(tag);\n        }\n      }\n    }\n\n    return this;\n  }\n  /** Clears all components from an Entity */\n\n\n  clear() {\n    this._world.clearEntityComponents(this._id);\n\n    return this;\n  }\n  /**\n   * Remove all tags on an entity\n   */\n\n\n  clearTags() {\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      entitySet.delete(this._id);\n\n      if (entitySet.size === 0) {\n        this._world.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n  destroy() {\n    this._world.destroyEntity(this._id);\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get world() {\n    return this._world;\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection.\n   * Does the same thing as entityInstance.getAll().\n   */\n\n\n  get components() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Retrieves all the tags that have been added to this entity.\n   */\n\n\n  get tags() {\n    const tags = new Set();\n\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      if (entitySet.has(this._id)) {\n        tags.add(tag);\n      }\n    }\n\n    return tags;\n  }\n\n  toDevEntity() {\n    return new src_DevEntity(this, this._world);\n  }\n\n}\nfunction createEntity(world) {\n  const entity = new Entity_Entity(world);\n  return entity;\n}\n// CONCATENATED MODULE: ./src/System.ts\n\n\n\n/**\n * This is how you create a System.\n * @example\n * ```\n * createSystem(world, [\'ComponentType\'], ({ entity }) => \'Do fun system things here.\')\n * ```\n */\nfunction createSystem(world, cTypes, systemFunc) {\n  const cNames = cTypes.map(ct => ct.name);\n  world.registerSystem(cNames, systemFunc.name);\n  return () => {\n    let index = 0;\n    const size = world.entitiesByCTypes.size; // Used for matching the array of ComponentTypes which is the key\n    // of where the ComponentCollection is, with the array of ComponentTypes\n    // that are passes.\n    // Might be nice in the future to go back to a ref check on cTypes, but\n    // for now this doesn\'t seem to be that much of a perf hit.\n    // for (const ct of world.entitiesByCTypes.keys()) {\n    //   if (cTypes.length === ct.length && cTypes.every(c => ct.includes(c))) {\n    //     for (const eid of world.entitiesByCTypes.get(cTypes)) {\n    //       const args: SystemFuncArgs<CT> = {\n    //         entity: world.entities.get(eid),\n    //         components: world.componentCollections.get(eid),\n    //         world,\n    //         index,\n    //         size,\n    //         isFirst: index === 0,\n    //         isLast: index + 1 === size,\n    //       }\n    //       systemFunc(args);\n    //       index += 1;\n    //     }\n    //   }\n    // }\n\n    const cTypeArrs = world.entitiesByCTypes.get(cNames) || new Set();\n\n    for (const eid of cTypeArrs) {\n      const args = {\n        entity: world.entities.get(eid) || new Entity_Entity(world),\n        components: world.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(),\n        world,\n        index,\n        size,\n        isFirst: index === 0,\n        isLast: index + 1 === size\n      };\n      systemFunc(args);\n      index += 1;\n    }\n  };\n}\n// CONCATENATED MODULE: ./src/DevTools.ts\nfunction DevTools_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevTools {\n  constructor(world) {\n    DevTools_defineProperty(this, "world", void 0);\n\n    this.world = world;\n  }\n  /**\n   * display the all systems of the world, and the components required by each system.\n   * Super helpful to use with console.table()\n   * @example\n   * ```\n   * console.table(world.dev.systemComponents);\n   * ```\n   */\n\n\n  get systemComponents() {\n    const compsBySystems = [];\n\n    for (const [system, compNames] of this.world.compNamesBySystemName) {\n      compsBySystems.push({\n        system,\n        components: compNames.join(", ")\n      });\n    }\n\n    return compsBySystems;\n  }\n  /**\n   * Create an array of DevEntites. Can be very helpful for things like inspecting component state,\n   * and which systems will be called on an entity.\n   * @example\n   * ```\n   * console.table(world.dev.entities);\n   *\n   * // Pro tip! try displaying a table of entities with console.table and DevEntity.toTableRow().\n   * console.table(world.dev.entities.map(devEntity => devEntity.toTableRow()));\n   * ```\n   */\n\n\n  get entities() {\n    return [...this.world.entities.values()].map(e => e.toDevEntity());\n  }\n\n}\n\n/* harmony default export */ var src_DevTools = (DevTools);\n// CONCATENATED MODULE: ./src/World.ts\nfunction World_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nclass World_World {\n  constructor() {\n    World_defineProperty(this, "componentCollections", new Map());\n\n    World_defineProperty(this, "entities", new Map());\n\n    World_defineProperty(this, "entitiesByCTypes", new Map());\n\n    World_defineProperty(this, "entitiesByTags", new Map());\n\n    World_defineProperty(this, "compNamesBySystemName", new Map());\n\n    World_defineProperty(this, "dev", void 0);\n\n    World_defineProperty(this, "find", predicate => {\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "findAll", predicate => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "locate", cl => {\n      for (const entity of this.entities.values()) {\n        // console.log("entity?", entity.components, cl.name);\n        if (entity.components.has(cl)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "locateAll", cl => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "grab", cl => {\n      // const entity = this.locate((cl as unknown) as CT[keyof CT]);\n      const entity = this.locate(cl);\n\n      if (entity) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n        return {\n          entity,\n          component\n        };\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabBy", (cl, predicate) => {\n      const entities = this.locateAll(cl);\n\n      for (const entity of entities) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n\n        if (predicate(component)) {\n          return {\n            component,\n            entity\n          };\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabAll", cl => {\n      const entities = this.locateAll(cl);\n      return entities.map(entity => {\n        return {\n          entity,\n          component: entity.components.get(cl)\n        };\n      });\n    });\n\n    World_defineProperty(this, "get", (eid, cl) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      return cc.get(cl);\n    });\n\n    World_defineProperty(this, "getComponent", (cl, defaultValue) => {\n      const result = this.grab(cl);\n\n      if (!result) {\n        return defaultValue ? defaultValue : null;\n      }\n\n      return result.component;\n    });\n\n    World_defineProperty(this, "getTagged", tag => {\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        const entityId = tagEntityIds.values().next().value;\n        const entity = this.entities.get(entityId);\n\n        if (entity) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "getAllTagged", tag => {\n      let entities = []; // eslint-disable-line\n\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        for (const entityId of tagEntityIds) {\n          const entity = this.entities.get(entityId);\n\n          if (entity) {\n            entities.push(entity);\n          }\n        }\n      }\n\n      return entities;\n    });\n\n    World_defineProperty(this, "set", (eid, component) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      cc.add(component);\n      this.componentCollections.set(eid, cc);\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      return this;\n    });\n\n    World_defineProperty(this, "remove", (eid, cType) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(); // remove entity from current entitiesByCTypes\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.delete(eid);\n        }\n      }\n\n      cc.remove(cType); // Move entityId to new CTypes if needed.\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      return this;\n    });\n\n    this.dev = new src_DevTools(this);\n  }\n  /**\n   * "finds" a single entity based on a predicate\n   */\n\n\n  /**\n   * Internal method used in setting up a new system.\n   */\n  registerSystem(cNames, systemName) {\n    this.compNamesBySystemName.set(systemName, [...cNames]);\n    this.entitiesByCTypes.set(cNames, new Set());\n    return this;\n  }\n  /**\n   * an alias for createSystem().\n   */\n\n\n  createSystem(cl, systemFunc) {\n    const system = createSystem(this, cl, systemFunc);\n    return system;\n  }\n\n  registerEntity(entity) {\n    const cc = new ComponentCollection_ComponentCollection();\n    this.componentCollections.set(entity.id, cc);\n    this.entities.set(entity.id, entity);\n    return this;\n  }\n  /**\n   * Remove all components that belong to an entity.\n   */\n\n\n  clearEntityComponents(eid) {\n    this.componentCollections.set(eid, new ComponentCollection_ComponentCollection());\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Create an entity that is in the world.\n   * Basically just new Entity(world), but saves an import of Entity.\n   */\n\n\n  createEntity() {\n    const entity = new Entity_Entity(this);\n    return entity;\n  }\n  /**\n   * Destroys an entity.\n   * Same as entity.destroy().\n   */\n\n\n  destroyEntity(eid) {\n    this.componentCollections.delete(eid);\n    this.entities.delete(eid);\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    } // remove any tag associations with destroyed entities.\n\n\n    for (const [tag, entitySet] of this.entitiesByTags) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n\n      if (entitySet.size === 0) {\n        this.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n}\n// CONCATENATED MODULE: ./src/index.ts\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY3N0YXRpYy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzP2Q4ZjgiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzPzQwZDYiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzA2ZTQiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3N0cmluZ2lmeS5qcz81OGNmIiwid2VicGFjazovL2Vjc3RhdGljLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz9lYzI2Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL2d1YXJkcy50cz8zYjU3Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL0NvbXBvbmVudENvbGxlY3Rpb24udHM/NTFjNCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZFbnRpdHkudHM/ZDE0MiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9FbnRpdHkudHM/YWM2OCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9TeXN0ZW0udHM/MzI0OCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZUb29scy50cz9lMDFhIiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL1dvcmxkLnRzP2NjMGIiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9zcmMvaW5kZXgudHM/ZmZiNCJdLCJuYW1lcyI6WyJpc0NvbXBvbmVudEluc3RhbmNlIiwiQ2xhc3MiLCJjb21wIiwiaXNDb21wb25lbnROYW1lIiwicG9zc2libGVOYW1lIiwiZW50aXRpZXNCeUNUeXBlcyIsImEiLCJrZXlzIiwiaW5jbHVkZXMiLCJDb21wb25lbnRDb2xsZWN0aW9uIiwiTWFwIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInNldCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNsIiwiZnVuYyIsImMiLCJnZXQiLCJ1cGRhdGVkQ29tcG9uZW50IiwiY1R5cGUiLCJkZWxldGUiLCJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwiY3QiLCJoYXMiLCJjTmFtZSIsImNvbXBvbmVudFR5cGVzIiwic2l6ZSIsInRvRGV2Q29tcG9uZW50cyIsIm9iaiIsImNvbXBOYW1lIiwiRGV2RW50aXR5IiwiZW50aXR5Iiwid29ybGQiLCJpZCIsInRhZ3MiLCJjb21wTmFtZXMiLCJPYmplY3QiLCJzeXN0ZW1OYW1lIiwiY05hbWVzIiwiY29tcE5hbWVzQnlTeXN0ZW1OYW1lIiwic3lzdGVtcyIsInB1c2giLCJ0b1RhYmxlUm93Iiwiam9pbiIsIkVudGl0eSIsIl9pZCIsInV1aWR2NCIsIl93b3JsZCIsInJlZ2lzdGVyRW50aXR5IiwiYWRkIiwiYWRkVGFnIiwidGFnIiwiZW50aXR5U2V0IiwiZW50aXRpZXNCeVRhZ3MiLCJTZXQiLCJjYyIsImNvbXBvbmVudENvbGxlY3Rpb25zIiwiaGFzVGFnIiwiZ2V0QWxsIiwicmVtb3ZlIiwicmVtb3ZlVGFnIiwiY2xlYXIiLCJjbGVhckVudGl0eUNvbXBvbmVudHMiLCJjbGVhclRhZ3MiLCJlbnRyaWVzIiwiZGVzdHJveSIsImRlc3Ryb3lFbnRpdHkiLCJ0b0RldkVudGl0eSIsImNyZWF0ZUVudGl0eSIsImNyZWF0ZVN5c3RlbSIsImNUeXBlcyIsInN5c3RlbUZ1bmMiLCJtYXAiLCJyZWdpc3RlclN5c3RlbSIsImluZGV4IiwiY1R5cGVBcnJzIiwiZWlkIiwiYXJncyIsImVudGl0aWVzIiwiaXNGaXJzdCIsImlzTGFzdCIsIkRldlRvb2xzIiwic3lzdGVtQ29tcG9uZW50cyIsImNvbXBzQnlTeXN0ZW1zIiwic3lzdGVtIiwidmFsdWVzIiwiZSIsIldvcmxkIiwicHJlZGljYXRlIiwicmVzdWx0cyIsImxvY2F0ZSIsImxvY2F0ZUFsbCIsImRlZmF1bHRWYWx1ZSIsInJlc3VsdCIsImdyYWIiLCJ0YWdFbnRpdHlJZHMiLCJlbnRpdHlJZCIsIm5leHQiLCJ2YWx1ZSIsImN0QXJyIiwiaGFzQnlOYW1lIiwiZGV2Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7QUNsQmUsd0RBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyx5Q0FBeUMsRTs7QUNBckc7O0FBRS9CO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7O0FBRWUsaUVBQVEsRTs7QUNOYztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTLFdBQUMsS0FBSyxDQUFDLFdBQUMsT0FBTyxHQUFHLFdBQUM7QUFDNUIsa0JBQWtCLFdBQUM7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Z0JBQXlnQjtBQUN6Z0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxvQkFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFZSxtRUFBUyxFOztBQzdCRztBQUNZOztBQUV2QztBQUNBO0FBQ0EsK0NBQStDLEdBQUcsSUFBSTs7QUFFdEQ7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMscUJBQVM7QUFDbEI7O0FBRWUscURBQUUsRTs7QUNuQmpCO0FBRU8sU0FBU0EsbUJBQVQsQ0FDTEMsS0FESyxFQUVMQyxJQUZLLEVBRytCO0FBQ3BDLE1BQUksQ0FBQ0EsSUFBTCxFQUFXO0FBQ1QsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsTUFBSSxFQUFFQSxJQUFJLFlBQVlELEtBQWxCLENBQUosRUFBOEI7QUFDNUIsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBTyxJQUFQO0FBQ0Q7QUFHTSxTQUFTRSxlQUFULENBQ0xDLFlBREssRUFFTEMsZ0JBRkss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QjtBQUNEOztBQUVELFVBQUl4QixTQUFTLENBQUMxQixJQUFWLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLGFBQUsyQixjQUFMLENBQW9CcEMsTUFBcEIsQ0FBMkJrQyxHQUEzQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7O0FBMVYrQyxDOztBQ1JsRDtBQUNBO0FBQ0EiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxudmFyIGdldFJhbmRvbVZhbHVlcztcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuICAgIC8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFycikge1xuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgdmFyIHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7IiwiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwiaW1wb3J0IEVudGl0eSwgeyBFbnRpdHlJZCB9IGZyb20gXCIuL0VudGl0eVwiO1xuaW1wb3J0IHsgQ29tcFR5cGVzIH0gZnJvbSAnaW50ZXJmYWNlcyc7XG5pbXBvcnQgQ29tcG9uZW50Q29sbGVjdGlvbiBmcm9tICcuL0NvbXBvbmVudENvbGxlY3Rpb24nO1xuXG4vLyBleHBvcnQgZnVuY3Rpb24gY2xhc3NJc0NvbXBUeXBlKGNsOiBhbnkpXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbXBvbmVudEluc3RhbmNlPFQ+KFxuICBDbGFzczogbmV3ICguLi5hcmdzOiBhbnkpID0+IFQsXG4gIGNvbXA6IGFueVxuKTogY29tcCBpcyBJbnN0YW5jZVR5cGU8dHlwZW9mIENsYXNzPiB7XG4gIGlmICghY29tcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDbGFzcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb21wb25lbnROYW1lPENUIGV4dGVuZHMgQ29tcFR5cGVzPENUPj4oXG4gIHBvc3NpYmxlTmFtZTogYW55LFxuICBlbnRpdGllc0J5Q1R5cGVzOiBNYXA8KGtleW9mIENUKVtdLCBTZXQ8RW50aXR5SWQ+PlxuKTogcG9zc2libGVOYW1lIGlzIENUW2tleW9mIENUXSB7XG4gIC8vIHN0cmluZ1xuICBpZiAodHlwZW9mIHBvc3NpYmxlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGEgb2YgZW50aXRpZXNCeUNUeXBlcy5rZXlzKCkpIHtcbiAgICBpZiAoYS5pbmNsdWRlcyhwb3NzaWJsZU5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgeyBpc0NvbXBvbmVudEluc3RhbmNlIH0gZnJvbSBcIi4vZ3VhcmRzXCI7XG5cbnR5cGUgQ2xhc3M8VD4gPSB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUIH07XG5cbi8vIENUIGlzIGEgVW5pb24sIGxpa2UgYHR5cGUgPSB0eXBlb2YgRmlyc3RDb21wb25lbnQgfCB0eXBlb2YgU2Vjb25kQ29tcG9uZW50YC5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBvbmVudENvbGxlY3Rpb248Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PiB7XG4gIGNvbXBvbmVudHM6IE1hcDxzdHJpbmcsIEluc3RhbmNlVHlwZTxDVD4+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIGluc3RhbmNlIG9mIGEgY29tcG9uZW50XG4gIC8vIGFkZCA9IChjb21wb25lbnQ6IEluc3RhbmNlVHlwZTxDVFtrZXlvZiBDVF0+KTogdm9pZCA9PiB7XG4gIGFkZCA9IChjb21wb25lbnQ6IEluc3RhbmNlVHlwZTxDVD4pOiB2b2lkID0+IHtcbiAgICB0aGlzLmNvbXBvbmVudHMuc2V0KGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lLCBjb21wb25lbnQpO1xuICB9O1xuXG4gIHVwZGF0ZSA9IDxUPihcbiAgICBjbDogQ2xhc3M8VD4sXG4gICAgZnVuYzogKGM6IEluc3RhbmNlVHlwZTx0eXBlb2YgY2w+KSA9PiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPlxuICApOiB2b2lkID0+IHtcbiAgICBjb25zdCBjID0gdGhpcy5jb21wb25lbnRzLmdldChjbC5uYW1lKTtcblxuICAgIGlmIChpc0NvbXBvbmVudEluc3RhbmNlKGNsLCBjKSkge1xuICAgICAgY29uc3QgdXBkYXRlZENvbXBvbmVudCA9IGZ1bmMoYyk7XG4gICAgICB0aGlzLmNvbXBvbmVudHMuc2V0KGNsLm5hbWUsIHVwZGF0ZWRDb21wb25lbnQgYXMgSW5zdGFuY2VUeXBlPENUPik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBjVHlwZSBDbGFzcyBvZiBjb21wb25lbnQgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlID0gKGNUeXBlOiBDVCk6IHZvaWQgPT4ge1xuICAgIHRoaXMuY29tcG9uZW50cy5kZWxldGUoY1R5cGUubmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGNvbXBvbmVudCB0aGF0IG1hdGNoZXMgdGhlIHBhc3NlZCBjbGFzcy5cbiAgICogV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gY29tcG9uZW50XG4gICAqIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGNvbGxlY3Rpb24sIHNvIGlmIHlvdSBkb24ndCBrbm93IGlmIGl0J3Mgc2FmZVxuICAgKiB0byBnZXQgYSBjb21wb25lbnQsIHlvdSBzaG91bGQgdGVzdCB3aXRoIGhhcygpIG9yIGhhc0J5TmFtZSgpIGZpcnN0LlxuICAgKiBZb3UgaGF2ZSBiZWVuIHdhcm5lZC5cbiAgICogQHBhcmFtIGNsIGNvbXBvbmVudCBDbGFzcyByZWZlcmVuY2UuXG4gICAqL1xuICBnZXQgPSA8VD4oY2w6IENsYXNzPFQ+KTogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gPT4ge1xuICAgIGNvbnN0IGNvbXAgPSB0aGlzLmNvbXBvbmVudHMuZ2V0KGNsLm5hbWUpO1xuXG4gICAgaWYgKGlzQ29tcG9uZW50SW5zdGFuY2U8VD4oY2wsIGNvbXApKSB7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ29tcG9uZW50Q29sbGVjdGlvbiBkb2VzIG5vdCBoYXZlIGNvbXBvbmVudCBvZiB0eXBlICR7Y2wubmFtZX1gXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvLyBQb3NzaWJsZSBvdGhlciB3YXkgdG8gd3JpdGUgYSBnZXQgbWV0aG9kIHRoYXQgbWFpbnRhaW5zIHRoZSB0eXBlIG9mIHRoZVxuICAvLyBDb21wb25lbnQgdGhyb3VnaG91dC4gS2VlcGluZyBhcm91bmQgZm9yIG5vdyBhcmUgYSByZWZlcmVuY2UuXG4gIC8vIGdldDxVIGV4dGVuZHMgQ1Q+KGNvbXBDbGFzczogQ2xhc3M8VT4pOiBVIHtcbiAgLy8gICBpZiAoIXRoaXMuY29tcG9uZW50cy5oYXMoY29tcENsYXNzLm5hbWUpKSB7XG4gIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gIC8vICAgICAgIGBDb21wb25lbnRDb2xsZWN0aW9uIGRvZXMgbm90IGhhdmUgY29tcG9uZW50IG9mIHR5cGUgJHtjb21wQ2xhc3MubmFtZX1gXG4gIC8vICAgICApO1xuICAvLyAgIH1cblxuICAvLyAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuZ2V0KGNvbXBDbGFzcy5uYW1lKSEgYXMgdW5rbm93biBhcyBVO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIFRlc3QgdG8gc2VlIGlmIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5zIGEgc3BlY2lmaWMgQ2xhc3Mgb3IgQ2xhc3Nlcy5cbiAgICogQHBhcmFtIGNUeXBlIGNvbXBvbmVudCBDbGFzcywgb3IgYXJyYXkgb2YgY29tcG9uZW50IENsYXNzZXMuXG4gICAqL1xuICBoYXMgPSAoY1R5cGU6IENUIHwgQ1RbXSk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNUeXBlKVxuICAgICAgPyBjVHlwZS5ldmVyeSgoY3QpID0+IHRoaXMuY29tcG9uZW50cy5oYXMoY3QubmFtZSkgPT09IHRydWUpXG4gICAgICA6IHRoaXMuY29tcG9uZW50cy5oYXMoY1R5cGUubmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3QgdG8gc2VlIGlmIHRoZSBjb2xsZWN0aW9uIGhhcyBhIGNvbXBvbmVudCBpbnN0YW5jZSBiYXNlZCBvbiBhXG4gICAqIGNsYXNzIG5hbWUuIFNvbWUgYnVpbGQgc3RlcHMvbWluaWZpZXJzIHdpbGwgY2hhbmdlIHRoZSBuYW1lIG9mIENsYXNzZXMsXG4gICAqIHNvIGl0J3MgdXN1YWxseSBiZXN0IHRvIHBhc3MgaW4gYSBNeUNsYXNzLm5hbWUgaW5zdGVhZCBvZiAnTXlDbGFzcycuXG4gICAqIEBwYXJhbSBjTmFtZSBUaGUgbmFtZSBvZiBhIENsYXNzLCBvciBhcnJheSBvZiBDbGFzcyBuYW1lcy5cbiAgICovXG4gIGhhc0J5TmFtZSA9IChjTmFtZTogc3RyaW5nIHwgc3RyaW5nW10pOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjTmFtZSlcbiAgICAgID8gY05hbWUuZXZlcnkoY3QgPT4gdGhpcy5jb21wb25lbnRzLmhhcyhjdCkgPT09IHRydWUpXG4gICAgICA6IHRoaXMuY29tcG9uZW50cy5oYXMoY05hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbXBvbmVudCB0eXBlIG5hbWVzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyB1c2VkIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZ2V0IGNvbXBvbmVudFR5cGVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuY29tcG9uZW50cy5rZXlzKCldO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBudW1iZXIgb2YgY29tcG9uZW50cyB0aGF0IGFyZSBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIGdldCBzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5zaXplO1xuICB9XG5cbiAgdG9EZXZDb21wb25lbnRzKCk6IFJlY29yZDxzdHJpbmcsIEluc3RhbmNlVHlwZTxDVD4+IHtcbiAgICBjb25zdCBvYmo6IFJlY29yZDxzdHJpbmcsIEluc3RhbmNlVHlwZTxDVD4+ID0ge307XG4gICAgZm9yIChjb25zdCBbY29tcE5hbWUsIGNvbXBdIG9mIHRoaXMuY29tcG9uZW50cykge1xuICAgICAgb2JqW2NvbXBOYW1lXSA9IGNvbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxuIiwiaW1wb3J0IFdvcmxkLCB7IENsYXNzIH0gZnJvbSBcIi4vV29ybGRcIjtcbmltcG9ydCBFbnRpdHkgZnJvbSBcIi4vRW50aXR5XCI7XG5pbXBvcnQgeyBUYWcgfSBmcm9tIFwiLi9UYWdcIjtcblxuaW50ZXJmYWNlIERldkVudGl0eVRhYmxlUm93IHtcbiAgaWQ6IHN0cmluZztcbiAgY29tcG9uZW50czogc3RyaW5nO1xuICB0YWdzOiBzdHJpbmc7XG4gIHN5c3RlbXM6IHN0cmluZztcbn1cblxuY2xhc3MgRGV2RW50aXR5PENUIGV4dGVuZHMgQ2xhc3M8YW55Pj4ge1xuICBpZDogc3RyaW5nO1xuXG4gIGNvbXBvbmVudHM6IFJlY29yZDxzdHJpbmcsIEluc3RhbmNlVHlwZTxDVD4+O1xuXG4gIHRhZ3M6IFRhZ1tdO1xuXG4gIHN5c3RlbXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZW50aXR5OiBFbnRpdHk8Q1Q+LCB3b3JsZDogV29ybGQ8Q1Q+KSB7XG4gICAgdGhpcy5pZCA9IGVudGl0eS5pZDtcbiAgICB0aGlzLmNvbXBvbmVudHMgPSBlbnRpdHkuY29tcG9uZW50cy50b0RldkNvbXBvbmVudHMoKSxcbiAgICB0aGlzLnRhZ3MgPSBbLi4uZW50aXR5LnRhZ3NdO1xuXG4gICAgY29uc3QgY29tcE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRzKTtcblxuICAgIGZvciAoY29uc3QgW3N5c3RlbU5hbWUsIGNOYW1lc10gb2Ygd29ybGQuY29tcE5hbWVzQnlTeXN0ZW1OYW1lKSB7XG4gICAgICBpZiAoY05hbWVzLmV2ZXJ5KChjTmFtZSkgPT4gY29tcE5hbWVzLmluY2x1ZGVzKGNOYW1lKSkpIHtcbiAgICAgICAgdGhpcy5zeXN0ZW1zLnB1c2goc3lzdGVtTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdG9UYWJsZVJvdygpOiBEZXZFbnRpdHlUYWJsZVJvdyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgY29tcG9uZW50czogT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRzKS5qb2luKFwiLCBcIiksXG4gICAgICB0YWdzOiB0aGlzLnRhZ3Muam9pbihcIiwgXCIpLFxuICAgICAgc3lzdGVtczogdGhpcy5zeXN0ZW1zLmpvaW4oJywgJyksXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZXZFbnRpdHk7XG4iLCJpbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCBXb3JsZCBmcm9tICcuL1dvcmxkJztcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gJy4vQ29tcG9uZW50Q29sbGVjdGlvbic7XG5pbXBvcnQgeyBUYWcgfSBmcm9tICcuL1RhZyc7XG5pbXBvcnQgeyBDb21wVHlwZXMgfSBmcm9tICdpbnRlcmZhY2VzJztcbmltcG9ydCBEZXZFbnRpdHkgZnJvbSAnLi9EZXZFbnRpdHknO1xuXG5leHBvcnQgdHlwZSBFbnRpdHlJZCA9IHN0cmluZztcblxudHlwZSBDbGFzczxUPiA9IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQgfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50aXR5PENUIGV4dGVuZHMgQ2xhc3M8YW55Pj4ge1xuICBwcml2YXRlIF9pZDogc3RyaW5nO1xuICBwcml2YXRlIF93b3JsZDogV29ybGQ8Q1Q+O1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZDxDVD4pIHtcbiAgICB0aGlzLl9pZCA9IHV1aWR2NCgpO1xuICAgIHRoaXMuX3dvcmxkID0gd29ybGQ7XG5cbiAgICAvKlxuICAgIFJlZ2lzdGVyaW5nIHdpdGggdGhlIFdvcmxkLlxuICAgICovXG4gICAgdGhpcy5fd29ybGQucmVnaXN0ZXJFbnRpdHkodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgY29tcG9uZW50IHRvIGFuIEVudGl0eSwgZG9oLlxuICAgKi9cbiAgYWRkKGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPENUPik6IHRoaXMge1xuICAgIHRoaXMuX3dvcmxkLnNldCh0aGlzLl9pZCwgY29tcG9uZW50KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHRhZyB0byBhIGNvbXBvbmVudFxuICAgKi9cbiAgYWRkVGFnKHRhZzogVGFnKTogdGhpcyB7XG4gICAgY29uc3QgZW50aXR5U2V0ID0gdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuaGFzKHRhZylcbiAgICAgID8gdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZylcbiAgICAgIDogbmV3IFNldDxFbnRpdHlJZD4oKTtcblxuICAgIGlmIChlbnRpdHlTZXQpIHtcbiAgICAgIGVudGl0eVNldC5hZGQodGhpcy5faWQpO1xuICAgICAgdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3Muc2V0KHRhZywgZW50aXR5U2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGFuIGVudGl0eSBoYXMgYSBjb21wb25lbnQgcmVsYXRlZCB0byBpdC5cbiAgICovXG4gIGhhcyhjVHlwZTogQ1QpOiBib29sZWFuIHtcbiAgICBjb25zdCBjYyA9IHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICByZXR1cm4gY2MuaGFzKGNUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgYW4gZW50aXR5IHRhZ2dlZCB3aXRoIGEgZ2l2ZW4gdGFnLlxuICAgKi9cbiAgaGFzVGFnKHRhZzogVGFnKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmhhcyh0YWcpKSB7XG4gICAgICBjb25zdCBlbnRpdHlTZXQgPSB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5nZXQodGFnKTtcbiAgICAgIGlmIChlbnRpdHlTZXQpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eVNldC5oYXModGhpcy5faWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBjb21wb25lbnQgdGhhdCBiZWxvbmdzIHRvIGFuIGVudGl0eS5cbiAgICovXG4gIGdldDxUPihjbDogQ2xhc3M8VD4pOiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPiB7XG4gICAgY29uc3QgY2MgPSB0aGlzLl93b3JsZC5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQodGhpcy5faWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvblxuICAgKi9cbiAgZ2V0QWxsKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjb21wb25lbnQgZnJvbSBhbiBlbnRpdHkuXG4gICAqIEBwYXJhbSBjVHlwZSBBIGNvbXBvbmVudCBjbGFzcywgZWcgTXlDb21wb25lbnRcbiAgICovXG4gIHJlbW92ZShjVHlwZTogQ1QpOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5yZW1vdmUodGhpcy5faWQsIGNUeXBlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHRhZyBmcm9tIGFuIGVudGl0eVxuICAgKi9cbiAgcmVtb3ZlVGFnKHRhZzogVGFnKTogdGhpcyB7XG4gICAgaWYgKHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmhhcyh0YWcpKSB7XG4gICAgICBjb25zdCBlbnRpdHlTZXQgPSB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5nZXQodGFnKTtcbiAgICAgIFxuICAgICAgaWYgKGVudGl0eVNldCkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKHRoaXMuX2lkKTtcblxuICAgICAgICBpZiAoZW50aXR5U2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5kZWxldGUodGFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBDbGVhcnMgYWxsIGNvbXBvbmVudHMgZnJvbSBhbiBFbnRpdHkgKi9cbiAgY2xlYXIoKTogdGhpcyB7XG4gICAgdGhpcy5fd29ybGQuY2xlYXJFbnRpdHlDb21wb25lbnRzKHRoaXMuX2lkKTtcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0YWdzIG9uIGFuIGVudGl0eVxuICAgKi9cbiAgY2xlYXJUYWdzKCk6IHRoaXMge1xuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5lbnRyaWVzKCkpIHtcbiAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICBpZiAoZW50aXR5U2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3dvcmxkLmRlc3Ryb3lFbnRpdHkodGhpcy5faWQpO1xuICB9XG5cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG5cbiAgZ2V0IHdvcmxkKCk6IFdvcmxkPENUPiB7XG4gICAgcmV0dXJuIHRoaXMuX3dvcmxkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgY29tcG9uZW50cyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byBhbiBlbnRpdHksIHZpYSBhIENvbXBvbmVudENvbGxlY3Rpb24uXG4gICAqIERvZXMgdGhlIHNhbWUgdGhpbmcgYXMgZW50aXR5SW5zdGFuY2UuZ2V0QWxsKCkuXG4gICAqL1xuICBnZXQgY29tcG9uZW50cygpOiBDb21wb25lbnRDb2xsZWN0aW9uPENUPiB7XG4gICAgcmV0dXJuIHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGFsbCB0aGUgdGFncyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGlzIGVudGl0eS5cbiAgICovXG4gIGdldCB0YWdzKCk6IFNldDxUYWc+IHtcbiAgICBjb25zdCB0YWdzID0gbmV3IFNldDxUYWc+KCk7XG4gICAgZm9yIChjb25zdCBbdGFnLCBlbnRpdHlTZXRdIG9mIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGVudGl0eVNldC5oYXModGhpcy5faWQpKSB7XG4gICAgICAgIHRhZ3MuYWRkKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cblxuICB0b0RldkVudGl0eSgpOiBEZXZFbnRpdHk8Q1Q+IHtcbiAgICByZXR1cm4gbmV3IERldkVudGl0eTxDVD4odGhpcywgdGhpcy5fd29ybGQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbnRpdHk8Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PihcbiAgd29ybGQ6IFdvcmxkPENUPixcbik6IEVudGl0eTxDVD4ge1xuICBjb25zdCBlbnRpdHkgPSBuZXcgRW50aXR5PENUPih3b3JsZCk7XG5cbiAgcmV0dXJuIGVudGl0eTtcbn1cblxuXG4iLCJpbXBvcnQgV29ybGQgZnJvbSAnLi9Xb3JsZCc7XG5pbXBvcnQgRW50aXR5IGZyb20gJy4vRW50aXR5JztcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gJy4vQ29tcG9uZW50Q29sbGVjdGlvbic7XG5cbnR5cGUgQ2xhc3M8VD4gPSB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUIH07XG5cbmV4cG9ydCB0eXBlIFN5c3RlbSA9ICgpID0+IHZvaWQ7XG5cbi8qKlxuICogQXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZCBpbnRvIGEgU3lzdGVtIGZ1bmN0aW9uIG9uIGVhY2ggaXRlcmF0aW9uLlxuICogVGhpcyBpcyBob3cgeW91IGFjY2VzIHRoaW5ncyBsaWtlIHRoZSBlbnRpdHkgdGhhdCBwYXJ0aWN1bGFyIGVudGl0eSB0byBhY3Qgb24sXG4gKiBhcyB3ZWxsIGFzIHNvbWUgb3RoZXIgaGVscGZ1bCBwYXJhbXMgbGlrZSBpZiB0aGUgZW50aXR5IGlzIHRoZSBmaXJzdCBvciBsYXN0IGVudGl0eVxuICogaW4gdGhlIGdyb3VwIG9mIGVudGl0aWVzIHRoYXQgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeXN0ZW1GdW5jQXJnczxDVCBleHRlbmRzIENsYXNzPGFueT4+IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGVudGl0eSBiZWluZyBpdGVyYXRlZC5cbiAgICovXG4gIGVudGl0eTogRW50aXR5PENUPjtcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnRzIHRoYXQgYmVsb25nIHRvIHRoZSBlbnRpdHlcbiAgICovXG4gIGNvbXBvbmVudHM6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+O1xuICAvKipcbiAgICogVGhlIFdvcmxkIGluc3RhbmNlLlxuICAgKiBVc2UgdGhpcyB0byBhY2Nlc3Mgb3RoZXIgZW50aXRpZXMuXG4gICAqL1xuICB3b3JsZDogV29ybGQ8Q1Q+O1xuICBpbmRleDogbnVtYmVyO1xuICBzaXplOiBudW1iZXI7XG4gIC8qKlxuICAgKiBJcyB0aGUgZmlyc3QgZW50aXR5IHRvIGJlIGl0ZXJhdGVkIG9uIHRoaXMgcnVuIG9mIGEgc3lzdGVtLlxuICAgKiBIZWxwZnVsIGZvciBzZXR0aW5nIHVwIHN0YXRlIHRoYXQgaXMgdGhlIHNhbWUgZm9yIGFsbCBlbnRpdGllcyBvbmx5IG9uY2UuXG4gICAqL1xuICBpc0ZpcnN0OiBib29sZWFuO1xuICAvKipcbiAgICogSXMgdGhlIGxhc3QgZW50aXR5IHRvIGJlIGl0ZXJhdGVkIG9uIHRoaXMgcnVuIG9mIGEgc3lzdGVtLlxuICAgKiBDYW4gYmUgaGVscGZ1bCB0byB0ZWFyIGRvd24gYW55dGhpbmcgdGhhdCBzaG91bGQgYmUgZGVhbHQgd2l0aCBhZnRlciBhbGwgdGhlIGVudGl0ZXMgaGF2ZSByYW4uXG4gICAqL1xuICBpc0xhc3Q6IGJvb2xlYW47XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIHN5c3RlbSBpcyBydW4uXG4gKi9cbmV4cG9ydCB0eXBlIFN5c3RlbUZ1bmM8Q1QgZXh0ZW5kcyBDbGFzczxDVD4+ID0gKFxuICBzeXRlbUZ1bmNBcmdzOiBTeXN0ZW1GdW5jQXJnczxDVD4sXG4pID0+IHZvaWQ7XG5cbi8qKlxuICogVGhpcyBpcyBob3cgeW91IGNyZWF0ZSBhIFN5c3RlbS5cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNyZWF0ZVN5c3RlbSh3b3JsZCwgWydDb21wb25lbnRUeXBlJ10sICh7IGVudGl0eSB9KSA9PiAnRG8gZnVuIHN5c3RlbSB0aGluZ3MgaGVyZS4nKVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTeXN0ZW08Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PihcbiAgd29ybGQ6IFdvcmxkPENUPixcbiAgY1R5cGVzOiBDVFtdLFxuICBzeXN0ZW1GdW5jOiBTeXN0ZW1GdW5jPENUPixcbik6IFN5c3RlbSB7XG4gIGNvbnN0IGNOYW1lcyA9IGNUeXBlcy5tYXAoY3QgPT4gY3QubmFtZSk7XG4gIHdvcmxkLnJlZ2lzdGVyU3lzdGVtKGNOYW1lcywgc3lzdGVtRnVuYy5uYW1lKTtcblxuICByZXR1cm4gKCk6IHZvaWQgPT4ge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IHdvcmxkLmVudGl0aWVzQnlDVHlwZXMuc2l6ZTtcblxuICAgIC8vIFVzZWQgZm9yIG1hdGNoaW5nIHRoZSBhcnJheSBvZiBDb21wb25lbnRUeXBlcyB3aGljaCBpcyB0aGUga2V5XG4gICAgLy8gb2Ygd2hlcmUgdGhlIENvbXBvbmVudENvbGxlY3Rpb24gaXMsIHdpdGggdGhlIGFycmF5IG9mIENvbXBvbmVudFR5cGVzXG4gICAgLy8gdGhhdCBhcmUgcGFzc2VzLlxuICAgIC8vIE1pZ2h0IGJlIG5pY2UgaW4gdGhlIGZ1dHVyZSB0byBnbyBiYWNrIHRvIGEgcmVmIGNoZWNrIG9uIGNUeXBlcywgYnV0XG4gICAgLy8gZm9yIG5vdyB0aGlzIGRvZXNuJ3Qgc2VlbSB0byBiZSB0aGF0IG11Y2ggb2YgYSBwZXJmIGhpdC5cbiAgICAvLyBmb3IgKGNvbnN0IGN0IG9mIHdvcmxkLmVudGl0aWVzQnlDVHlwZXMua2V5cygpKSB7XG4gICAgLy8gICBpZiAoY1R5cGVzLmxlbmd0aCA9PT0gY3QubGVuZ3RoICYmIGNUeXBlcy5ldmVyeShjID0+IGN0LmluY2x1ZGVzKGMpKSkge1xuICAgIC8vICAgICBmb3IgKGNvbnN0IGVpZCBvZiB3b3JsZC5lbnRpdGllc0J5Q1R5cGVzLmdldChjVHlwZXMpKSB7XG4gICAgLy8gICAgICAgY29uc3QgYXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+ID0ge1xuICAgIC8vICAgICAgICAgZW50aXR5OiB3b3JsZC5lbnRpdGllcy5nZXQoZWlkKSxcbiAgICAvLyAgICAgICAgIGNvbXBvbmVudHM6IHdvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpLFxuICAgIC8vICAgICAgICAgd29ybGQsXG4gICAgLy8gICAgICAgICBpbmRleCxcbiAgICAvLyAgICAgICAgIHNpemUsXG4gICAgLy8gICAgICAgICBpc0ZpcnN0OiBpbmRleCA9PT0gMCxcbiAgICAvLyAgICAgICAgIGlzTGFzdDogaW5kZXggKyAxID09PSBzaXplLFxuICAgIC8vICAgICAgIH1cbiAgICBcbiAgICAvLyAgICAgICBzeXN0ZW1GdW5jKGFyZ3MpO1xuICAgIFxuICAgIC8vICAgICAgIGluZGV4ICs9IDE7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICBjb25zdCBjVHlwZUFycnMgPSB3b3JsZC5lbnRpdGllc0J5Q1R5cGVzLmdldChjTmFtZXMpIHx8IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3QgZWlkIG9mIGNUeXBlQXJycykge1xuICAgICAgY29uc3QgYXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+ID0ge1xuICAgICAgICBlbnRpdHk6IHdvcmxkLmVudGl0aWVzLmdldChlaWQpIHx8IG5ldyBFbnRpdHk8Q1Q+KHdvcmxkKSxcbiAgICAgICAgY29tcG9uZW50czogd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCksXG4gICAgICAgIHdvcmxkLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgaXNGaXJzdDogaW5kZXggPT09IDAsXG4gICAgICAgIGlzTGFzdDogaW5kZXggKyAxID09PSBzaXplLFxuICAgICAgfVxuXG4gICAgICBzeXN0ZW1GdW5jKGFyZ3MpO1xuXG4gICAgICBpbmRleCArPSAxO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IFdvcmxkLCB7IENsYXNzIH0gZnJvbSAnLi9Xb3JsZCc7XG5pbXBvcnQgRGV2RW50aXR5IGZyb20gJy4vRGV2RW50aXR5JztcblxuaW50ZXJmYWNlIERldlN5c3RlbUNvbXBzIHtcbiAgc3lzdGVtOiBzdHJpbmc7XG4gIGNvbXBvbmVudHM6IHN0cmluZztcbn1cblxuXG5jbGFzcyBEZXZUb29sczxDVCBleHRlbmRzIENsYXNzPGFueT4+IHtcbiAgd29ybGQ6IFdvcmxkPENUPjtcblxuICBjb25zdHJ1Y3Rvcih3b3JsZDogV29ybGQ8Q1Q+KSB7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICB9XG4gIC8qKlxuICAgKiBkaXNwbGF5IHRoZSBhbGwgc3lzdGVtcyBvZiB0aGUgd29ybGQsIGFuZCB0aGUgY29tcG9uZW50cyByZXF1aXJlZCBieSBlYWNoIHN5c3RlbS5cbiAgICogU3VwZXIgaGVscGZ1bCB0byB1c2Ugd2l0aCBjb25zb2xlLnRhYmxlKClcbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIGNvbnNvbGUudGFibGUod29ybGQuZGV2LnN5c3RlbUNvbXBvbmVudHMpO1xuICAgKiBgYGBcbiAgICovXG4gIGdldCBzeXN0ZW1Db21wb25lbnRzKCk6IERldlN5c3RlbUNvbXBzW10ge1xuICAgIGNvbnN0IGNvbXBzQnlTeXN0ZW1zID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtzeXN0ZW0sIGNvbXBOYW1lc10gb2YgdGhpcy53b3JsZC5jb21wTmFtZXNCeVN5c3RlbU5hbWUpIHtcbiAgICAgIGNvbXBzQnlTeXN0ZW1zLnB1c2goeyBzeXN0ZW0sIGNvbXBvbmVudHM6IGNvbXBOYW1lcy5qb2luKFwiLCBcIikgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBzQnlTeXN0ZW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhcnJheSBvZiBEZXZFbnRpdGVzLiBDYW4gYmUgdmVyeSBoZWxwZnVsIGZvciB0aGluZ3MgbGlrZSBpbnNwZWN0aW5nIGNvbXBvbmVudCBzdGF0ZSxcbiAgICogYW5kIHdoaWNoIHN5c3RlbXMgd2lsbCBiZSBjYWxsZWQgb24gYW4gZW50aXR5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMpO1xuICAgKlxuICAgKiAvLyBQcm8gdGlwISB0cnkgZGlzcGxheWluZyBhIHRhYmxlIG9mIGVudGl0aWVzIHdpdGggY29uc29sZS50YWJsZSBhbmQgRGV2RW50aXR5LnRvVGFibGVSb3coKS5cbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMubWFwKGRldkVudGl0eSA9PiBkZXZFbnRpdHkudG9UYWJsZVJvdygpKSk7XG4gICAqIGBgYFxuICAgKi9cblxuICBnZXQgZW50aXRpZXMoKTogRGV2RW50aXR5PENUPltdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMud29ybGQuZW50aXRpZXMudmFsdWVzKCldLm1hcCgoZSkgPT4gZS50b0RldkVudGl0eSgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZXZUb29scztcbiIsImltcG9ydCBFbnRpdHksIHsgRW50aXR5SWQgfSBmcm9tIFwiLi9FbnRpdHlcIjtcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gXCIuL0NvbXBvbmVudENvbGxlY3Rpb25cIjtcbmltcG9ydCB7IFRhZyB9IGZyb20gXCIuL1RhZ1wiO1xuaW1wb3J0IHsgY3JlYXRlU3lzdGVtLCBTeXN0ZW0sIFN5c3RlbUZ1bmMgfSBmcm9tIFwiLi9TeXN0ZW1cIjtcbmltcG9ydCBEZXZUb29scyBmcm9tIFwiLi9EZXZUb29sc1wiO1xuXG5leHBvcnQgdHlwZSBDbGFzczxUPiA9IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQgfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV29ybGQ8Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PiB7XG4gIGNvbXBvbmVudENvbGxlY3Rpb25zOiBNYXA8RW50aXR5SWQsIENvbXBvbmVudENvbGxlY3Rpb248Q1Q+PiA9IG5ldyBNYXAoKTtcblxuICBlbnRpdGllczogTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+PiA9IG5ldyBNYXAoKTtcblxuICBlbnRpdGllc0J5Q1R5cGVzOiBNYXA8c3RyaW5nW10sIFNldDxFbnRpdHlJZD4+ID0gbmV3IE1hcCgpO1xuXG4gIGVudGl0aWVzQnlUYWdzOiBNYXA8VGFnLCBTZXQ8RW50aXR5SWQ+PiA9IG5ldyBNYXAoKTtcblxuICBjb21wTmFtZXNCeVN5c3RlbU5hbWU6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPiA9IG5ldyBNYXAoKTtcblxuICBkZXY6IERldlRvb2xzPENUPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRldiA9IG5ldyBEZXZUb29scyh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcImZpbmRzXCIgYSBzaW5nbGUgZW50aXR5IGJhc2VkIG9uIGEgcHJlZGljYXRlXG4gICAqL1xuICBmaW5kID0gKHByZWRpY2F0ZTogKGVudGl0eTogRW50aXR5PENUPikgPT4gYm9vbGVhbik6IEVudGl0eTxDVD4gfCBudWxsID0+IHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogXCJmaW5kc1wiIGFsbCBlbnRpdGllcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSwga2luZGEgbGlrZSBmaWx0ZXIuXG4gICAqL1xuICBmaW5kQWxsID0gKHByZWRpY2F0ZTogKGVudGl0eTogRW50aXR5PENUPikgPT4gYm9vbGVhbik6IEVudGl0eTxDVD5bXSA9PiB7XG4gICAgY29uc3QgcmVzdWx0czogRW50aXR5PENUPltdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGVudGl0eSkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFwibG9jYXRlc1wiIGEgc2luZ2xlIGVudGl0eSBiYXNlZCBvbiBpdHMgQ29tcG9uZW50cy5cbiAgICovXG4gIGxvY2F0ZSA9IChjbDogQ1QgfCBDVFtdKTogRW50aXR5PENUPiB8IG51bGwgPT4ge1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiZW50aXR5P1wiLCBlbnRpdHkuY29tcG9uZW50cywgY2wubmFtZSk7XG4gICAgICBpZiAoZW50aXR5LmNvbXBvbmVudHMuaGFzKGNsKSkge1xuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2NhdGVzIGFsbCBlbnRpdGllcyB0aGF0IGNvbnRhaW4gdGhlIGNvbXBvbmVudHMgbmFtZWRcbiAgICovXG4gIGxvY2F0ZUFsbCA9IChjbDogQ1QgfCBDVFtdKTogRW50aXR5PENUPltdID0+IHtcbiAgICBjb25zdCByZXN1bHRzOiBFbnRpdHk8Q1Q+W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHkuY29tcG9uZW50cy5oYXMoY2wpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHcmFicyB0aGUgZmlyc3QgZW50aXR5LCBhbmQgaXRzIHJlbGF0ZWQgY29tcG9uZW50LCB0aGF0IG1hdGNoZXMgdGhlIGNvbXBvbmVudCB0eXBlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc3QgeyBlbnRpdHksIGNvbXBvbmVudCB9ID0gd29ybGQuZ3JhYihNeUNvbXBvbmVudCk7XG4gICAqIGBgYFxuICAgKi9cbiAgZ3JhYiA9IDxUPihcbiAgICBjbDogQ2xhc3M8VD5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gfSB8IG51bGwgPT4ge1xuICAgIC8vIGNvbnN0IGVudGl0eSA9IHRoaXMubG9jYXRlKChjbCBhcyB1bmtub3duKSBhcyBDVFtrZXlvZiBDVF0pO1xuICAgIGNvbnN0IGVudGl0eSA9IHRoaXMubG9jYXRlKChjbCBhcyB1bmtub3duKSBhcyBDVCk7XG5cbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBjb25zdCBjYyA9XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVudGl0eS5pZCkgfHxcbiAgICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNjLmdldDxUPihjbCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudGl0eSxcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR3JhYiBzaW5nbGUgY29tcG9uZW50IGJhc2VkIG9uIGNvbXBvbmVudCB0eXBlIGFuZCBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgeyBlbnRpdHksIGNvbXBvbmVudCB9ID0gd29ybGQuZ3JhYkJ5KEZpcnN0Q29tcG9uZW50LCAoY29tcCkgPT4gY29tcC5pZCA9PSAnYXdlc29tZScpXG4gICAqIGBgYFxuICAgKi9cbiAgZ3JhYkJ5ID0gPFQ+KFxuICAgIGNsOiBDbGFzczxUPixcbiAgICBwcmVkaWNhdGU6IChjb21wOiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPikgPT4gYm9vbGVhblxuICApOiB7IGVudGl0eTogRW50aXR5PENUPjsgY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPiB9IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgZW50aXRpZXMgPSB0aGlzLmxvY2F0ZUFsbCgoY2wgYXMgdW5rbm93bikgYXMgQ1QpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGNjID1cbiAgICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZW50aXR5LmlkKSB8fFxuICAgICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgICAgaWYgKHByZWRpY2F0ZShjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgIGVudGl0eSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR3JhYiBhbGwgdGhlIGNvbXBvbmVudHMgcHJpbWFyaWx5LCBhbmQgdGhlIGVudGl0aWVzIGlmIG5lZWRlZFxuICAgKi9cbiAgZ3JhYkFsbCA9IDxUPihcbiAgICBjbDogQ2xhc3M8VD5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gfVtdID0+IHtcbiAgICBjb25zdCBlbnRpdGllcyA9IHRoaXMubG9jYXRlQWxsKChjbCBhcyB1bmtub3duKSBhcyBDVCk7XG5cbiAgICByZXR1cm4gZW50aXRpZXMubWFwKChlbnRpdHkpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudGl0eSxcbiAgICAgICAgY29tcG9uZW50OiBlbnRpdHkuY29tcG9uZW50cy5nZXQ8VD4oY2wpLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYW4gZW50aXR5IGlkIGFuZCBjb21wb25lbnRUeXBlLCByZXR1cm5zIGNvbXBvbmVudFxuICAgKi9cbiAgZ2V0ID0gPFQ+KGVpZDogRW50aXR5SWQsIGNsOiBDbGFzczxUPik6IEluc3RhbmNlVHlwZTx0eXBlb2YgY2w+ID0+IHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgcmV0dXJuIGNjLmdldDxUPihjbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgYW5kIGdldCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQsIHdpdGhvdXQgYW55IGFzc29jaWF0ZWQgZW50aXRpZXMuXG4gICAqIEhlbHBmdWwgaXMgeW91IGtub3cgdGhhdCBvbmx5IG9uZSBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBleGlzdHMgYWNyb3NzIGFsbCBlbnRpdGllcy5cbiAgICogQHBhcmFtIGNsIENvbXBvbmVudCBDbGFzcyBDb250cnVjdG9yXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQSBkZWZhdWx0IGNvbXBvbmVudCBpbnN0YW5jZSBpZiBubyBjb21wb25lbnRzIGFyZSBmb3VuZC5cbiAgICovXG4gIGdldENvbXBvbmVudCA9IDxUPihcbiAgICBjbDogQ2xhc3M8VD4sXG4gICAgZGVmYXVsdFZhbHVlPzogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD5cbiAgKTogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gfCBudWxsID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdyYWIoY2wpO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgPyBkZWZhdWx0VmFsdWUgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuY29tcG9uZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gZW50aXR5IHRoYXQgaGFzIGJlZW4gdGFnZ2VkIHdpdGggdGhlIGdpdmVuIHRhZywgb3IgcmV0dXJuIG51bGw7XG4gICAqL1xuICBnZXRUYWdnZWQgPSAodGFnOiBUYWcpOiBFbnRpdHk8Q1Q+IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgdGFnRW50aXR5SWRzID0gdGhpcy5lbnRpdGllc0J5VGFncy5nZXQodGFnKTtcblxuICAgIGlmICh0YWdFbnRpdHlJZHMpIHtcbiAgICAgIGNvbnN0IGVudGl0eUlkID0gdGFnRW50aXR5SWRzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZW50aXR5SWQpO1xuXG4gICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHQgYWxsIGVudGl0aWVzIHRoYXQgaGF2ZSBiZWVuIHRhZ2dlZCB3aXRoIHRoZSBnaXZlbiB0YWcuXG4gICAqIEBwYXJhbSB0YWcgQSBzdHJpbmcgb3IgbnVtYmVyLlxuICAgKi9cbiAgZ2V0QWxsVGFnZ2VkID0gKHRhZzogVGFnKTogRW50aXR5PENUPltdID0+IHtcbiAgICBsZXQgZW50aXRpZXM6IEVudGl0eTxDVD5bXSA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjb25zdCB0YWdFbnRpdHlJZHMgPSB0aGlzLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgaWYgKHRhZ0VudGl0eUlkcykge1xuICAgICAgZm9yIChjb25zdCBlbnRpdHlJZCBvZiB0YWdFbnRpdHlJZHMpIHtcbiAgICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZW50aXR5SWQpO1xuICAgICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgICAgZW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudGl0aWVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBjb21wb25lbnQgb24gdGhlIGdpdmVuIGVudGl0eVxuICAgKi9cbiAgc2V0ID0gKGVpZDogRW50aXR5SWQsIGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPENUPik6IHRoaXMgPT4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICBjYy5hZGQoY29tcG9uZW50KTtcblxuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVpZCwgY2MpO1xuXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5hZGQoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29tcG9uZW50IGZyb20gdGhlIGdpdmVuIGVudGl0eS5cbiAgICogTk9URTogVGhpcyB3aWxsIGNoYW5nZSB3aGF0IHN5c3RlbXMgd2lsbCBiZSBjYWxsZWQgb24gdGhlIGVudGl0eS5cbiAgICovXG4gIHJlbW92ZSA9IChlaWQ6IEVudGl0eUlkLCBjVHlwZTogQ1QpOiB0aGlzID0+IHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgLy8gcmVtb3ZlIGVudGl0eSBmcm9tIGN1cnJlbnQgZW50aXRpZXNCeUNUeXBlc1xuICAgIGZvciAoY29uc3QgW2N0QXJyLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcykge1xuICAgICAgaWYgKChjdEFyciBhcyBzdHJpbmdbXSkuZXZlcnkoY2MuaGFzQnlOYW1lKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2MucmVtb3ZlKGNUeXBlKTtcblxuICAgIC8vIE1vdmUgZW50aXR5SWQgdG8gbmV3IENUeXBlcyBpZiBuZWVkZWQuXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5hZGQoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgaW4gc2V0dGluZyB1cCBhIG5ldyBzeXN0ZW0uXG4gICAqL1xuICByZWdpc3RlclN5c3RlbShjTmFtZXM6IHN0cmluZ1tdLCBzeXN0ZW1OYW1lOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLmNvbXBOYW1lc0J5U3lzdGVtTmFtZS5zZXQoc3lzdGVtTmFtZSwgWy4uLmNOYW1lc10pO1xuICAgIHRoaXMuZW50aXRpZXNCeUNUeXBlcy5zZXQoY05hbWVzLCBuZXcgU2V0PEVudGl0eUlkPigpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIGFuIGFsaWFzIGZvciBjcmVhdGVTeXN0ZW0oKS5cbiAgICovXG4gIGNyZWF0ZVN5c3RlbShjbDogQ1RbXSwgc3lzdGVtRnVuYzogU3lzdGVtRnVuYzxDVD4pOiBTeXN0ZW0ge1xuICAgIGNvbnN0IHN5c3RlbSA9IGNyZWF0ZVN5c3RlbTxDVD4odGhpcywgY2wsIHN5c3RlbUZ1bmMpO1xuXG4gICAgcmV0dXJuIHN5c3RlbTtcbiAgfVxuXG4gIHJlZ2lzdGVyRW50aXR5KGVudGl0eTogRW50aXR5PENUPik6IFdvcmxkPENUPiB7XG4gICAgY29uc3QgY2MgPSBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVudGl0eS5pZCwgY2MpO1xuICAgIHRoaXMuZW50aXRpZXMuc2V0KGVudGl0eS5pZCwgZW50aXR5KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgY29tcG9uZW50cyB0aGF0IGJlbG9uZyB0byBhbiBlbnRpdHkuXG4gICAqL1xuICBjbGVhckVudGl0eUNvbXBvbmVudHMoZWlkOiBFbnRpdHlJZCk6IHRoaXMge1xuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVpZCwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCkpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHlTZXQgb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZW50aXR5U2V0LmhhcyhlaWQpKSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZW50aXR5IHRoYXQgaXMgaW4gdGhlIHdvcmxkLlxuICAgKiBCYXNpY2FsbHkganVzdCBuZXcgRW50aXR5KHdvcmxkKSwgYnV0IHNhdmVzIGFuIGltcG9ydCBvZiBFbnRpdHkuXG4gICAqL1xuICBjcmVhdGVFbnRpdHkoKTogRW50aXR5PENUPiB7XG4gICAgY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eSh0aGlzKTtcblxuICAgIHJldHVybiBlbnRpdHk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgYW4gZW50aXR5LlxuICAgKiBTYW1lIGFzIGVudGl0eS5kZXN0cm95KCkuXG4gICAqL1xuICBkZXN0cm95RW50aXR5KGVpZDogRW50aXR5SWQpOiBXb3JsZDxDVD4ge1xuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZGVsZXRlKGVpZCk7XG4gICAgdGhpcy5lbnRpdGllcy5kZWxldGUoZWlkKTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5U2V0IG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVudGl0eVNldC5oYXMoZWlkKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFueSB0YWcgYXNzb2NpYXRpb25zIHdpdGggZGVzdHJveWVkIGVudGl0aWVzLlxuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLmVudGl0aWVzQnlUYWdzKSB7XG4gICAgICBpZiAoZW50aXR5U2V0LmhhcyhlaWQpKSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUoZWlkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVudGl0eVNldC5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsImltcG9ydCBXb3JsZCBmcm9tICcuL1dvcmxkJztcbmltcG9ydCB7IGNyZWF0ZUVudGl0eSB9IGZyb20gJy4vRW50aXR5JztcbmltcG9ydCB7IGNyZWF0ZVN5c3RlbSB9IGZyb20gJy4vU3lzdGVtJztcblxuZXhwb3J0IHtcbiAgV29ybGQsXG4gIGNyZWF0ZUVudGl0eSxcbiAgY3JlYXRlU3lzdGVtLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')}])}));