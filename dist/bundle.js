!function(Q,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("ecstatic",[],n):"object"==typeof exports?exports.ecstatic=n():Q.ecstatic=n()}(window,(function(){return function(Q){var n=window.webpackHotUpdateecstatic;window.webpackHotUpdateecstatic=function(Q,B){!function(Q,n){if(!V[Q]||!y[Q])return;for(var B in y[Q]=!1,n)Object.prototype.hasOwnProperty.call(n,B)&&(b[B]=n[B]);0==--G&&0===u&&r()}(Q,B),n&&n(Q,B)};var B,t=!0,e="da3e32675378f1eb8ab5",F={},i=[],I=[];function U(Q){var n=E[Q];if(!n)return N;var t=function(t){return n.hot.active?(E[t]?-1===E[t].parents.indexOf(Q)&&E[t].parents.push(Q):(i=[Q],B=t),-1===n.children.indexOf(t)&&n.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+Q),i=[]),N(t)},e=function(Q){return{configurable:!0,enumerable:!0,get:function(){return N[Q]},set:function(n){N[Q]=n}}};for(var F in N)Object.prototype.hasOwnProperty.call(N,F)&&"e"!==F&&"t"!==F&&Object.defineProperty(t,F,e(F));return t.e=function(Q){return"ready"===s&&g("prepare"),u++,N.e(Q).then(n,(function(Q){throw n(),Q}));function n(){u--,"prepare"===s&&(a[Q]||Z(Q),0===u&&0===G&&r())}},t.t=function(Q,n){return 1&n&&(Q=t(Q)),N.t(Q,-2&n)},t}function l(n){var t={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:B!==n,active:!0,accept:function(Q,n){if(void 0===Q)t._selfAccepted=!0;else if("function"==typeof Q)t._selfAccepted=Q;else if("object"==typeof Q)for(var B=0;B<Q.length;B++)t._acceptedDependencies[Q[B]]=n||function(){};else t._acceptedDependencies[Q]=n||function(){}},decline:function(Q){if(void 0===Q)t._selfDeclined=!0;else if("object"==typeof Q)for(var n=0;n<Q.length;n++)t._declinedDependencies[Q[n]]=!0;else t._declinedDependencies[Q]=!0},dispose:function(Q){t._disposeHandlers.push(Q)},addDisposeHandler:function(Q){t._disposeHandlers.push(Q)},removeDisposeHandler:function(Q){var n=t._disposeHandlers.indexOf(Q);n>=0&&t._disposeHandlers.splice(n,1)},invalidate:function(){switch(this._selfInvalidated=!0,s){case"idle":(b={})[n]=Q[n],g("ready");break;case"ready":L(n);break;case"prepare":case"check":case"dispose":case"apply":(o=o||[]).push(n)}},check:X,apply:p,status:function(Q){if(!Q)return s;c.push(Q)},addStatusHandler:function(Q){c.push(Q)},removeStatusHandler:function(Q){var n=c.indexOf(Q);n>=0&&c.splice(n,1)},data:F[n]};return B=void 0,t}var c=[],s="idle";function g(Q){s=Q;for(var n=0;n<c.length;n++)c[n].call(null,Q)}var d,b,C,o,G=0,u=0,a={},y={},V={};function x(Q){return+Q+""===Q?+Q:Q}function X(Q){if("idle"!==s)throw new Error("check() is only allowed in idle status");return t=Q,g("check"),(n=1e4,n=n||1e4,new Promise((function(Q,B){if("undefined"==typeof XMLHttpRequest)return B(new Error("No browser support"));try{var t=new XMLHttpRequest,e=N.p+"hot/hot-update.json";t.open("GET",e,!0),t.timeout=n,t.send(null)}catch(Q){return B(Q)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)B(new Error("Manifest request to "+e+" timed out."));else if(404===t.status)Q();else if(200!==t.status&&304!==t.status)B(new Error("Manifest request to "+e+" failed."));else{try{var n=JSON.parse(t.responseText)}catch(Q){return void B(Q)}Q(n)}}}))).then((function(Q){if(!Q)return g(R()?"ready":"idle"),null;y={},a={},V=Q.c,C=Q.h,g("prepare");var n=new Promise((function(Q,n){d={resolve:Q,reject:n}}));b={};return Z(0),"prepare"===s&&0===u&&0===G&&r(),n}));var n}function Z(Q){var n;V[Q]?(y[Q]=!0,G++,(n=document.createElement("script")).charset="utf-8",n.src=N.p+"hot/hot-update.js",document.head.appendChild(n)):a[Q]=!0}function r(){g("ready");var Q=d;if(d=null,Q)if(t)Promise.resolve().then((function(){return p(t)})).then((function(n){Q.resolve(n)}),(function(n){Q.reject(n)}));else{var n=[];for(var B in b)Object.prototype.hasOwnProperty.call(b,B)&&n.push(x(B));Q.resolve(n)}}function p(n){if("ready"!==s)throw new Error("apply() is only allowed in ready status");return function n(t){var I,U,l,c,s;function d(Q){for(var n=[Q],B={},t=n.map((function(Q){return{chain:[Q],id:Q}}));t.length>0;){var e=t.pop(),F=e.id,i=e.chain;if((c=E[F])&&(!c.hot._selfAccepted||c.hot._selfInvalidated)){if(c.hot._selfDeclined)return{type:"self-declined",chain:i,moduleId:F};if(c.hot._main)return{type:"unaccepted",chain:i,moduleId:F};for(var I=0;I<c.parents.length;I++){var U=c.parents[I],l=E[U];if(l){if(l.hot._declinedDependencies[F])return{type:"declined",chain:i.concat([U]),moduleId:F,parentId:U};-1===n.indexOf(U)&&(l.hot._acceptedDependencies[F]?(B[U]||(B[U]=[]),G(B[U],[F])):(delete B[U],n.push(U),t.push({chain:i.concat([U]),id:U})))}}}}return{type:"accepted",moduleId:Q,outdatedModules:n,outdatedDependencies:B}}function G(Q,n){for(var B=0;B<n.length;B++){var t=n[B];-1===Q.indexOf(t)&&Q.push(t)}}R();var u={},a=[],y={},X=function(){console.warn("[HMR] unexpected require("+r.moduleId+") to disposed module")};for(var Z in b)if(Object.prototype.hasOwnProperty.call(b,Z)){var r;s=x(Z),r=b[Z]?d(s):{type:"disposed",moduleId:Z};var p=!1,L=!1,m=!1,A="";switch(r.chain&&(A="\nUpdate propagation: "+r.chain.join(" -> ")),r.type){case"self-declined":t.onDeclined&&t.onDeclined(r),t.ignoreDeclined||(p=new Error("Aborted because of self decline: "+r.moduleId+A));break;case"declined":t.onDeclined&&t.onDeclined(r),t.ignoreDeclined||(p=new Error("Aborted because of declined dependency: "+r.moduleId+" in "+r.parentId+A));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(r),t.ignoreUnaccepted||(p=new Error("Aborted because "+s+" is not accepted"+A));break;case"accepted":t.onAccepted&&t.onAccepted(r),L=!0;break;case"disposed":t.onDisposed&&t.onDisposed(r),m=!0;break;default:throw new Error("Unexception type "+r.type)}if(p)return g("abort"),Promise.reject(p);if(L)for(s in y[s]=b[s],G(a,r.outdatedModules),r.outdatedDependencies)Object.prototype.hasOwnProperty.call(r.outdatedDependencies,s)&&(u[s]||(u[s]=[]),G(u[s],r.outdatedDependencies[s]));m&&(G(a,[r.moduleId]),y[s]=X)}var W,h=[];for(U=0;U<a.length;U++)s=a[U],E[s]&&E[s].hot._selfAccepted&&y[s]!==X&&!E[s].hot._selfInvalidated&&h.push({module:s,parents:E[s].parents.slice(),errorHandler:E[s].hot._selfAccepted});g("dispose"),Object.keys(V).forEach((function(Q){!1===V[Q]&&function(Q){delete installedChunks[Q]}(Q)}));var S,D,Y=a.slice();for(;Y.length>0;)if(s=Y.pop(),c=E[s]){var H={},v=c.hot._disposeHandlers;for(l=0;l<v.length;l++)(I=v[l])(H);for(F[s]=H,c.hot.active=!1,delete E[s],delete u[s],l=0;l<c.children.length;l++){var T=E[c.children[l]];T&&((W=T.parents.indexOf(s))>=0&&T.parents.splice(W,1))}}for(s in u)if(Object.prototype.hasOwnProperty.call(u,s)&&(c=E[s]))for(D=u[s],l=0;l<D.length;l++)S=D[l],(W=c.children.indexOf(S))>=0&&c.children.splice(W,1);g("apply"),void 0!==C&&(e=C,C=void 0);for(s in b=void 0,y)Object.prototype.hasOwnProperty.call(y,s)&&(Q[s]=y[s]);var z=null;for(s in u)if(Object.prototype.hasOwnProperty.call(u,s)&&(c=E[s])){D=u[s];var f=[];for(U=0;U<D.length;U++)if(S=D[U],I=c.hot._acceptedDependencies[S]){if(-1!==f.indexOf(I))continue;f.push(I)}for(U=0;U<f.length;U++){I=f[U];try{I(D)}catch(Q){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:s,dependencyId:D[U],error:Q}),t.ignoreErrored||z||(z=Q)}}}for(U=0;U<h.length;U++){var k=h[U];s=k.module,i=k.parents,B=s;try{N(s)}catch(Q){if("function"==typeof k.errorHandler)try{k.errorHandler(Q)}catch(n){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:s,error:n,originalError:Q}),t.ignoreErrored||z||(z=n),z||(z=Q)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:s,error:Q}),t.ignoreErrored||z||(z=Q)}}if(z)return g("fail"),Promise.reject(z);if(o)return n(t).then((function(Q){return a.forEach((function(n){Q.indexOf(n)<0&&Q.push(n)})),Q}));return g("idle"),new Promise((function(Q){Q(a)}))}(n=n||{})}function R(){if(o)return b||(b={}),o.forEach(L),o=void 0,!0}function L(n){Object.prototype.hasOwnProperty.call(b,n)||(b[n]=Q[n])}var E={};function N(n){if(E[n])return E[n].exports;var B=E[n]={i:n,l:!1,exports:{},hot:l(n),parents:(I=i,i=[],I),children:[]};return Q[n].call(B.exports,B,B.exports,U(n)),B.l=!0,B.exports}return N.m=Q,N.c=E,N.d=function(Q,n,B){N.o(Q,n)||Object.defineProperty(Q,n,{enumerable:!0,get:B})},N.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},N.t=function(Q,n){if(1&n&&(Q=N(Q)),8&n)return Q;if(4&n&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var B=Object.create(null);if(N.r(B),Object.defineProperty(B,"default",{enumerable:!0,value:Q}),2&n&&"string"!=typeof Q)for(var t in Q)N.d(B,t,function(n){return Q[n]}.bind(null,t));return B},N.n=function(Q){var n=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return N.d(n,"a",n),n},N.o=function(Q,n){return Object.prototype.hasOwnProperty.call(Q,n)},N.p="/static/",N.h=function(){return e},U(0)(N.s=0)}([function(Q,n,B){Q.exports=B(1)},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "World", function() { return /* reexport */ World_World; });\n__webpack_require__.d(__webpack_exports__, "createEntity", function() { return /* reexport */ createEntity; });\n__webpack_require__.d(__webpack_exports__, "createSystem", function() { return /* reexport */ createSystem; });\n\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== \'undefined\' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \'undefined\' && typeof msCrypto.getRandomValues === \'function\' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error(\'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js\n/* harmony default export */ var regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js\n\n\nfunction validate(uuid) {\n  return typeof uuid === \'string\' && regex.test(uuid);\n}\n\n/* harmony default export */ var esm_browser_validate = (validate);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var stringify_i = 0; stringify_i < 256; ++stringify_i) {\n  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It\'s been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \'-\' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \'-\' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \'-\' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \'-\' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it\'s likely due to one\n  // of the following:\n  // - One or more input array values don\'t map to a hex octet (leading to\n  // "undefined" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!esm_browser_validate(uuid)) {\n    throw TypeError(\'Stringified UUID is invalid\');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ var esm_browser_stringify = (stringify);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return esm_browser_stringify(rnds);\n}\n\n/* harmony default export */ var esm_browser_v4 = (v4);\n// CONCATENATED MODULE: ./src/guards.ts\n// export function classIsCompType(cl: any)\nfunction isComponentInstance(Class, comp) {\n  if (!comp) {\n    return false;\n  }\n\n  if (!(comp instanceof Class)) {\n    return false;\n  }\n\n  return true;\n}\nfunction isComponentName(possibleName, entitiesByCTypes) {\n  // string\n  if (typeof possibleName !== \'string\') {\n    return false;\n  }\n\n  for (const a of entitiesByCTypes.keys()) {\n    if (a.includes(possibleName)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n// CONCATENATED MODULE: ./src/ComponentCollection.ts\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n// CT is a Union, like `type = typeof FirstComponent | typeof SecondComponent`.\nclass ComponentCollection_ComponentCollection {\n  constructor() {\n    _defineProperty(this, "components", new Map());\n\n    _defineProperty(this, "add", component => {\n      this.components.set(component.constructor.name, component);\n    });\n\n    _defineProperty(this, "update", (cl, func) => {\n      const c = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, c)) {\n        const updatedComponent = func(c);\n        this.components.set(cl.name, updatedComponent);\n      }\n    });\n\n    _defineProperty(this, "remove", cType => {\n      this.components.delete(cType.name);\n    });\n\n    _defineProperty(this, "get", cl => {\n      const comp = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, comp)) {\n        return comp;\n      } else {\n        throw new Error(`ComponentCollection does not have component of type ${cl.name}`);\n      }\n    });\n\n    _defineProperty(this, "has", cType => {\n      return Array.isArray(cType) ? cType.every(ct => this.components.has(ct.name) === true) : this.components.has(cType.name);\n    });\n\n    _defineProperty(this, "hasByName", cName => {\n      return Array.isArray(cName) ? cName.every(ct => this.components.has(ct) === true) : this.components.has(cName);\n    });\n  }\n\n  /**\n   * Get the component type names that are currently being used in the collection.\n   */\n  get componentTypes() {\n    return [...this.components.keys()];\n  }\n  /**\n   * Get the current number of components that are in the collection.\n   */\n\n\n  get size() {\n    return this.components.size;\n  }\n\n}\n// CONCATENATED MODULE: ./src/Entity.ts\nfunction Entity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nclass Entity_Entity {\n  constructor(world) {\n    Entity_defineProperty(this, "_id", void 0);\n\n    Entity_defineProperty(this, "_world", void 0);\n\n    this._id = esm_browser_v4();\n    this._world = world;\n    /*\n    Registering with the World.\n    */\n\n    this._world.registerEntity(this);\n  }\n  /**\n   * Add a component to an Entity, doh.\n   */\n\n\n  add(component) {\n    this._world.set(this._id, component);\n\n    return this;\n  }\n  /**\n   * Add a tag to a component\n   */\n\n\n  addTag(tag) {\n    const entitySet = this._world.entitiesByTags.has(tag) ? this._world.entitiesByTags.get(tag) : new Set();\n\n    if (entitySet) {\n      entitySet.add(this._id);\n\n      this._world.entitiesByTags.set(tag, entitySet);\n    }\n\n    return this;\n  }\n  /**\n   * Determines if an entity has a component related to it.\n   */\n\n\n  has(cType) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    return cc.has(cType);\n  }\n  /**\n   * Check to see if an entity tagged with a given tag.\n   */\n\n\n  hasTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        return entitySet.has(this._id);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get a component that belongs to an entity.\n   */\n\n\n  get(cl) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    const component = cc.get(cl);\n    return component;\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection\n   */\n\n\n  getAll() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Remove a component from an entity.\n   * @param cType A component class, eg MyComponent\n   */\n\n\n  remove(cType) {\n    this._world.remove(this._id, cType);\n\n    return this;\n  }\n  /**\n   * Remove a tag from an entity\n   */\n\n\n  removeTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        entitySet.delete(this._id);\n\n        if (entitySet.size === 0) {\n          this._world.entitiesByTags.delete(tag);\n        }\n      }\n    }\n\n    return this;\n  }\n  /** Clears all components from an Entity */\n\n\n  clear() {\n    this._world.clearEntityComponents(this._id);\n\n    return this;\n  }\n  /**\n   * Remove all tags on an entity\n   */\n\n\n  clearTags() {\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      entitySet.delete(this._id);\n\n      if (entitySet.size === 0) {\n        this._world.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n  destroy() {\n    this._world.destroyEntity(this._id);\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get world() {\n    return this._world;\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection.\n   * Does the same thing as entityInstance.getAll().\n   */\n\n\n  get components() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Retrieves all the tags that have been added to this entity.\n   */\n\n\n  get tags() {\n    const tags = new Set();\n\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      if (entitySet.has(this._id)) {\n        tags.add(tag);\n      }\n    }\n\n    return tags;\n  }\n\n}\nfunction createEntity(world) {\n  const entity = new Entity_Entity(world);\n  return entity;\n}\n// CONCATENATED MODULE: ./src/System.ts\n\n\n\n/**\n * This is how you create a System.\n * @example\n * ```\n * createSystem(world, [\'ComponentType\'], ({ entity }) => \'Do fun system things here.\')\n * ```\n */\nfunction createSystem( // export function createSystem<CT extends CompTypes<CT>>(\nworld, // cTypes: CT[],\ncTypes, systemFunc) {\n  const cNames = cTypes.map(ct => ct.name);\n  world.registerSystem(cNames); // world.registerSystem(cTypes);\n\n  return () => {\n    let index = 0;\n    const size = world.entitiesByCTypes.size; // Used for matching the array of ComponentTypes which is the key\n    // of where the ComponentCollection is, with the array of ComponentTypes\n    // that are passes.\n    // Might be nice in the future to go back to a ref check on cTypes, but\n    // for now this doesn\'t seem to be that much of a perf hit.\n    // for (const ct of world.entitiesByCTypes.keys()) {\n    //   if (cTypes.length === ct.length && cTypes.every(c => ct.includes(c))) {\n    //     for (const eid of world.entitiesByCTypes.get(cTypes)) {\n    //       const args: SystemFuncArgs<CT> = {\n    //         entity: world.entities.get(eid),\n    //         components: world.componentCollections.get(eid),\n    //         world,\n    //         index,\n    //         size,\n    //         isFirst: index === 0,\n    //         isLast: index + 1 === size,\n    //       }\n    //       systemFunc(args);\n    //       index += 1;\n    //     }\n    //   }\n    // }\n\n    const cTypeArrs = world.entitiesByCTypes.get(cNames) || new Set();\n\n    for (const eid of cTypeArrs) {\n      const args = {\n        entity: world.entities.get(eid) || new Entity_Entity(world),\n        components: world.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(),\n        world,\n        index,\n        size,\n        isFirst: index === 0,\n        isLast: index + 1 === size\n      };\n      systemFunc(args);\n      index += 1;\n    }\n  };\n}\n// CONCATENATED MODULE: ./src/World.ts\nfunction World_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nclass World_World {\n  constructor() {\n    World_defineProperty(this, "componentCollections", new Map());\n\n    World_defineProperty(this, "entities", new Map());\n\n    World_defineProperty(this, "entitiesByCTypes", new Map());\n\n    World_defineProperty(this, "entitiesByTags", new Map());\n\n    World_defineProperty(this, "find", predicate => {\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "findAll", predicate => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "locate", cl => {\n      for (const entity of this.entities.values()) {\n        // console.log("entity?", entity.components, cl.name);\n        if (entity.components.has(cl)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "locateAll", cl => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "grab", cl => {\n      // const entity = this.locate((cl as unknown) as CT[keyof CT]);\n      const entity = this.locate(cl);\n\n      if (entity) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n        return {\n          entity,\n          component\n        };\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabBy", (cl, predicate) => {\n      const entities = this.locateAll(cl);\n\n      for (const entity of entities) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n\n        if (predicate(component)) {\n          return {\n            component,\n            entity\n          };\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabAll", cl => {\n      const entities = this.locateAll(cl);\n      return entities.map(entity => {\n        return {\n          entity,\n          component: entity.components.get(cl)\n        };\n      });\n    });\n\n    World_defineProperty(this, "get", (eid, cl) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      return cc.get(cl);\n    });\n\n    World_defineProperty(this, "getComponent", (cl, defaultValue) => {\n      const result = this.grab(cl);\n\n      if (!result) {\n        return defaultValue ? defaultValue : null;\n      }\n\n      return result.component;\n    });\n\n    World_defineProperty(this, "getTagged", tag => {\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        const entityId = tagEntityIds.values().next().value;\n        const entity = this.entities.get(entityId);\n\n        if (entity) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "getAllTagged", tag => {\n      let entities = []; // eslint-disable-line\n\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        for (const entityId of tagEntityIds) {\n          const entity = this.entities.get(entityId);\n\n          if (entity) {\n            entities.push(entity);\n          }\n        }\n      }\n\n      return entities;\n    });\n\n    World_defineProperty(this, "set", (eid, component) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      cc.add(component);\n      this.componentCollections.set(eid, cc);\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      return this;\n    });\n\n    World_defineProperty(this, "remove", (eid, cType) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(); // remove entity from current entitiesByCTypes\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.delete(eid);\n        }\n      }\n\n      cc.remove(cType); // Move entityId to new CTypes if needed.\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      return this;\n    });\n  }\n\n  /**\n   * Internal method used in setting up a new system.\n   */\n  registerSystem(cNames) {\n    this.entitiesByCTypes.set(cNames, new Set());\n    return this;\n  }\n  /**\n   * an alias for createSystem().\n   */\n\n\n  createSystem(cl, systemFunc) {\n    const system = createSystem(this, cl, systemFunc);\n    return system;\n  }\n\n  registerEntity(entity) {\n    const cc = new ComponentCollection_ComponentCollection();\n    this.componentCollections.set(entity.id, cc);\n    this.entities.set(entity.id, entity);\n    return this;\n  }\n  /**\n   * Remove all components that belong to an entity.\n   */\n\n\n  clearEntityComponents(eid) {\n    this.componentCollections.set(eid, new ComponentCollection_ComponentCollection());\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Create an entity that is in the world.\n   * Basically just new Entity(world), but saves an import of Entity.\n   */\n\n\n  createEntity() {\n    const entity = new Entity_Entity(this);\n    return entity;\n  }\n  /**\n   * Destroys an entity.\n   * Same as entity.destroy().\n   */\n\n\n  destroyEntity(eid) {\n    this.componentCollections.delete(eid);\n    this.entities.delete(eid);\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    } // remove any tag associations with destroyed entities.\n\n\n    for (const [tag, entitySet] of this.entitiesByTags) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n\n      if (entitySet.size === 0) {\n        this.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n}\n// CONCATENATED MODULE: ./src/index.ts\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY3N0YXRpYy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzP2Q4ZjgiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzPzQwZDYiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzA2ZTQiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3N0cmluZ2lmeS5qcz81OGNmIiwid2VicGFjazovL2Vjc3RhdGljLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz9lYzI2Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL2d1YXJkcy50cz8zYjU3Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL0NvbXBvbmVudENvbGxlY3Rpb24udHM/NTFjNCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9FbnRpdHkudHM/YWM2OCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9TeXN0ZW0udHM/MzI0OCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9Xb3JsZC50cz9jYzBiIiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL2luZGV4LnRzP2ZmYjQiXSwibmFtZXMiOlsiaXNDb21wb25lbnRJbnN0YW5jZSIsIkNsYXNzIiwiY29tcCIsImlzQ29tcG9uZW50TmFtZSIsInBvc3NpYmxlTmFtZSIsImVudGl0aWVzQnlDVHlwZXMiLCJhIiwia2V5cyIsImluY2x1ZGVzIiwiQ29tcG9uZW50Q29sbGVjdGlvbiIsIk1hcCIsImNvbXBvbmVudCIsImNvbXBvbmVudHMiLCJzZXQiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJjbCIsImZ1bmMiLCJjIiwiZ2V0IiwidXBkYXRlZENvbXBvbmVudCIsImNUeXBlIiwiZGVsZXRlIiwiRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsImN0IiwiaGFzIiwiY05hbWUiLCJjb21wb25lbnRUeXBlcyIsInNpemUiLCJFbnRpdHkiLCJ3b3JsZCIsIl9pZCIsInV1aWR2NCIsIl93b3JsZCIsInJlZ2lzdGVyRW50aXR5IiwiYWRkIiwiYWRkVGFnIiwidGFnIiwiZW50aXR5U2V0IiwiZW50aXRpZXNCeVRhZ3MiLCJTZXQiLCJjYyIsImNvbXBvbmVudENvbGxlY3Rpb25zIiwiaGFzVGFnIiwiZ2V0QWxsIiwicmVtb3ZlIiwicmVtb3ZlVGFnIiwiY2xlYXIiLCJjbGVhckVudGl0eUNvbXBvbmVudHMiLCJjbGVhclRhZ3MiLCJlbnRyaWVzIiwiZGVzdHJveSIsImRlc3Ryb3lFbnRpdHkiLCJpZCIsInRhZ3MiLCJjcmVhdGVFbnRpdHkiLCJlbnRpdHkiLCJjcmVhdGVTeXN0ZW0iLCJjVHlwZXMiLCJzeXN0ZW1GdW5jIiwiY05hbWVzIiwibWFwIiwicmVnaXN0ZXJTeXN0ZW0iLCJpbmRleCIsImNUeXBlQXJycyIsImVpZCIsImFyZ3MiLCJlbnRpdGllcyIsImlzRmlyc3QiLCJpc0xhc3QiLCJXb3JsZCIsInByZWRpY2F0ZSIsInZhbHVlcyIsInJlc3VsdHMiLCJwdXNoIiwibG9jYXRlIiwibG9jYXRlQWxsIiwiZGVmYXVsdFZhbHVlIiwicmVzdWx0IiwiZ3JhYiIsInRhZ0VudGl0eUlkcyIsImVudGl0eUlkIiwibmV4dCIsInZhbHVlIiwiY3RBcnIiLCJoYXNCeU5hbWUiLCJzeXN0ZW0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOztBQ2xCZSx3REFBYyxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxHQUFHLHlDQUF5QyxFOztBQ0FyRzs7QUFFL0I7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQzs7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MkI7QUFDdEMsU0FBS3ZCLG9CQUFMLENBQTBCdkIsTUFBMUIsQ0FBaUM4QyxHQUFqQztBQUNBLFNBQUtFLFFBQUwsQ0FBY2hELE1BQWQsQ0FBcUI4QyxHQUFyQjs7QUFFQSxTQUFLLE1BQU0zQixTQUFYLElBQXdCLEtBQUtwQyxnQkFBTCxDQUFzQnNFLE1BQXRCLEVBQXhCLEVBQXdEO0FBQ3RELFVBQUlsQyxTQUFTLENBQUNiLEdBQVYsQ0FBY3dDLEdBQWQsQ0FBSixFQUF3QjtBQUN0QjNCLGlCQUFTLENBQUNuQixNQUFWLENBQWlCOEMsR0FBakI7QUFDRDtBQUNGLEtBUnFDLENBVXRDOzs7QUFDQSxTQUFLLE1BQU0sQ0FBQzVCLEdBQUQsRUFBTUMsU0FBTixDQUFYLElBQStCLEtBQUtDLGNBQXBDLEVBQW9EO0FBQ2xELFVBQUlELFNBQVMsQ0FBQ2IsR0FBVixDQUFjd0MsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCM0IsaUJBQVMsQ0FBQ25CLE1BQVYsQ0FBaUI4QyxHQUFqQjtBQUNEOztBQUVELFVBQUkzQixTQUFTLENBQUNWLElBQVYsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsYUFBS1csY0FBTCxDQUFvQnBCLE1BQXBCLENBQTJCa0IsR0FBM0I7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNEOztBQWpWK0MsQzs7QUNQbEQ7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbnZhciBnZXRSYW5kb21WYWx1ZXM7XG52YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyIsImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG52YXIgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIpIHtcbiAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHZhciB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyIsImltcG9ydCBFbnRpdHksIHsgRW50aXR5SWQgfSBmcm9tIFwiLi9FbnRpdHlcIjtcbmltcG9ydCB7IENvbXBUeXBlcyB9IGZyb20gJ2ludGVyZmFjZXMnO1xuaW1wb3J0IENvbXBvbmVudENvbGxlY3Rpb24gZnJvbSAnLi9Db21wb25lbnRDb2xsZWN0aW9uJztcblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGNsYXNzSXNDb21wVHlwZShjbDogYW55KVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb21wb25lbnRJbnN0YW5jZTxUPihcbiAgQ2xhc3M6IG5ldyAoLi4uYXJnczogYW55KSA9PiBULFxuICBjb21wOiBhbnlcbik6IGNvbXAgaXMgSW5zdGFuY2VUeXBlPHR5cGVvZiBDbGFzcz4ge1xuICBpZiAoIWNvbXApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tcG9uZW50TmFtZTxDVCBleHRlbmRzIENvbXBUeXBlczxDVD4+KFxuICBwb3NzaWJsZU5hbWU6IGFueSxcbiAgZW50aXRpZXNCeUNUeXBlczogTWFwPChrZXlvZiBDVClbXSwgU2V0PEVudGl0eUlkPj5cbik6IHBvc3NpYmxlTmFtZSBpcyBDVFtrZXlvZiBDVF0ge1xuICAvLyBzdHJpbmdcbiAgaWYgKHR5cGVvZiBwb3NzaWJsZU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBhIG9mIGVudGl0aWVzQnlDVHlwZXMua2V5cygpKSB7XG4gICAgaWYgKGEuaW5jbHVkZXMocG9zc2libGVOYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgaXNDb21wb25lbnRJbnN0YW5jZSB9IGZyb20gXCIuL2d1YXJkc1wiO1xuXG50eXBlIENsYXNzPFQ+ID0geyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVCB9O1xuXG4vLyBDVCBpcyBhIFVuaW9uLCBsaWtlIGB0eXBlID0gdHlwZW9mIEZpcnN0Q29tcG9uZW50IHwgdHlwZW9mIFNlY29uZENvbXBvbmVudGAuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnRDb2xsZWN0aW9uPENUIGV4dGVuZHMgQ2xhc3M8YW55Pj4ge1xuICBjb21wb25lbnRzOiBNYXA8c3RyaW5nLCBJbnN0YW5jZVR5cGU8Q1Q+PiA9IG5ldyBNYXAoKTtcblxuICAvLyBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudFxuICAvLyBhZGQgPSAoY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8Q1Rba2V5b2YgQ1RdPik6IHZvaWQgPT4ge1xuICBhZGQgPSAoY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8Q1Q+KTogdm9pZCA9PiB7XG4gICAgdGhpcy5jb21wb25lbnRzLnNldChjb21wb25lbnQuY29uc3RydWN0b3IubmFtZSwgY29tcG9uZW50KTtcbiAgfTtcblxuICB1cGRhdGUgPSA8VD4oXG4gICAgY2w6IENsYXNzPFQ+LFxuICAgIGZ1bmM6IChjOiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPikgPT4gSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD5cbiAgKTogdm9pZCA9PiB7XG4gICAgY29uc3QgYyA9IHRoaXMuY29tcG9uZW50cy5nZXQoY2wubmFtZSk7XG5cbiAgICBpZiAoaXNDb21wb25lbnRJbnN0YW5jZShjbCwgYykpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRDb21wb25lbnQgPSBmdW5jKGMpO1xuICAgICAgdGhpcy5jb21wb25lbnRzLnNldChjbC5uYW1lLCB1cGRhdGVkQ29tcG9uZW50IGFzIEluc3RhbmNlVHlwZTxDVD4pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gY1R5cGUgQ2xhc3Mgb2YgY29tcG9uZW50IHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZSA9IChjVHlwZTogQ1QpOiB2b2lkID0+IHtcbiAgICB0aGlzLmNvbXBvbmVudHMuZGVsZXRlKGNUeXBlLm5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBjb21wb25lbnQgdGhhdCBtYXRjaGVzIHRoZSBwYXNzZWQgY2xhc3MuXG4gICAqIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGNvbXBvbmVudFxuICAgKiBkb2Vzbid0IGV4aXN0IGluIHRoZSBjb2xsZWN0aW9uLCBzbyBpZiB5b3UgZG9uJ3Qga25vdyBpZiBpdCdzIHNhZmVcbiAgICogdG8gZ2V0IGEgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHRlc3Qgd2l0aCBoYXMoKSBvciBoYXNCeU5hbWUoKSBmaXJzdC5cbiAgICogWW91IGhhdmUgYmVlbiB3YXJuZWQuXG4gICAqIEBwYXJhbSBjbCBjb21wb25lbnQgQ2xhc3MgcmVmZXJlbmNlLlxuICAgKi9cbiAgZ2V0ID0gPFQ+KGNsOiBDbGFzczxUPik6IEluc3RhbmNlVHlwZTx0eXBlb2YgY2w+ID0+IHtcbiAgICBjb25zdCBjb21wID0gdGhpcy5jb21wb25lbnRzLmdldChjbC5uYW1lKTtcblxuICAgIGlmIChpc0NvbXBvbmVudEluc3RhbmNlPFQ+KGNsLCBjb21wKSkge1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvbXBvbmVudENvbGxlY3Rpb24gZG9lcyBub3QgaGF2ZSBjb21wb25lbnQgb2YgdHlwZSAke2NsLm5hbWV9YFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUG9zc2libGUgb3RoZXIgd2F5IHRvIHdyaXRlIGEgZ2V0IG1ldGhvZCB0aGF0IG1haW50YWlucyB0aGUgdHlwZSBvZiB0aGVcbiAgLy8gQ29tcG9uZW50IHRocm91Z2hvdXQuIEtlZXBpbmcgYXJvdW5kIGZvciBub3cgYXJlIGEgcmVmZXJlbmNlLlxuICAvLyBnZXQ8VSBleHRlbmRzIENUPihjb21wQ2xhc3M6IENsYXNzPFU+KTogVSB7XG4gIC8vICAgaWYgKCF0aGlzLmNvbXBvbmVudHMuaGFzKGNvbXBDbGFzcy5uYW1lKSkge1xuICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAvLyAgICAgICBgQ29tcG9uZW50Q29sbGVjdGlvbiBkb2VzIG5vdCBoYXZlIGNvbXBvbmVudCBvZiB0eXBlICR7Y29tcENsYXNzLm5hbWV9YFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICByZXR1cm4gdGhpcy5jb21wb25lbnRzLmdldChjb21wQ2xhc3MubmFtZSkhIGFzIHVua25vd24gYXMgVTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBUZXN0IHRvIHNlZSBpZiB0aGUgY29sbGVjdGlvbiBjb250YWlucyBhIHNwZWNpZmljIENsYXNzIG9yIENsYXNzZXMuXG4gICAqIEBwYXJhbSBjVHlwZSBjb21wb25lbnQgQ2xhc3MsIG9yIGFycmF5IG9mIGNvbXBvbmVudCBDbGFzc2VzLlxuICAgKi9cbiAgaGFzID0gKGNUeXBlOiBDVCB8IENUW10pOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjVHlwZSlcbiAgICAgID8gY1R5cGUuZXZlcnkoKGN0KSA9PiB0aGlzLmNvbXBvbmVudHMuaGFzKGN0Lm5hbWUpID09PSB0cnVlKVxuICAgICAgOiB0aGlzLmNvbXBvbmVudHMuaGFzKGNUeXBlLm5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHRvIHNlZSBpZiB0aGUgY29sbGVjdGlvbiBoYXMgYSBjb21wb25lbnQgaW5zdGFuY2UgYmFzZWQgb24gYVxuICAgKiBjbGFzcyBuYW1lLiBTb21lIGJ1aWxkIHN0ZXBzL21pbmlmaWVycyB3aWxsIGNoYW5nZSB0aGUgbmFtZSBvZiBDbGFzc2VzLFxuICAgKiBzbyBpdCdzIHVzdWFsbHkgYmVzdCB0byBwYXNzIGluIGEgTXlDbGFzcy5uYW1lIGluc3RlYWQgb2YgJ015Q2xhc3MnLlxuICAgKiBAcGFyYW0gY05hbWUgVGhlIG5hbWUgb2YgYSBDbGFzcywgb3IgYXJyYXkgb2YgQ2xhc3MgbmFtZXMuXG4gICAqL1xuICBoYXNCeU5hbWUgPSAoY05hbWU6IHN0cmluZyB8IHN0cmluZ1tdKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY05hbWUpXG4gICAgICA/IGNOYW1lLmV2ZXJ5KGN0ID0+IHRoaXMuY29tcG9uZW50cy5oYXMoY3QpID09PSB0cnVlKVxuICAgICAgOiB0aGlzLmNvbXBvbmVudHMuaGFzKGNOYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb21wb25lbnQgdHlwZSBuYW1lcyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgdXNlZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIGdldCBjb21wb25lbnRUeXBlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmNvbXBvbmVudHMua2V5cygpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGNvbXBvbmVudHMgdGhhdCBhcmUgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqL1xuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuc2l6ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgV29ybGQgZnJvbSAnLi9Xb3JsZCc7XG5pbXBvcnQgQ29tcG9uZW50Q29sbGVjdGlvbiBmcm9tICcuL0NvbXBvbmVudENvbGxlY3Rpb24nO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSAnLi9UYWcnO1xuaW1wb3J0IHsgQ29tcFR5cGVzIH0gZnJvbSAnaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCB0eXBlIEVudGl0eUlkID0gc3RyaW5nO1xuXG50eXBlIENsYXNzPFQ+ID0geyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVCB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRpdHk8Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PiB7XG4gIHByaXZhdGUgX2lkOiBzdHJpbmc7XG4gIHByaXZhdGUgX3dvcmxkOiBXb3JsZDxDVD47XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMuX2lkID0gdXVpZHY0KCk7XG4gICAgdGhpcy5fd29ybGQgPSB3b3JsZDtcblxuICAgIC8qXG4gICAgUmVnaXN0ZXJpbmcgd2l0aCB0aGUgV29ybGQuXG4gICAgKi9cbiAgICB0aGlzLl93b3JsZC5yZWdpc3RlckVudGl0eSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBjb21wb25lbnQgdG8gYW4gRW50aXR5LCBkb2guXG4gICAqL1xuICBhZGQoY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8Q1Q+KTogdGhpcyB7XG4gICAgdGhpcy5fd29ybGQuc2V0KHRoaXMuX2lkLCBjb21wb25lbnQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgdGFnIHRvIGEgY29tcG9uZW50XG4gICAqL1xuICBhZGRUYWcodGFnOiBUYWcpOiB0aGlzIHtcbiAgICBjb25zdCBlbnRpdHlTZXQgPSB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5oYXModGFnKVxuICAgICAgPyB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5nZXQodGFnKVxuICAgICAgOiBuZXcgU2V0PEVudGl0eUlkPigpO1xuXG4gICAgaWYgKGVudGl0eVNldCkge1xuICAgICAgZW50aXR5U2V0LmFkZCh0aGlzLl9pZCk7XG4gICAgICB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5zZXQodGFnLCBlbnRpdHlTZXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYW4gZW50aXR5IGhhcyBhIGNvbXBvbmVudCByZWxhdGVkIHRvIGl0LlxuICAgKi9cbiAgaGFzKGNUeXBlOiBDVCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNjID0gdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIHJldHVybiBjYy5oYXMoY1R5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiBhbiBlbnRpdHkgdGFnZ2VkIHdpdGggYSBnaXZlbiB0YWcuXG4gICAqL1xuICBoYXNUYWcodGFnOiBUYWcpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuaGFzKHRhZykpIHtcbiAgICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuICAgICAgaWYgKGVudGl0eVNldCkge1xuICAgICAgICByZXR1cm4gZW50aXR5U2V0Lmhhcyh0aGlzLl9pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGNvbXBvbmVudCB0aGF0IGJlbG9uZ3MgdG8gYW4gZW50aXR5LlxuICAgKi9cbiAgZ2V0PFQ+KGNsOiBDbGFzczxUPik6IEluc3RhbmNlVHlwZTx0eXBlb2YgY2w+IHtcbiAgICBjb25zdCBjYyA9IHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICBjb25zdCBjb21wb25lbnQgPSBjYy5nZXQ8VD4oY2wpO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGNvbXBvbmVudHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gYW4gZW50aXR5LCB2aWEgYSBDb21wb25lbnRDb2xsZWN0aW9uXG4gICAqL1xuICBnZXRBbGwoKTogQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4ge1xuICAgIHJldHVybiB0aGlzLl93b3JsZC5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQodGhpcy5faWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNvbXBvbmVudCBmcm9tIGFuIGVudGl0eS5cbiAgICogQHBhcmFtIGNUeXBlIEEgY29tcG9uZW50IGNsYXNzLCBlZyBNeUNvbXBvbmVudFxuICAgKi9cbiAgcmVtb3ZlKGNUeXBlOiBDVCk6IHRoaXMge1xuICAgIHRoaXMuX3dvcmxkLnJlbW92ZSh0aGlzLl9pZCwgY1R5cGUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdGFnIGZyb20gYW4gZW50aXR5XG4gICAqL1xuICByZW1vdmVUYWcodGFnOiBUYWcpOiB0aGlzIHtcbiAgICBpZiAodGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuaGFzKHRhZykpIHtcbiAgICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuICAgICAgXG4gICAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICAgIGlmIChlbnRpdHlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENsZWFycyBhbGwgY29tcG9uZW50cyBmcm9tIGFuIEVudGl0eSAqL1xuICBjbGVhcigpOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5jbGVhckVudGl0eUNvbXBvbmVudHModGhpcy5faWQpO1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHRhZ3Mgb24gYW4gZW50aXR5XG4gICAqL1xuICBjbGVhclRhZ3MoKTogdGhpcyB7XG4gICAgZm9yIChjb25zdCBbdGFnLCBlbnRpdHlTZXRdIG9mIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmVudHJpZXMoKSkge1xuICAgICAgZW50aXR5U2V0LmRlbGV0ZSh0aGlzLl9pZCk7XG5cbiAgICAgIGlmIChlbnRpdHlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5kZWxldGUodGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fd29ybGQuZGVzdHJveUVudGl0eSh0aGlzLl9pZCk7XG4gIH1cblxuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cblxuICBnZXQgd29ybGQoKTogV29ybGQ8Q1Q+IHtcbiAgICByZXR1cm4gdGhpcy5fd29ybGQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvbi5cbiAgICogRG9lcyB0aGUgc2FtZSB0aGluZyBhcyBlbnRpdHlJbnN0YW5jZS5nZXRBbGwoKS5cbiAgICovXG4gIGdldCBjb21wb25lbnRzKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYWxsIHRoZSB0YWdzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoaXMgZW50aXR5LlxuICAgKi9cbiAgZ2V0IHRhZ3MoKTogU2V0PFRhZz4ge1xuICAgIGNvbnN0IHRhZ3MgPSBuZXcgU2V0PFRhZz4oKTtcbiAgICBmb3IgKGNvbnN0IFt0YWcsIGVudGl0eVNldF0gb2YgdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZW50cmllcygpKSB7XG4gICAgICBpZiAoZW50aXR5U2V0Lmhhcyh0aGlzLl9pZCkpIHtcbiAgICAgICAgdGFncy5hZGQodGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFncztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW50aXR5PENUIGV4dGVuZHMgQ2xhc3M8YW55Pj4oXG4gIHdvcmxkOiBXb3JsZDxDVD4sXG4pOiBFbnRpdHk8Q1Q+IHtcbiAgY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eTxDVD4od29ybGQpO1xuXG4gIHJldHVybiBlbnRpdHk7XG59XG5cblxuIiwiaW1wb3J0IFdvcmxkIGZyb20gJy4vV29ybGQnO1xuaW1wb3J0IEVudGl0eSBmcm9tICcuL0VudGl0eSc7XG5pbXBvcnQgQ29tcG9uZW50Q29sbGVjdGlvbiBmcm9tICcuL0NvbXBvbmVudENvbGxlY3Rpb24nO1xuXG50eXBlIENsYXNzPFQ+ID0geyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVCB9O1xuXG5leHBvcnQgdHlwZSBTeXN0ZW0gPSAoKSA9PiB2b2lkO1xuXG4vKipcbiAqIEFyZ3VtZW50cyB0aGF0IGFyZSBwYXNzZWQgaW50byBhIFN5c3RlbSBmdW5jdGlvbiBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAqIFRoaXMgaXMgaG93IHlvdSBhY2NlcyB0aGluZ3MgbGlrZSB0aGUgZW50aXR5IHRoYXQgcGFydGljdWxhciBlbnRpdHkgdG8gYWN0IG9uLFxuICogYXMgd2VsbCBhcyBzb21lIG90aGVyIGhlbHBmdWwgcGFyYW1zIGxpa2UgaWYgdGhlIGVudGl0eSBpcyB0aGUgZmlyc3Qgb3IgbGFzdCBlbnRpdHlcbiAqIGluIHRoZSBncm91cCBvZiBlbnRpdGllcyB0aGF0IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3lzdGVtRnVuY0FyZ3M8Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PiB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBlbnRpdHkgYmVpbmcgaXRlcmF0ZWQuXG4gICAqL1xuICBlbnRpdHk6IEVudGl0eTxDVD47XG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB0aGF0IGJlbG9uZyB0byB0aGUgZW50aXR5XG4gICAqL1xuICBjb21wb25lbnRzOiBDb21wb25lbnRDb2xsZWN0aW9uPENUPjtcbiAgLyoqXG4gICAqIFRoZSBXb3JsZCBpbnN0YW5jZS5cbiAgICogVXNlIHRoaXMgdG8gYWNjZXNzIG90aGVyIGVudGl0aWVzLlxuICAgKi9cbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICAvKipcbiAgICogSXMgdGhlIGZpcnN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogSGVscGZ1bCBmb3Igc2V0dGluZyB1cCBzdGF0ZSB0aGF0IGlzIHRoZSBzYW1lIGZvciBhbGwgZW50aXRpZXMgb25seSBvbmNlLlxuICAgKi9cbiAgaXNGaXJzdDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIElzIHRoZSBsYXN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogQ2FuIGJlIGhlbHBmdWwgdG8gdGVhciBkb3duIGFueXRoaW5nIHRoYXQgc2hvdWxkIGJlIGRlYWx0IHdpdGggYWZ0ZXIgYWxsIHRoZSBlbnRpdGVzIGhhdmUgcmFuLlxuICAgKi9cbiAgaXNMYXN0OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBzeXN0ZW0gaXMgcnVuLlxuICovXG5leHBvcnQgdHlwZSBTeXN0ZW1GdW5jPENUIGV4dGVuZHMgQ2xhc3M8Q1Q+PiA9IChcbiAgc3l0ZW1GdW5jQXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+LFxuKSA9PiB2b2lkO1xuXG4vKipcbiAqIFRoaXMgaXMgaG93IHlvdSBjcmVhdGUgYSBTeXN0ZW0uXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjcmVhdGVTeXN0ZW0od29ybGQsIFsnQ29tcG9uZW50VHlwZSddLCAoeyBlbnRpdHkgfSkgPT4gJ0RvIGZ1biBzeXN0ZW0gdGhpbmdzIGhlcmUuJylcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3lzdGVtPENUIGV4dGVuZHMgQ2xhc3M8YW55Pj4oXG4vLyBleHBvcnQgZnVuY3Rpb24gY3JlYXRlU3lzdGVtPENUIGV4dGVuZHMgQ29tcFR5cGVzPENUPj4oXG4gIHdvcmxkOiBXb3JsZDxDVD4sXG4gIC8vIGNUeXBlczogQ1RbXSxcbiAgY1R5cGVzOiBDVFtdLFxuICBzeXN0ZW1GdW5jOiBTeXN0ZW1GdW5jPENUPlxuKTogU3lzdGVtIHtcbiAgY29uc3QgY05hbWVzID0gY1R5cGVzLm1hcChjdCA9PiBjdC5uYW1lKTtcbiAgd29ybGQucmVnaXN0ZXJTeXN0ZW0oY05hbWVzKTtcbiAgLy8gd29ybGQucmVnaXN0ZXJTeXN0ZW0oY1R5cGVzKTtcblxuICByZXR1cm4gKCk6IHZvaWQgPT4ge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IHdvcmxkLmVudGl0aWVzQnlDVHlwZXMuc2l6ZTtcblxuICAgIC8vIFVzZWQgZm9yIG1hdGNoaW5nIHRoZSBhcnJheSBvZiBDb21wb25lbnRUeXBlcyB3aGljaCBpcyB0aGUga2V5XG4gICAgLy8gb2Ygd2hlcmUgdGhlIENvbXBvbmVudENvbGxlY3Rpb24gaXMsIHdpdGggdGhlIGFycmF5IG9mIENvbXBvbmVudFR5cGVzXG4gICAgLy8gdGhhdCBhcmUgcGFzc2VzLlxuICAgIC8vIE1pZ2h0IGJlIG5pY2UgaW4gdGhlIGZ1dHVyZSB0byBnbyBiYWNrIHRvIGEgcmVmIGNoZWNrIG9uIGNUeXBlcywgYnV0XG4gICAgLy8gZm9yIG5vdyB0aGlzIGRvZXNuJ3Qgc2VlbSB0byBiZSB0aGF0IG11Y2ggb2YgYSBwZXJmIGhpdC5cbiAgICAvLyBmb3IgKGNvbnN0IGN0IG9mIHdvcmxkLmVudGl0aWVzQnlDVHlwZXMua2V5cygpKSB7XG4gICAgLy8gICBpZiAoY1R5cGVzLmxlbmd0aCA9PT0gY3QubGVuZ3RoICYmIGNUeXBlcy5ldmVyeShjID0+IGN0LmluY2x1ZGVzKGMpKSkge1xuICAgIC8vICAgICBmb3IgKGNvbnN0IGVpZCBvZiB3b3JsZC5lbnRpdGllc0J5Q1R5cGVzLmdldChjVHlwZXMpKSB7XG4gICAgLy8gICAgICAgY29uc3QgYXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+ID0ge1xuICAgIC8vICAgICAgICAgZW50aXR5OiB3b3JsZC5lbnRpdGllcy5nZXQoZWlkKSxcbiAgICAvLyAgICAgICAgIGNvbXBvbmVudHM6IHdvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpLFxuICAgIC8vICAgICAgICAgd29ybGQsXG4gICAgLy8gICAgICAgICBpbmRleCxcbiAgICAvLyAgICAgICAgIHNpemUsXG4gICAgLy8gICAgICAgICBpc0ZpcnN0OiBpbmRleCA9PT0gMCxcbiAgICAvLyAgICAgICAgIGlzTGFzdDogaW5kZXggKyAxID09PSBzaXplLFxuICAgIC8vICAgICAgIH1cbiAgICBcbiAgICAvLyAgICAgICBzeXN0ZW1GdW5jKGFyZ3MpO1xuICAgIFxuICAgIC8vICAgICAgIGluZGV4ICs9IDE7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICBjb25zdCBjVHlwZUFycnMgPSB3b3JsZC5lbnRpdGllc0J5Q1R5cGVzLmdldChjTmFtZXMpIHx8IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3QgZWlkIG9mIGNUeXBlQXJycykge1xuICAgICAgY29uc3QgYXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+ID0ge1xuICAgICAgICBlbnRpdHk6IHdvcmxkLmVudGl0aWVzLmdldChlaWQpIHx8IG5ldyBFbnRpdHk8Q1Q+KHdvcmxkKSxcbiAgICAgICAgY29tcG9uZW50czogd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCksXG4gICAgICAgIHdvcmxkLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgaXNGaXJzdDogaW5kZXggPT09IDAsXG4gICAgICAgIGlzTGFzdDogaW5kZXggKyAxID09PSBzaXplLFxuICAgICAgfVxuXG4gICAgICBzeXN0ZW1GdW5jKGFyZ3MpO1xuXG4gICAgICBpbmRleCArPSAxO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IEVudGl0eSwgeyBFbnRpdHlJZCB9IGZyb20gXCIuL0VudGl0eVwiO1xuaW1wb3J0IENvbXBvbmVudENvbGxlY3Rpb24gZnJvbSBcIi4vQ29tcG9uZW50Q29sbGVjdGlvblwiO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSBcIi4vVGFnXCI7XG5pbXBvcnQgeyBjcmVhdGVTeXN0ZW0sIFN5c3RlbSwgU3lzdGVtRnVuYyB9IGZyb20gXCIuL1N5c3RlbVwiO1xuXG50eXBlIENsYXNzPFQ+ID0geyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVCB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JsZDxDVCBleHRlbmRzIENsYXNzPGFueT4+IHtcbiAgY29tcG9uZW50Q29sbGVjdGlvbnM6IE1hcDxFbnRpdHlJZCwgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4+ID0gbmV3IE1hcCgpO1xuXG4gIGVudGl0aWVzOiBNYXA8RW50aXR5SWQsIEVudGl0eTxDVD4+ID0gbmV3IE1hcCgpO1xuXG4gIGVudGl0aWVzQnlDVHlwZXM6IE1hcDxzdHJpbmdbXSwgU2V0PEVudGl0eUlkPj4gPSBuZXcgTWFwKCk7XG5cbiAgZW50aXRpZXNCeVRhZ3M6IE1hcDxUYWcsIFNldDxFbnRpdHlJZD4+ID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBcImZpbmRzXCIgYSBzaW5nbGUgZW50aXR5IGJhc2VkIG9uIGEgcHJlZGljYXRlXG4gICAqL1xuICBmaW5kID0gKHByZWRpY2F0ZTogKGVudGl0eTogRW50aXR5PENUPikgPT4gYm9vbGVhbik6IEVudGl0eTxDVD4gfCBudWxsID0+IHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogXCJmaW5kc1wiIGFsbCBlbnRpdGllcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSwga2luZGEgbGlrZSBmaWx0ZXIuXG4gICAqL1xuICBmaW5kQWxsID0gKHByZWRpY2F0ZTogKGVudGl0eTogRW50aXR5PENUPikgPT4gYm9vbGVhbik6IEVudGl0eTxDVD5bXSA9PiB7XG4gICAgY29uc3QgcmVzdWx0czogRW50aXR5PENUPltdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGVudGl0eSkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFwibG9jYXRlc1wiIGEgc2luZ2xlIGVudGl0eSBiYXNlZCBvbiBpdHMgQ29tcG9uZW50cy5cbiAgICovXG4gIGxvY2F0ZSA9IChjbDogQ1QgfCBDVFtdKTogRW50aXR5PENUPiB8IG51bGwgPT4ge1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiZW50aXR5P1wiLCBlbnRpdHkuY29tcG9uZW50cywgY2wubmFtZSk7XG4gICAgICBpZiAoZW50aXR5LmNvbXBvbmVudHMuaGFzKGNsKSkge1xuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2NhdGVzIGFsbCBlbnRpdGllcyB0aGF0IGNvbnRhaW4gdGhlIGNvbXBvbmVudHMgbmFtZWRcbiAgICovXG4gIGxvY2F0ZUFsbCA9IChjbDogQ1QgfCBDVFtdKTogRW50aXR5PENUPltdID0+IHtcbiAgICBjb25zdCByZXN1bHRzOiBFbnRpdHk8Q1Q+W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHkuY29tcG9uZW50cy5oYXMoY2wpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHcmFicyB0aGUgZmlyc3QgZW50aXR5LCBhbmQgaXRzIHJlbGF0ZWQgY29tcG9uZW50LCB0aGF0IG1hdGNoZXMgdGhlIGNvbXBvbmVudCB0eXBlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc3QgeyBlbnRpdHksIGNvbXBvbmVudCB9ID0gd29ybGQuZ3JhYihNeUNvbXBvbmVudCk7XG4gICAqIGBgYFxuICAgKi9cbiAgZ3JhYiA9IDxUPihcbiAgICBjbDogQ2xhc3M8VD5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gfSB8IG51bGwgPT4ge1xuICAgIC8vIGNvbnN0IGVudGl0eSA9IHRoaXMubG9jYXRlKChjbCBhcyB1bmtub3duKSBhcyBDVFtrZXlvZiBDVF0pO1xuICAgIGNvbnN0IGVudGl0eSA9IHRoaXMubG9jYXRlKChjbCBhcyB1bmtub3duKSBhcyBDVCk7XG5cbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBjb25zdCBjYyA9XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVudGl0eS5pZCkgfHxcbiAgICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNjLmdldDxUPihjbCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudGl0eSxcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR3JhYiBzaW5nbGUgY29tcG9uZW50IGJhc2VkIG9uIGNvbXBvbmVudCB0eXBlIGFuZCBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgeyBlbnRpdHksIGNvbXBvbmVudCB9ID0gd29ybGQuZ3JhYkJ5KEZpcnN0Q29tcG9uZW50LCAoY29tcCkgPT4gY29tcC5pZCA9PSAnYXdlc29tZScpXG4gICAqIGBgYFxuICAgKi9cbiAgZ3JhYkJ5ID0gPFQ+KFxuICAgIGNsOiBDbGFzczxUPixcbiAgICBwcmVkaWNhdGU6IChjb21wOiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPikgPT4gYm9vbGVhblxuICApOiB7IGVudGl0eTogRW50aXR5PENUPjsgY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPiB9IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgZW50aXRpZXMgPSB0aGlzLmxvY2F0ZUFsbCgoY2wgYXMgdW5rbm93bikgYXMgQ1QpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGNjID1cbiAgICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZW50aXR5LmlkKSB8fFxuICAgICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgICAgaWYgKHByZWRpY2F0ZShjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgIGVudGl0eSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR3JhYiBhbGwgdGhlIGNvbXBvbmVudHMgcHJpbWFyaWx5LCBhbmQgdGhlIGVudGl0aWVzIGlmIG5lZWRlZFxuICAgKi9cbiAgZ3JhYkFsbCA9IDxUPihcbiAgICBjbDogQ2xhc3M8VD5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gfVtdID0+IHtcbiAgICBjb25zdCBlbnRpdGllcyA9IHRoaXMubG9jYXRlQWxsKChjbCBhcyB1bmtub3duKSBhcyBDVCk7XG5cbiAgICByZXR1cm4gZW50aXRpZXMubWFwKChlbnRpdHkpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudGl0eSxcbiAgICAgICAgY29tcG9uZW50OiBlbnRpdHkuY29tcG9uZW50cy5nZXQ8VD4oY2wpLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYW4gZW50aXR5IGlkIGFuZCBjb21wb25lbnRUeXBlLCByZXR1cm5zIGNvbXBvbmVudFxuICAgKi9cbiAgZ2V0ID0gPFQ+KGVpZDogRW50aXR5SWQsIGNsOiBDbGFzczxUPik6IEluc3RhbmNlVHlwZTx0eXBlb2YgY2w+ID0+IHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgcmV0dXJuIGNjLmdldDxUPihjbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgYW5kIGdldCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQsIHdpdGhvdXQgYW55IGFzc29jaWF0ZWQgZW50aXRpZXMuXG4gICAqIEhlbHBmdWwgaXMgeW91IGtub3cgdGhhdCBvbmx5IG9uZSBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBleGlzdHMgYWNyb3NzIGFsbCBlbnRpdGllcy5cbiAgICogQHBhcmFtIGNsIENvbXBvbmVudCBDbGFzcyBDb250cnVjdG9yXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQSBkZWZhdWx0IGNvbXBvbmVudCBpbnN0YW5jZSBpZiBubyBjb21wb25lbnRzIGFyZSBmb3VuZC5cbiAgICovXG4gIGdldENvbXBvbmVudCA9IDxUPihcbiAgICBjbDogQ2xhc3M8VD4sXG4gICAgZGVmYXVsdFZhbHVlPzogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD5cbiAgKTogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gfCBudWxsID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdyYWIoY2wpO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgPyBkZWZhdWx0VmFsdWUgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuY29tcG9uZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gZW50aXR5IHRoYXQgaGFzIGJlZW4gdGFnZ2VkIHdpdGggdGhlIGdpdmVuIHRhZywgb3IgcmV0dXJuIG51bGw7XG4gICAqL1xuICBnZXRUYWdnZWQgPSAodGFnOiBUYWcpOiBFbnRpdHk8Q1Q+IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgdGFnRW50aXR5SWRzID0gdGhpcy5lbnRpdGllc0J5VGFncy5nZXQodGFnKTtcblxuICAgIGlmICh0YWdFbnRpdHlJZHMpIHtcbiAgICAgIGNvbnN0IGVudGl0eUlkID0gdGFnRW50aXR5SWRzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZW50aXR5SWQpO1xuXG4gICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHQgYWxsIGVudGl0aWVzIHRoYXQgaGF2ZSBiZWVuIHRhZ2dlZCB3aXRoIHRoZSBnaXZlbiB0YWcuXG4gICAqIEBwYXJhbSB0YWcgQSBzdHJpbmcgb3IgbnVtYmVyLlxuICAgKi9cbiAgZ2V0QWxsVGFnZ2VkID0gKHRhZzogVGFnKTogRW50aXR5PENUPltdID0+IHtcbiAgICBsZXQgZW50aXRpZXM6IEVudGl0eTxDVD5bXSA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjb25zdCB0YWdFbnRpdHlJZHMgPSB0aGlzLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgaWYgKHRhZ0VudGl0eUlkcykge1xuICAgICAgZm9yIChjb25zdCBlbnRpdHlJZCBvZiB0YWdFbnRpdHlJZHMpIHtcbiAgICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZW50aXR5SWQpO1xuICAgICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgICAgZW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudGl0aWVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBjb21wb25lbnQgb24gdGhlIGdpdmVuIGVudGl0eVxuICAgKi9cbiAgc2V0ID0gKGVpZDogRW50aXR5SWQsIGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPENUPik6IHRoaXMgPT4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICBjYy5hZGQoY29tcG9uZW50KTtcblxuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVpZCwgY2MpO1xuXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5hZGQoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29tcG9uZW50IGZyb20gdGhlIGdpdmVuIGVudGl0eS5cbiAgICogTk9URTogVGhpcyB3aWxsIGNoYW5nZSB3aGF0IHN5c3RlbXMgd2lsbCBiZSBjYWxsZWQgb24gdGhlIGVudGl0eS5cbiAgICovXG4gIHJlbW92ZSA9IChlaWQ6IEVudGl0eUlkLCBjVHlwZTogQ1QpOiB0aGlzID0+IHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgLy8gcmVtb3ZlIGVudGl0eSBmcm9tIGN1cnJlbnQgZW50aXRpZXNCeUNUeXBlc1xuICAgIGZvciAoY29uc3QgW2N0QXJyLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcykge1xuICAgICAgaWYgKChjdEFyciBhcyBzdHJpbmdbXSkuZXZlcnkoY2MuaGFzQnlOYW1lKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2MucmVtb3ZlKGNUeXBlKTtcblxuICAgIC8vIE1vdmUgZW50aXR5SWQgdG8gbmV3IENUeXBlcyBpZiBuZWVkZWQuXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5hZGQoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgaW4gc2V0dGluZyB1cCBhIG5ldyBzeXN0ZW0uXG4gICAqL1xuICByZWdpc3RlclN5c3RlbShjTmFtZXM6IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgdGhpcy5lbnRpdGllc0J5Q1R5cGVzLnNldChjTmFtZXMsIG5ldyBTZXQ8RW50aXR5SWQ+KCkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogYW4gYWxpYXMgZm9yIGNyZWF0ZVN5c3RlbSgpLlxuICAgKi9cbiAgY3JlYXRlU3lzdGVtKGNsOiBDVFtdLCBzeXN0ZW1GdW5jOiBTeXN0ZW1GdW5jPENUPik6IFN5c3RlbSB7XG4gICAgY29uc3Qgc3lzdGVtID0gY3JlYXRlU3lzdGVtPENUPih0aGlzLCBjbCwgc3lzdGVtRnVuYyk7XG5cbiAgICByZXR1cm4gc3lzdGVtO1xuICB9XG5cbiAgcmVnaXN0ZXJFbnRpdHkoZW50aXR5OiBFbnRpdHk8Q1Q+KTogV29ybGQ8Q1Q+IHtcbiAgICBjb25zdCBjYyA9IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZW50aXR5LmlkLCBjYyk7XG4gICAgdGhpcy5lbnRpdGllcy5zZXQoZW50aXR5LmlkLCBlbnRpdHkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBjb21wb25lbnRzIHRoYXQgYmVsb25nIHRvIGFuIGVudGl0eS5cbiAgICovXG4gIGNsZWFyRW50aXR5Q29tcG9uZW50cyhlaWQ6IEVudGl0eUlkKTogdGhpcyB7XG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZWlkLCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKSk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eVNldCBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVpZCkpIHtcbiAgICAgICAgZW50aXR5U2V0LmRlbGV0ZShlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlbnRpdHkgdGhhdCBpcyBpbiB0aGUgd29ybGQuXG4gICAqIEJhc2ljYWxseSBqdXN0IG5ldyBFbnRpdHkod29ybGQpLCBidXQgc2F2ZXMgYW4gaW1wb3J0IG9mIEVudGl0eS5cbiAgICovXG4gIGNyZWF0ZUVudGl0eSgpOiBFbnRpdHk8Q1Q+IHtcbiAgICBjb25zdCBlbnRpdHkgPSBuZXcgRW50aXR5KHRoaXMpO1xuXG4gICAgcmV0dXJuIGVudGl0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbiBlbnRpdHkuXG4gICAqIFNhbWUgYXMgZW50aXR5LmRlc3Ryb3koKS5cbiAgICovXG4gIGRlc3Ryb3lFbnRpdHkoZWlkOiBFbnRpdHlJZCk6IFdvcmxkPENUPiB7XG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5kZWxldGUoZWlkKTtcbiAgICB0aGlzLmVudGl0aWVzLmRlbGV0ZShlaWQpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHlTZXQgb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZW50aXR5U2V0LmhhcyhlaWQpKSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYW55IHRhZyBhc3NvY2lhdGlvbnMgd2l0aCBkZXN0cm95ZWQgZW50aXRpZXMuXG4gICAgZm9yIChjb25zdCBbdGFnLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeVRhZ3MpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVpZCkpIHtcbiAgICAgICAgZW50aXR5U2V0LmRlbGV0ZShlaWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW50aXR5U2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbnRpdGllc0J5VGFncy5kZWxldGUodGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiaW1wb3J0IFdvcmxkIGZyb20gJy4vV29ybGQnO1xuaW1wb3J0IHsgY3JlYXRlRW50aXR5IH0gZnJvbSAnLi9FbnRpdHknO1xuaW1wb3J0IHsgY3JlYXRlU3lzdGVtIH0gZnJvbSAnLi9TeXN0ZW0nO1xuXG5leHBvcnQge1xuICBXb3JsZCxcbiAgY3JlYXRlRW50aXR5LFxuICBjcmVhdGVTeXN0ZW0sXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n')}])}));