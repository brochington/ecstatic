!function(Q,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("ecstatic",[],n):"object"==typeof exports?exports.ecstatic=n():Q.ecstatic=n()}(window,(function(){return function(Q){var n=window.webpackHotUpdateecstatic;window.webpackHotUpdateecstatic=function(Q,B){!function(Q,n){if(!R[Q]||!a[Q])return;for(var B in a[Q]=!1,n)Object.prototype.hasOwnProperty.call(n,B)&&(b[B]=n[B]);0==--G&&0===u&&Z()}(Q,B),n&&n(Q,B)};var B,t=!0,e="ee3cab145f2db1b182d4",F={},U=[],I=[];function s(Q){var n=E[Q];if(!n)return L;var t=function(t){return n.hot.active?(E[t]?-1===E[t].parents.indexOf(Q)&&E[t].parents.push(Q):(U=[Q],B=t),-1===n.children.indexOf(t)&&n.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+Q),U=[]),L(t)},e=function(Q){return{configurable:!0,enumerable:!0,get:function(){return L[Q]},set:function(n){L[Q]=n}}};for(var F in L)Object.prototype.hasOwnProperty.call(L,F)&&"e"!==F&&"t"!==F&&Object.defineProperty(t,F,e(F));return t.e=function(Q){return"ready"===l&&g("prepare"),u++,L.e(Q).then(n,(function(Q){throw n(),Q}));function n(){u--,"prepare"===l&&(y[Q]||X(Q),0===u&&0===G&&Z())}},t.t=function(Q,n){return 1&n&&(Q=t(Q)),L.t(Q,-2&n)},t}function c(n){var t={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:B!==n,active:!0,accept:function(Q,n){if(void 0===Q)t._selfAccepted=!0;else if("function"==typeof Q)t._selfAccepted=Q;else if("object"==typeof Q)for(var B=0;B<Q.length;B++)t._acceptedDependencies[Q[B]]=n||function(){};else t._acceptedDependencies[Q]=n||function(){}},decline:function(Q){if(void 0===Q)t._selfDeclined=!0;else if("object"==typeof Q)for(var n=0;n<Q.length;n++)t._declinedDependencies[Q[n]]=!0;else t._declinedDependencies[Q]=!0},dispose:function(Q){t._disposeHandlers.push(Q)},addDisposeHandler:function(Q){t._disposeHandlers.push(Q)},removeDisposeHandler:function(Q){var n=t._disposeHandlers.indexOf(Q);n>=0&&t._disposeHandlers.splice(n,1)},invalidate:function(){switch(this._selfInvalidated=!0,l){case"idle":(b={})[n]=Q[n],g("ready");break;case"ready":m(n);break;case"prepare":case"check":case"dispose":case"apply":(o=o||[]).push(n)}},check:V,apply:N,status:function(Q){if(!Q)return l;i.push(Q)},addStatusHandler:function(Q){i.push(Q)},removeStatusHandler:function(Q){var n=i.indexOf(Q);n>=0&&i.splice(n,1)},data:F[n]};return B=void 0,t}var i=[],l="idle";function g(Q){l=Q;for(var n=0;n<i.length;n++)i[n].call(null,Q)}var d,b,C,o,G=0,u=0,y={},a={},R={};function x(Q){return+Q+""===Q?+Q:Q}function V(Q){if("idle"!==l)throw new Error("check() is only allowed in idle status");return t=Q,g("check"),(n=1e4,n=n||1e4,new Promise((function(Q,B){if("undefined"==typeof XMLHttpRequest)return B(new Error("No browser support"));try{var t=new XMLHttpRequest,e=L.p+"hot/hot-update.json";t.open("GET",e,!0),t.timeout=n,t.send(null)}catch(Q){return B(Q)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)B(new Error("Manifest request to "+e+" timed out."));else if(404===t.status)Q();else if(200!==t.status&&304!==t.status)B(new Error("Manifest request to "+e+" failed."));else{try{var n=JSON.parse(t.responseText)}catch(Q){return void B(Q)}Q(n)}}}))).then((function(Q){if(!Q)return g(r()?"ready":"idle"),null;a={},y={},R=Q.c,C=Q.h,g("prepare");var n=new Promise((function(Q,n){d={resolve:Q,reject:n}}));b={};return X(0),"prepare"===l&&0===u&&0===G&&Z(),n}));var n}function X(Q){var n;R[Q]?(a[Q]=!0,G++,(n=document.createElement("script")).charset="utf-8",n.src=L.p+"hot/hot-update.js",document.head.appendChild(n)):y[Q]=!0}function Z(){g("ready");var Q=d;if(d=null,Q)if(t)Promise.resolve().then((function(){return N(t)})).then((function(n){Q.resolve(n)}),(function(n){Q.reject(n)}));else{var n=[];for(var B in b)Object.prototype.hasOwnProperty.call(b,B)&&n.push(x(B));Q.resolve(n)}}function N(n){if("ready"!==l)throw new Error("apply() is only allowed in ready status");return function n(t){var I,s,c,i,l;function d(Q){for(var n=[Q],B={},t=n.map((function(Q){return{chain:[Q],id:Q}}));t.length>0;){var e=t.pop(),F=e.id,U=e.chain;if((i=E[F])&&(!i.hot._selfAccepted||i.hot._selfInvalidated)){if(i.hot._selfDeclined)return{type:"self-declined",chain:U,moduleId:F};if(i.hot._main)return{type:"unaccepted",chain:U,moduleId:F};for(var I=0;I<i.parents.length;I++){var s=i.parents[I],c=E[s];if(c){if(c.hot._declinedDependencies[F])return{type:"declined",chain:U.concat([s]),moduleId:F,parentId:s};-1===n.indexOf(s)&&(c.hot._acceptedDependencies[F]?(B[s]||(B[s]=[]),G(B[s],[F])):(delete B[s],n.push(s),t.push({chain:U.concat([s]),id:s})))}}}}return{type:"accepted",moduleId:Q,outdatedModules:n,outdatedDependencies:B}}function G(Q,n){for(var B=0;B<n.length;B++){var t=n[B];-1===Q.indexOf(t)&&Q.push(t)}}r();var u={},y=[],a={},V=function(){console.warn("[HMR] unexpected require("+Z.moduleId+") to disposed module")};for(var X in b)if(Object.prototype.hasOwnProperty.call(b,X)){var Z;l=x(X),Z=b[X]?d(l):{type:"disposed",moduleId:X};var N=!1,m=!1,W=!1,p="";switch(Z.chain&&(p="\nUpdate propagation: "+Z.chain.join(" -> ")),Z.type){case"self-declined":t.onDeclined&&t.onDeclined(Z),t.ignoreDeclined||(N=new Error("Aborted because of self decline: "+Z.moduleId+p));break;case"declined":t.onDeclined&&t.onDeclined(Z),t.ignoreDeclined||(N=new Error("Aborted because of declined dependency: "+Z.moduleId+" in "+Z.parentId+p));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(Z),t.ignoreUnaccepted||(N=new Error("Aborted because "+l+" is not accepted"+p));break;case"accepted":t.onAccepted&&t.onAccepted(Z),m=!0;break;case"disposed":t.onDisposed&&t.onDisposed(Z),W=!0;break;default:throw new Error("Unexception type "+Z.type)}if(N)return g("abort"),Promise.reject(N);if(m)for(l in a[l]=b[l],G(y,Z.outdatedModules),Z.outdatedDependencies)Object.prototype.hasOwnProperty.call(Z.outdatedDependencies,l)&&(u[l]||(u[l]=[]),G(u[l],Z.outdatedDependencies[l]));W&&(G(y,[Z.moduleId]),a[l]=V)}var A,S=[];for(s=0;s<y.length;s++)l=y[s],E[l]&&E[l].hot._selfAccepted&&a[l]!==V&&!E[l].hot._selfInvalidated&&S.push({module:l,parents:E[l].parents.slice(),errorHandler:E[l].hot._selfAccepted});g("dispose"),Object.keys(R).forEach((function(Q){!1===R[Q]&&function(Q){delete installedChunks[Q]}(Q)}));var h,D,H=y.slice();for(;H.length>0;)if(l=H.pop(),i=E[l]){var v={},Y=i.hot._disposeHandlers;for(c=0;c<Y.length;c++)(I=Y[c])(v);for(F[l]=v,i.hot.active=!1,delete E[l],delete u[l],c=0;c<i.children.length;c++){var k=E[i.children[c]];k&&((A=k.parents.indexOf(l))>=0&&k.parents.splice(A,1))}}for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=E[l]))for(D=u[l],c=0;c<D.length;c++)h=D[c],(A=i.children.indexOf(h))>=0&&i.children.splice(A,1);g("apply"),void 0!==C&&(e=C,C=void 0);for(l in b=void 0,a)Object.prototype.hasOwnProperty.call(a,l)&&(Q[l]=a[l]);var T=null;for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=E[l])){D=u[l];var J=[];for(s=0;s<D.length;s++)if(h=D[s],I=i.hot._acceptedDependencies[h]){if(-1!==J.indexOf(I))continue;J.push(I)}for(s=0;s<J.length;s++){I=J[s];try{I(D)}catch(Q){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:l,dependencyId:D[s],error:Q}),t.ignoreErrored||T||(T=Q)}}}for(s=0;s<S.length;s++){var z=S[s];l=z.module,U=z.parents,B=l;try{L(l)}catch(Q){if("function"==typeof z.errorHandler)try{z.errorHandler(Q)}catch(n){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:l,error:n,originalError:Q}),t.ignoreErrored||T||(T=n),T||(T=Q)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:l,error:Q}),t.ignoreErrored||T||(T=Q)}}if(T)return g("fail"),Promise.reject(T);if(o)return n(t).then((function(Q){return y.forEach((function(n){Q.indexOf(n)<0&&Q.push(n)})),Q}));return g("idle"),new Promise((function(Q){Q(y)}))}(n=n||{})}function r(){if(o)return b||(b={}),o.forEach(m),o=void 0,!0}function m(n){Object.prototype.hasOwnProperty.call(b,n)||(b[n]=Q[n])}var E={};function L(n){if(E[n])return E[n].exports;var B=E[n]={i:n,l:!1,exports:{},hot:c(n),parents:(I=U,U=[],I),children:[]};return Q[n].call(B.exports,B,B.exports,s(n)),B.l=!0,B.exports}return L.m=Q,L.c=E,L.d=function(Q,n,B){L.o(Q,n)||Object.defineProperty(Q,n,{enumerable:!0,get:B})},L.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},L.t=function(Q,n){if(1&n&&(Q=L(Q)),8&n)return Q;if(4&n&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var B=Object.create(null);if(L.r(B),Object.defineProperty(B,"default",{enumerable:!0,value:Q}),2&n&&"string"!=typeof Q)for(var t in Q)L.d(B,t,function(n){return Q[n]}.bind(null,t));return B},L.n=function(Q){var n=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return L.d(n,"a",n),n},L.o=function(Q,n){return Object.prototype.hasOwnProperty.call(Q,n)},L.p="/static/",L.h=function(){return e},s(0)(L.s=0)}([function(Q,n,B){Q.exports=B(1)},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "World", function() { return /* reexport */ World_World; });\n__webpack_require__.d(__webpack_exports__, "trackComponent", function() { return /* reexport */ trackComponent; });\n\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== \'undefined\' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \'undefined\' && typeof msCrypto.getRandomValues === \'function\' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error(\'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js\n/* harmony default export */ var regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js\n\n\nfunction validate(uuid) {\n  return typeof uuid === \'string\' && regex.test(uuid);\n}\n\n/* harmony default export */ var esm_browser_validate = (validate);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var stringify_i = 0; stringify_i < 256; ++stringify_i) {\n  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It\'s been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \'-\' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \'-\' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \'-\' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \'-\' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it\'s likely due to one\n  // of the following:\n  // - One or more input array values don\'t map to a hex octet (leading to\n  // "undefined" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!esm_browser_validate(uuid)) {\n    throw TypeError(\'Stringified UUID is invalid\');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ var esm_browser_stringify = (stringify);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return esm_browser_stringify(rnds);\n}\n\n/* harmony default export */ var esm_browser_v4 = (v4);\n// CONCATENATED MODULE: ./src/guards.ts\nfunction isComponentInstance(Class, comp) {\n  if (!comp) {\n    return false;\n  }\n\n  if (!(comp instanceof Class)) {\n    return false;\n  }\n\n  return true;\n}\n// CONCATENATED MODULE: ./src/ComponentCollection.ts\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n// CT is a Union, like `type = FirstComponent | SecondComponent`.\nclass ComponentCollection_ComponentCollection {\n  constructor() {\n    _defineProperty(this, "components", new Map());\n\n    _defineProperty(this, "add", component => {\n      this.components.set(component.constructor.name, component);\n    });\n\n    _defineProperty(this, "update", (cl, func) => {\n      const c = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, c)) {\n        const updatedComponent = func(c);\n        this.components.set(cl.name, updatedComponent);\n      }\n    });\n\n    _defineProperty(this, "remove", cType => {\n      this.components.delete(cType.name);\n    });\n\n    _defineProperty(this, "get", cl => {\n      const comp = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, comp)) {\n        return comp;\n      } else {\n        throw new Error(`ComponentCollection does not have component of type ${cl.name}`);\n      }\n    });\n\n    _defineProperty(this, "has", cType => {\n      return Array.isArray(cType) ? cType.every(ct => this.components.has(ct.name) === true) : this.components.has(cType.name);\n    });\n\n    _defineProperty(this, "hasByName", cName => {\n      return Array.isArray(cName) ? cName.every(ct => this.components.has(ct) === true) : this.components.has(cName);\n    });\n  }\n\n  /**\n   * Get the component type names that are currently being used in the collection.\n   */\n  get componentTypes() {\n    return [...this.components.keys()];\n  }\n  /**\n   * Get the current number of components that are in the collection.\n   */\n\n\n  get size() {\n    return this.components.size;\n  }\n\n  toDevComponents() {\n    const obj = {};\n\n    for (const [compName, comp] of this.components) {\n      obj[compName] = comp;\n    }\n\n    return obj;\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevEntity.ts\nfunction DevEntity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevEntity {\n  constructor(entity, world) {\n    DevEntity_defineProperty(this, "id", void 0);\n\n    DevEntity_defineProperty(this, "components", void 0);\n\n    DevEntity_defineProperty(this, "tags", void 0);\n\n    DevEntity_defineProperty(this, "systems", []);\n\n    this.id = entity.id;\n    this.components = entity.components.toDevComponents(), this.tags = [...entity.tags];\n    const compNames = Object.keys(this.components);\n\n    for (const [systemName, cNames] of world.systems.compNamesBySystemName) {\n      if (cNames.every(cName => compNames.includes(cName))) {\n        this.systems.push(systemName);\n      }\n    }\n  }\n\n  toTableRow() {\n    return {\n      id: this.id,\n      components: Object.keys(this.components).join(", "),\n      tags: this.tags.join(", "),\n      systems: this.systems.join(\', \')\n    };\n  }\n\n}\n\n/* harmony default export */ var src_DevEntity = (DevEntity);\n// CONCATENATED MODULE: ./src/SimpleFSM.ts\nfunction SimpleFSM_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass SimpleFSM {\n  constructor(initialState, transitions) {\n    SimpleFSM_defineProperty(this, "current", void 0);\n\n    SimpleFSM_defineProperty(this, "inital", void 0);\n\n    SimpleFSM_defineProperty(this, "transitions", void 0);\n\n    this.inital = initialState;\n    this.current = initialState;\n    this.transitions = transitions;\n  }\n\n  next(data) {\n    if (this.transitions[this.current]) {\n      this.current = this.transitions[this.current](data, this.current);\n    }\n  }\n\n  reset() {\n    this.current = this.inital;\n  }\n\n  is(checkState) {\n    return this.current === checkState;\n  }\n\n}\n// CONCATENATED MODULE: ./src/Entity.ts\nfunction Entity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nclass Entity_Entity {\n  get id() {\n    return this._id;\n  }\n\n  get world() {\n    return this._world;\n  }\n\n  get state() {\n    return this._state.current;\n  }\n\n  constructor(world) {\n    Entity_defineProperty(this, "_id", void 0);\n\n    Entity_defineProperty(this, "_world", void 0);\n\n    Entity_defineProperty(this, "_error", void 0);\n\n    Entity_defineProperty(this, "_state", void 0);\n\n    this._id = esm_browser_v4();\n    this._world = world;\n    this._error = null;\n\n    const fsmTransition = ns => {\n      if (ns === "error" || this._error) return "error";\n      return ns;\n    };\n\n    this._state = new SimpleFSM("creating", {\n      creating: fsmTransition,\n      created: fsmTransition,\n      destroying: fsmTransition,\n      destroyed: () => "destroyed",\n      error: () => "error"\n    });\n    /*\n    Registering with the World.\n    */\n\n    this._world.registerEntity(this);\n\n    if (this._world.systems.compNamesBySystemName.size === 0) {\n      this._state.next(\'created\');\n    }\n  }\n  /* LifeCycle methods, meant to be overridden */\n\n\n  onCreate(world) {// abstract\n  }\n\n  onDestroy(world) {// abstract\n  }\n\n  onComponentAdd(args) {// abstract\n  }\n\n  onTrackedComponentUpdate(args) {// abstract\n  }\n\n  onComponentRemove(args) {// abstract\n  }\n  /**\n   * Add a component to an Entity, doh.\n   */\n\n\n  add(component) {\n    this._world.add(this._id, component);\n\n    return this;\n  }\n  /**\n   * Add a tag to a component\n   */\n\n\n  addTag(tag) {\n    const entitySet = this._world.entitiesByTags.has(tag) ? this._world.entitiesByTags.get(tag) : new Set();\n\n    if (entitySet) {\n      entitySet.add(this._id);\n\n      this._world.entitiesByTags.set(tag, entitySet);\n    }\n\n    return this;\n  }\n  /**\n   * Determines if an entity has a component related to it.\n   */\n\n\n  has(cType) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    return cc.has(cType);\n  }\n  /**\n   * Check to see if an entity tagged with a given tag.\n   */\n\n\n  hasTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        return entitySet.has(this._id);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get a component that belongs to an entity.\n   */\n\n\n  get(cl) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    const component = cc.get(cl);\n    return component;\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection\n   */\n\n\n  getAll() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Remove a component from an entity.\n   * @param cType A component class, eg MyComponent\n   */\n\n\n  remove(cType) {\n    this._world.remove(this._id, cType);\n\n    return this;\n  }\n  /**\n   * Remove a tag from an entity\n   */\n\n\n  removeTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        entitySet.delete(this._id);\n\n        if (entitySet.size === 0) {\n          this._world.entitiesByTags.delete(tag);\n        }\n      }\n    }\n\n    return this;\n  }\n  /** Clears all components from an Entity */\n\n\n  clear() {\n    this._world.clearEntityComponents(this._id);\n\n    return this;\n  }\n  /**\n   * Remove all tags on an entity\n   */\n\n\n  clearTags() {\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      entitySet.delete(this._id);\n\n      if (entitySet.size === 0) {\n        this._world.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Sets the state of the entity to \'created\'. that\'s it.\n   */\n\n\n  finishCreation() {\n    this._state.next(\'created\');\n  }\n  /**\n   * Destroy an entity. Actual destruction is deferred until after the next pass of systems.\n   * This gives the systems a chance to do any cleanup that might be needed.\n   */\n\n\n  destroy() {\n    // If no systems are added, the destroy immediately.\n    if (this._world.systems.compNamesBySystemName.size === 0) {\n      this.destroyImmediately();\n      return;\n    } // Mark as "destroying" so that systems can act on it before actually being destroyed.\n\n\n    this._state.next(\'destroying\');\n  }\n\n  destroyImmediately() {\n    // Right now calling before the actual destorying of the entity.\n    // Might want to change this to post destruction in the future, who knows.\n    this.onDestroy(this._world); // Actually destroy entity.\n\n    this._world.destroyEntity(this._id); // should return an error??\n\n\n    this._state.next(\'destroyed\');\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection.\n   * Does the same thing as entityInstance.getAll().\n   */\n\n\n  get components() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Retrieves all the tags that have been added to this entity.\n   */\n\n\n  get tags() {\n    const tags = new Set();\n\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      if (entitySet.has(this._id)) {\n        tags.add(tag);\n      }\n    }\n\n    return tags;\n  }\n  /**\n   * Convert Entity to a DevEntity. Very helpful in for debugging.\n   */\n\n\n  toDevEntity() {\n    return new src_DevEntity(this, this._world);\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevTools.ts\nfunction DevTools_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevTools {\n  constructor(world) {\n    DevTools_defineProperty(this, "world", void 0);\n\n    this.world = world;\n  }\n  /**\n   * display the all systems of the world, and the components required by each system.\n   * Super helpful to use with console.table()\n   * @example\n   * ```\n   * console.table(world.dev.systemComponents);\n   * ```\n   */\n\n\n  get systemComponents() {\n    const compsBySystems = [];\n\n    for (const [system, compNames] of this.world.systems.compNamesBySystemName) {\n      compsBySystems.push({\n        system,\n        components: compNames.join(", ")\n      });\n    }\n\n    return compsBySystems;\n  }\n  /**\n   * Create an array of DevEntites. Can be very helpful for things like inspecting component state,\n   * and which systems will be called on an entity.\n   * @example\n   * ```\n   * console.table(world.dev.entities);\n   *\n   * // Pro tip! try displaying a table of entities with console.table and DevEntity.toTableRow().\n   * console.table(world.dev.entities.map(devEntity => devEntity.toTableRow()));\n   * ```\n   */\n\n\n  get entities() {\n    return [...this.world.entities.values()].map(e => e.toDevEntity());\n  }\n\n}\n\n/* harmony default export */ var src_DevTools = (DevTools);\n// CONCATENATED MODULE: ./src/Systems.ts\nfunction Systems_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/**\n * Arguments that are passed into a System function on each iteration.\n * This is how you acces things like the entity that particular entity to act on,\n * as well as some other helpful params like if the entity is the first or last entity\n * in the group of entities that being iterated over.\n */\n\nclass Systems_Systems {\n  // double check to make sure that maps are ordered.\n  constructor(world) {\n    Systems_defineProperty(this, "world", void 0);\n\n    Systems_defineProperty(this, "systemFuncBySystemName", void 0);\n\n    Systems_defineProperty(this, "compNamesBySystemName", void 0);\n\n    this.world = world;\n    this.systemFuncBySystemName = new Map();\n    this.compNamesBySystemName = new Map();\n  }\n\n  add(cTypes, systemFunc, funcName) {\n    const cNames = cTypes.map(ct => ct.name);\n    let name = systemFunc.name;\n\n    if (systemFunc.name === \'\') {\n      // Super brute force, and might lead to errors in the future, but for now\n      // using the stringified system function if the function doesn\'t already have a name.\n      // This is useful for anonymous functions used as a system function.\n      // Might be good to figure out how to get a hash of the function string.\n      name = systemFunc.toString().slice(0, 30);\n    }\n\n    if (funcName) {\n      name = funcName;\n    }\n\n    this.systemFuncBySystemName.set(name, systemFunc);\n    this.compNamesBySystemName.set(name, cNames);\n    this.world.entitiesByCTypes.set(cNames, new Set());\n    return this;\n  }\n\n  run() {\n    // TODO: Might be cool to add a way to stop the systems loop when in dev.\n    //       Maybe something like world.dev.stop() or pause().\n    for (const [funcName, systemFunc] of this.systemFuncBySystemName.entries()) {\n      let index = 0;\n      const size = this.world.entitiesByCTypes.size;\n      const cNames = this.compNamesBySystemName.get(funcName) || [];\n      const cTypeArrs = this.world.entitiesByCTypes.get(cNames) || new Set();\n      const entitiesInCreatingState = [];\n      const entitiesInDestroyingState = [];\n\n      for (const entity of this.world.entities.values()) {\n        if (entity.state === \'creating\') {\n          entitiesInCreatingState.push(entity);\n        }\n\n        if (entity.state === \'destroying\') {\n          entitiesInDestroyingState.push(entity);\n        }\n      }\n\n      for (const eid of cTypeArrs) {\n        const args = {\n          entity: this.world.entities.get(eid) || new Entity_Entity(this.world),\n          components: this.world.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(),\n          world: this.world,\n          index,\n          size,\n          isFirst: index === 0,\n          isLast: index + 1 === size\n        };\n        systemFunc(args);\n        index += 1;\n      }\n\n      for (const entity of entitiesInCreatingState) {\n        entity.finishCreation();\n      }\n\n      for (const entity of entitiesInDestroyingState) {\n        entity.destroyImmediately();\n      }\n    }\n  }\n\n}\n// CONCATENATED MODULE: ./src/TrackedComponent.ts\n// Waiting for Typescript 4.2 to come out so that Symbols are supporded keys.\nconst TrackedCompSymbolKeys = {\n  isTracked: Symbol.for("ecs.trackedComponent.isTracked"),\n  world: Symbol.for("ecs.trackedComponent.world"),\n  setWorld: Symbol.for("ecs.trackedComponent.setWorld"),\n  onAdd: Symbol.for("ecs.trackedComponent.onAdd"),\n  onUpdate: Symbol.for("ecs.trackedComponent.onUpdate"),\n  onRemove: Symbol.for("ecs.trackedComponent.onRemove")\n}; //@ts-ignore\n\nfunction createClassInstanceProxyHandlers(trackedEventHandlers) {\n  const updatedProps = new Set();\n  return {\n    set(component, property, value) {\n      updatedProps.add(property); //@ts-ignore\n\n      const world = component[TrackedCompSymbolKeys.world];\n      const previousVal = component[property];\n      component[property] = value;\n\n      if (trackedEventHandlers.onUpdate) {\n        trackedEventHandlers.onUpdate({\n          world,\n          component,\n          previousVal,\n          property\n        });\n      }\n\n      return true;\n    }\n\n  };\n}\n\nfunction trackComponent(CompClass, trackedEventHandlers) {\n  return new Proxy(CompClass, {\n    construct(Component, args) {\n      const component = new Component(...args); // const component = new Component(...args) as T & TrackedComponent<Class<T>>;\n      // const component = new Component(...args) as InstanceType<Class<T>>;\n      // For use in identifing a "tracked" class through the proxy.\n      //@ts-ignore\n\n      component[TrackedCompSymbolKeys.isTracked] = true; //@ts-ignore\n\n      component[TrackedCompSymbolKeys.setWorld] = world => {\n        //@ts-ignore\n        component[TrackedCompSymbolKeys.world] = world;\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onAdd] = (world, entity) => {\n        if (trackedEventHandlers.onAdd) {\n          trackedEventHandlers.onAdd({\n            component,\n            world,\n            entity\n          });\n        }\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onRemove] = (world, entity) => {\n        if (trackedEventHandlers.onRemove) {\n          trackedEventHandlers.onRemove({\n            component,\n            world,\n            entity\n          });\n        }\n      };\n\n      return new Proxy(component, createClassInstanceProxyHandlers(trackedEventHandlers));\n    }\n\n  });\n}\n// CONCATENATED MODULE: ./src/World.ts\nfunction World_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nclass World_World {\n  constructor() {\n    World_defineProperty(this, "componentCollections", new Map());\n\n    World_defineProperty(this, "entities", new Map());\n\n    World_defineProperty(this, "entitiesByCTypes", new Map());\n\n    World_defineProperty(this, "entitiesByTags", new Map());\n\n    World_defineProperty(this, "systems", void 0);\n\n    World_defineProperty(this, "dev", void 0);\n\n    World_defineProperty(this, "find", predicate => {\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "findAll", predicate => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "locate", cl => {\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "locateAll", cl => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "grab", cl => {\n      const entity = this.locate(cl);\n\n      if (entity) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n        return {\n          entity,\n          component\n        };\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabBy", (cl, predicate) => {\n      const entities = this.locateAll(cl); // const entities = this.locateAll((cl as unknown) as CT);\n\n      for (const entity of entities) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n\n        if (predicate(component)) {\n          return {\n            component,\n            entity\n          };\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabAll", cl => {\n      const entities = this.locateAll(cl);\n      return entities.map(entity => {\n        return {\n          entity,\n          component: entity.components.get(cl)\n        };\n      });\n    });\n\n    World_defineProperty(this, "get", (eid, cl) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      return cc.get(cl);\n    });\n\n    World_defineProperty(this, "getComponent", (cl, defaultValue) => {\n      const result = this.grab(cl);\n\n      if (!result) {\n        return defaultValue ? defaultValue : null;\n      }\n\n      return result.component;\n    });\n\n    World_defineProperty(this, "getTagged", tag => {\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        const entityId = tagEntityIds.values().next().value;\n        const entity = this.entities.get(entityId);\n\n        if (entity) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "getAllTagged", tag => {\n      let entities = []; // eslint-disable-line\n\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        for (const entityId of tagEntityIds) {\n          const entity = this.entities.get(entityId);\n\n          if (entity) {\n            entities.push(entity);\n          }\n        }\n      }\n\n      return entities;\n    });\n\n    World_defineProperty(this, "add", (eid, component) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      cc.add(component);\n      this.componentCollections.set(eid, cc);\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      } // @ts-ignore\n\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        // @ts-ignore\n        component[TrackedCompSymbolKeys.setWorld](this);\n        const entity = this.entities.get(eid);\n\n        if (!entity) {\n          throw new Error(`world.add: Unable to locate entity. eid: ${eid}`);\n        } // @ts-ignore\n\n\n        component[TrackedCompSymbolKeys.onAdd](this, entity);\n      }\n\n      return this;\n    });\n\n    World_defineProperty(this, "remove", (eid, cType) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(); // need to get component instance...\n\n      const component = cc.get(cType); // @ts-ignore\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        const entity = this.entities.get(eid);\n\n        if (!entity) {\n          throw new Error(`world.remove: Unable to locate entity. eid: ${eid}, cType: ${cType.name}`);\n        } // @ts-ignore\n\n\n        component[TrackedCompSymbolKeys.onRemove](this, entity);\n      } // remove entity from current entitiesByCTypes\n\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.delete(eid);\n        }\n      }\n\n      cc.remove(cType); // Move entityId to new CTypes if needed.\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      return this;\n    });\n\n    this.dev = new src_DevTools(this);\n    this.systems = new Systems_Systems(this);\n  }\n  /**\n   * "finds" a single entity based on a predicate\n   */\n\n\n  /**\n   * Alternative method for adding systems.\n   */\n  addSystem(cTypes, systemFunc, funcName) {\n    this.systems.add(cTypes, systemFunc, funcName);\n    return this;\n  }\n\n  registerEntity(entity) {\n    const cc = new ComponentCollection_ComponentCollection();\n    this.componentCollections.set(entity.id, cc);\n    this.entities.set(entity.id, entity);\n    entity.onCreate(this);\n    return this;\n  }\n  /**\n   * Remove all components that belong to an entity.\n   */\n\n\n  clearEntityComponents(entityId) {\n    this.componentCollections.set(entityId, new ComponentCollection_ComponentCollection());\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(entityId)) {\n        entitySet.delete(entityId);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Create an entity that is in the world.\n   * Basically just new Entity(world), but saves an import of Entity.\n   */\n\n\n  createEntity() {\n    const entity = new Entity_Entity(this);\n    return entity; // Register entity here....\n  }\n  /**\n   * Destroys an entity.\n   * Same as entity.destroy().\n   */\n\n\n  destroyEntity(entityId) {\n    this.componentCollections.delete(entityId);\n    const entity = this.entities.get(entityId);\n\n    if (!entity) {\n      throw new Error(`world.destroyEntity: No entity found. entity id: ${entityId}`);\n    }\n\n    this.entities.delete(entityId);\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(entityId)) {\n        entitySet.delete(entityId);\n      }\n    } // remove any tag associations with destroyed entities.\n\n\n    for (const [tag, entitySet] of this.entitiesByTags) {\n      if (entitySet.has(entityId)) {\n        entitySet.delete(entityId);\n      }\n\n      if (entitySet.size === 0) {\n        this.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n}\n// CONCATENATED MODULE: ./src/index.ts\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY3N0YXRpYy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzP2Q4ZjgiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzPzQwZDYiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzA2ZTQiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3N0cmluZ2lmeS5qcz81OGNmIiwid2VicGFjazovL2Vjc3RhdGljLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz9lYzI2Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL2d1YXJkcy50cz8zYjU3Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL0NvbXBvbmVudENvbGxlY3Rpb24udHM/NTFjNCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZFbnRpdHkudHM/ZDE0MiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9TaW1wbGVGU00udHM/NDY5OSIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9FbnRpdHkudHM/YWM2OCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZUb29scy50cz9lMDFhIiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL1N5c3RlbXMudHM/YTYxMyIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9UcmFja2VkQ29tcG9uZW50LnRzP2JhMjciLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9zcmMvV29ybGQudHM/Y2MwYiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9pbmRleC50cz9mZmI0Il0sIm5hbWVzIjpbImlzQ29tcG9uZW50SW5zdGFuY2UiLCJDbGFzcyIsImNvbXAiLCJDb21wb25lbnRDb2xsZWN0aW9uIiwiTWFwIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInNldCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNsIiwiZnVuYyIsImMiLCJnZXQiLCJ1cGRhdGVkQ29tcG9uZW50IiwiY1R5cGUiLCJkZWxldGUiLCJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwiY3QiLCJoYXMiLCJjTmFtZSIsImNvbXBvbmVudFR5cGVzIiwia2V5cyIsInNpemUiLCJ0b0RldkNvbXBvbmVudHMiLCJvYmoiLCJjb21wTmFtZSIsIkRldkVudGl0eSIsImVudGl0eSIsIndvcmxkIiwiaWQiLCJ0YWdzIiwiY29tcE5hbWVzIiwiT2JqZWN0Iiwic3lzdGVtTmFtZSIsImNOYW1lcyIsInN5c3RlbXMiLCJjb21wTmFtZXNCeVN5c3RlbU5hbWUiLCJpbmNsdWRlcyIsInB1c2giLCJ0b1RhYmxlUm93Iiwiam9pbiIsIlNpbXBsZUZTTSIsImluaXRpYWxTdGF0ZSIsInRyYW5zaXRpb25zIiwiaW5pdGFsIiwiY3VycmVudCIsIm5leHQiLCJkYXRhIiwicmVzZXQiLCJpcyIsImNoZWNrU3RhdGUiLCJFbnRpdHkiLCJfaWQiLCJfd29ybGQiLCJzdGF0ZSIsIl9zdGF0ZSIsInV1aWR2NCIsIl9lcnJvciIsImZzbVRyYW5zaXRpb24iLCJucyIsImNyZWF0aW5nIiwiY3JlYXRlZCIsImRlc3Ryb3lpbmciLCJkZXN0cm95ZWQiLCJlcnJvciIsInJlZ2lzdGVyRW50aXR5Iiwib25DcmVhdGUiLCJvbkRlc3Ryb3kiLCJvbkNvbXBvbmVudEFkZCIsImFyZ3MiLCJvblRyYWNrZWRDb21wb25lbnRVcGRhdGUiLCJvbkNvbXBvbmVudFJlbW92ZSIsImFkZCIsImFkZFRhZyIsInRhZyIsImVudGl0eVNldCIsImVudGl0aWVzQnlUYWdzIiwiU2V0IiwiY2MiLCJjb21wb25lbnRDb2xsZWN0aW9ucyIsImhhc1RhZyIsImdldEFsbCIsInJlbW92ZSIsInJlbW92ZVRhZyIsImNsZWFyIiwiY2xlYXJFbnRpdHlDb21wb25lbnRzIiwiY2xlYXJUYWdzIiwiZW50cmllcyIsImZpbmlzaENyZWF0aW9uIiwiZGVzdHJveSIsImRlc3Ryb3lJbW1lZGlhdGVseSIsImRlc3Ryb3lFbnRpdHkiLCJ0b0RldkVudGl0eSIsIkRldlRvb2xzIiwic3lzdGVtQ29tcG9uZW50cyIsImNvbXBzQnlTeXN0ZW1zIiwic3lzdGVtIiwiZW50aXRpZXMiLCJ2YWx1ZXMiLCJtYXAiLCJlIiwiU3lzdGVtcyIsInN5c3RlbUZ1bmNCeVN5c3RlbU5hbWUiLCJjVHlwZXMiLCJzeXN0ZW1GdW5jIiwiZnVuY05hbWUiLCJ0b1N0cmluZyIsInNsaWNlIiwiZW50aXRpZXNCeUNUeXBlcyIsInJ1biIsImluZGV4IiwiY1R5cGVBcnJzIiwiZW50aXRpZXNJbkNyZWF0aW5nU3RhdGUiLCJlbnRpdGllc0luRGVzdHJveWluZ1N0YXRlIiwiZWlkIiwiaXNGaXJzdCIsImlzTGFzdCIsIlRyYWNrZWRDb21wU3ltYm9sS2V5cyIsImlzVHJhY2tlZCIsIlN5bWJvbCIsImZvciIsInNldFdvcmxkIiwib25BZGQiLCJvblVwZGF0ZSIsIm9uUmVtb3ZlIiwiY3JlYXRlQ2xhc3NJbnN0YW5jZVByb3h5SGFuZGxlcnMiLCJ0cmFja2VkRXZlbnRIYW5kbGVycyIsInVwZGF0ZWRQcm9wcyIsInByb3BlcnR5IiwidmFsdWUiLCJwcmV2aW91c1ZhbCIsInRyYWNrQ29tcG9uZW50IiwiQ29tcENsYXNzIiwiUHJveHkiLCJjb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJXb3JsZCIsInByZWRpY2F0ZSIsInJlc3VsdHMiLCJsb2NhdGUiLCJsb2NhdGVBbGwiLCJkZWZhdWx0VmFsdWUiLCJyZXN1bHQiLCJncmFiIiwidGFnRW50aXR5SWRzIiwiZW50aXR5SWQiLCJjdEFyciIsImhhc0J5TmFtZSIsImRldiIsImFkZFN5c3RlbSIsImNyZWF0ZUVudGl0eSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QWtCd0ksUUFBbEIsQ0FBZjs7QUFFQSxRQUFJLENBQUN0SCxNQUFMLEVBQWE7QUFDWCxZQUFNLElBQUlkLEtBQUosQ0FBVyxvREFBbURvSSxRQUFTLEVBQXZFLENBQU47QUFDRDs7QUFFRCxTQUFLaEQsUUFBTCxDQUFjckYsTUFBZCxDQUFxQnFJLFFBQXJCOztBQUVBLFNBQUssTUFBTXRFLFNBQVgsSUFBd0IsS0FBS2lDLGdCQUFMLENBQXNCVixNQUF0QixFQUF4QixFQUF3RDtBQUN0RCxVQUFJdkIsU0FBUyxDQUFDekQsR0FBVixDQUFjK0gsUUFBZCxDQUFKLEVBQTZCO0FBQzNCdEUsaUJBQVMsQ0FBQy9ELE1BQVYsQ0FBaUJxSSxRQUFqQjtBQUNEO0FBQ0YsS0FkMEMsQ0FnQjNDOzs7QUFDQSxTQUFLLE1BQU0sQ0FBQ3ZFLEdBQUQsRUFBTUMsU0FBTixDQUFYLElBQStCLEtBQUtDLGNBQXBDLEVBQW9EO0FBQ2xELFVBQUlELFNBQVMsQ0FBQ3pELEdBQVYsQ0FBYytILFFBQWQsQ0FBSixFQUE2QjtBQUMzQnRFLGlCQUFTLENBQUMvRCxNQUFWLENBQWlCcUksUUFBakI7QUFDRDs7QUFFRCxVQUFJdEUsU0FBUyxDQUFDckQsSUFBVixLQUFtQixDQUF2QixFQUEwQjtBQUN4QixhQUFLc0QsY0FBTCxDQUFvQmhFLE1BQXBCLENBQTJCOEQsR0FBM0I7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNEOztBQTNYNEIsQzs7QUNWL0I7QUFDQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG52YXIgZ2V0UmFuZG9tVmFsdWVzO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4gICAgLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSIsImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTsiLCJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiLCJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxudmFyIGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyKSB7XG4gIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICB2YXIgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiLCJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5KHJuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2NDsiLCJleHBvcnQgZnVuY3Rpb24gaXNDb21wb25lbnRJbnN0YW5jZTxUPihcbiAgQ2xhc3M6IG5ldyAoLi4uYXJnczogYW55KSA9PiBULFxuICBjb21wOiBhbnlcbik6IGNvbXAgaXMgSW5zdGFuY2VUeXBlPHR5cGVvZiBDbGFzcz4ge1xuICBpZiAoIWNvbXApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJpbXBvcnQgeyBpc0NvbXBvbmVudEluc3RhbmNlIH0gZnJvbSBcIi4vZ3VhcmRzXCI7XG5cbnR5cGUgQ29tcE5hbWUgPSBzdHJpbmc7XG50eXBlIENsYXNzQ29uc3RydWN0b3I8VD4gPSB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUIH07XG5cbi8vIENUIGlzIGEgVW5pb24sIGxpa2UgYHR5cGUgPSBGaXJzdENvbXBvbmVudCB8IFNlY29uZENvbXBvbmVudGAuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnRDb2xsZWN0aW9uPENUPiB7XG4gIGNvbXBvbmVudHM6IE1hcDxDb21wTmFtZSwgQ1Q+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIGluc3RhbmNlIG9mIGEgY29tcG9uZW50XG4gIC8vIGFkZCA9IChjb21wb25lbnQ6IEluc3RhbmNlVHlwZTxDVFtrZXlvZiBDVF0+KTogdm9pZCA9PiB7XG4gIGFkZCA9IChjb21wb25lbnQ6IENUKTogdm9pZCA9PiB7XG4gICAgdGhpcy5jb21wb25lbnRzLnNldCgoPGFueT5jb21wb25lbnQpLmNvbnN0cnVjdG9yLm5hbWUsIGNvbXBvbmVudCk7XG4gIH07XG5cbiAgdXBkYXRlID0gPFQgZXh0ZW5kcyBDVD4oXG4gICAgY2w6IENsYXNzQ29uc3RydWN0b3I8VD4sXG4gICAgZnVuYzogKGM6IFQpID0+IFRcbiAgKTogdm9pZCA9PiB7XG4gICAgY29uc3QgYyA9IHRoaXMuY29tcG9uZW50cy5nZXQoY2wubmFtZSk7XG5cbiAgICBpZiAoaXNDb21wb25lbnRJbnN0YW5jZShjbCwgYykpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRDb21wb25lbnQgPSBmdW5jKGMpO1xuICAgICAgdGhpcy5jb21wb25lbnRzLnNldChjbC5uYW1lLCB1cGRhdGVkQ29tcG9uZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGNUeXBlIENsYXNzIG9mIGNvbXBvbmVudCB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmUgPSAoY1R5cGU6IENsYXNzQ29uc3RydWN0b3I8Q1Q+KTogdm9pZCA9PiB7XG4gICAgdGhpcy5jb21wb25lbnRzLmRlbGV0ZShjVHlwZS5uYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgY29tcG9uZW50IHRoYXQgbWF0Y2hlcyB0aGUgcGFzc2VkIGNsYXNzLlxuICAgKiBXaWxsIHRocm93IGFuIGVycm9yIGlmIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBjb21wb25lbnRcbiAgICogZG9lc24ndCBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiwgc28gaWYgeW91IGRvbid0IGtub3cgaWYgaXQncyBzYWZlXG4gICAqIHRvIGdldCBhIGNvbXBvbmVudCwgeW91IHNob3VsZCB0ZXN0IHdpdGggaGFzKCkgb3IgaGFzQnlOYW1lKCkgZmlyc3QuXG4gICAqIFlvdSBoYXZlIGJlZW4gd2FybmVkLlxuICAgKiBAcGFyYW0gY2wgY29tcG9uZW50IENsYXNzIHJlZmVyZW5jZS5cbiAgICovXG4gIGdldCA9IDxUIGV4dGVuZHMgQ1Q+KGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+KTogVCA9PiB7XG4gICAgY29uc3QgY29tcCA9IHRoaXMuY29tcG9uZW50cy5nZXQoY2wubmFtZSk7XG5cbiAgICBpZiAoaXNDb21wb25lbnRJbnN0YW5jZTxUPihjbCwgY29tcCkpIHtcbiAgICAgIHJldHVybiBjb21wO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb21wb25lbnRDb2xsZWN0aW9uIGRvZXMgbm90IGhhdmUgY29tcG9uZW50IG9mIHR5cGUgJHtjbC5uYW1lfWBcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHRvIHNlZSBpZiB0aGUgY29sbGVjdGlvbiBjb250YWlucyBhIHNwZWNpZmljIENsYXNzIG9yIENsYXNzZXMuXG4gICAqIEBwYXJhbSBjVHlwZSBjb21wb25lbnQgQ2xhc3MsIG9yIGFycmF5IG9mIGNvbXBvbmVudCBDbGFzc2VzLlxuICAgKi9cbiAgaGFzID0gKGNUeXBlOiBDbGFzc0NvbnN0cnVjdG9yPENUPiB8IENsYXNzQ29uc3RydWN0b3I8Q1Q+W10pOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjVHlwZSlcbiAgICAgID8gY1R5cGUuZXZlcnkoKGN0KSA9PiB0aGlzLmNvbXBvbmVudHMuaGFzKGN0Lm5hbWUpID09PSB0cnVlKVxuICAgICAgOiB0aGlzLmNvbXBvbmVudHMuaGFzKGNUeXBlLm5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHRvIHNlZSBpZiB0aGUgY29sbGVjdGlvbiBoYXMgYSBjb21wb25lbnQgaW5zdGFuY2UgYmFzZWQgb24gYVxuICAgKiBjbGFzcyBuYW1lLiBTb21lIGJ1aWxkIHN0ZXBzL21pbmlmaWVycyB3aWxsIGNoYW5nZSB0aGUgbmFtZSBvZiBDbGFzc2VzLFxuICAgKiBzbyBpdCdzIHVzdWFsbHkgYmVzdCB0byBwYXNzIGluIGEgTXlDbGFzcy5uYW1lIGluc3RlYWQgb2YgJ015Q2xhc3MnLlxuICAgKiBAcGFyYW0gY05hbWUgVGhlIG5hbWUgb2YgYSBDbGFzcywgb3IgYXJyYXkgb2YgQ2xhc3MgbmFtZXMuXG4gICAqL1xuICBoYXNCeU5hbWUgPSAoY05hbWU6IHN0cmluZyB8IHN0cmluZ1tdKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY05hbWUpXG4gICAgICA/IGNOYW1lLmV2ZXJ5KGN0ID0+IHRoaXMuY29tcG9uZW50cy5oYXMoY3QpID09PSB0cnVlKVxuICAgICAgOiB0aGlzLmNvbXBvbmVudHMuaGFzKGNOYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb21wb25lbnQgdHlwZSBuYW1lcyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgdXNlZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIGdldCBjb21wb25lbnRUeXBlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmNvbXBvbmVudHMua2V5cygpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGNvbXBvbmVudHMgdGhhdCBhcmUgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqL1xuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuc2l6ZTtcbiAgfVxuXG4gIHRvRGV2Q29tcG9uZW50cygpOiBSZWNvcmQ8c3RyaW5nLCBDVD4ge1xuICAgIGNvbnN0IG9iajogUmVjb3JkPHN0cmluZywgQ1Q+ID0ge307XG4gICAgZm9yIChjb25zdCBbY29tcE5hbWUsIGNvbXBdIG9mIHRoaXMuY29tcG9uZW50cykge1xuICAgICAgb2JqW2NvbXBOYW1lXSA9IGNvbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxuIiwiaW1wb3J0IFdvcmxkIGZyb20gXCIuL1dvcmxkXCI7XG5pbXBvcnQgRW50aXR5IGZyb20gXCIuL0VudGl0eVwiO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSBcIi4vVGFnXCI7XG5cbmludGVyZmFjZSBEZXZFbnRpdHlUYWJsZVJvdyB7XG4gIGlkOiBzdHJpbmc7XG4gIGNvbXBvbmVudHM6IHN0cmluZztcbiAgdGFnczogc3RyaW5nO1xuICBzeXN0ZW1zOiBzdHJpbmc7XG59XG5cbmNsYXNzIERldkVudGl0eTxDVD4ge1xuICBpZDogc3RyaW5nO1xuXG4gIGNvbXBvbmVudHM6IFJlY29yZDxzdHJpbmcsIENUPjtcblxuICB0YWdzOiBUYWdbXTtcblxuICBzeXN0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGVudGl0eTogRW50aXR5PENUPiwgd29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMuaWQgPSBlbnRpdHkuaWQ7XG4gICAgdGhpcy5jb21wb25lbnRzID0gZW50aXR5LmNvbXBvbmVudHMudG9EZXZDb21wb25lbnRzKCksXG4gICAgdGhpcy50YWdzID0gWy4uLmVudGl0eS50YWdzXTtcblxuICAgIGNvbnN0IGNvbXBOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuY29tcG9uZW50cyk7XG5cbiAgICBmb3IgKGNvbnN0IFtzeXN0ZW1OYW1lLCBjTmFtZXNdIG9mIHdvcmxkLnN5c3RlbXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lKSB7XG4gICAgICBpZiAoY05hbWVzLmV2ZXJ5KChjTmFtZSkgPT4gY29tcE5hbWVzLmluY2x1ZGVzKGNOYW1lKSkpIHtcbiAgICAgICAgdGhpcy5zeXN0ZW1zLnB1c2goc3lzdGVtTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdG9UYWJsZVJvdygpOiBEZXZFbnRpdHlUYWJsZVJvdyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgY29tcG9uZW50czogT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRzKS5qb2luKFwiLCBcIiksXG4gICAgICB0YWdzOiB0aGlzLnRhZ3Muam9pbihcIiwgXCIpLFxuICAgICAgc3lzdGVtczogdGhpcy5zeXN0ZW1zLmpvaW4oJywgJyksXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZXZFbnRpdHk7XG4iLCJleHBvcnQgdHlwZSBTdGF0ZSA9IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbDtcblxuZXhwb3J0IHR5cGUgVHJhbnNpdGlvbnM8UyBleHRlbmRzIFN0YXRlLCBEID0gdW5kZWZpbmVkPiA9IFJlY29yZDxcbiAgUyxcbiAgKGRhdGE6IEQsIGN1cnJlbnQ6IFMpID0+IFNcbj47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpbXBsZUZTTTxTIGV4dGVuZHMgU3RhdGUsIEQgPSB1bmRlZmluZWQ+IHtcbiAgY3VycmVudDogUztcblxuICBpbml0YWw6IFM7XG5cbiAgdHJhbnNpdGlvbnM6IFRyYW5zaXRpb25zPFMsIEQ+O1xuXG4gIGNvbnN0cnVjdG9yKGluaXRpYWxTdGF0ZTogUywgdHJhbnNpdGlvbnM6IFRyYW5zaXRpb25zPFMsIEQ+KSB7XG4gICAgdGhpcy5pbml0YWwgPSBpbml0aWFsU3RhdGU7XG4gICAgdGhpcy5jdXJyZW50ID0gaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcbiAgfVxuXG4gIG5leHQoZGF0YTogRCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25zW3RoaXMuY3VycmVudF0pIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMudHJhbnNpdGlvbnNbdGhpcy5jdXJyZW50XShkYXRhLCB0aGlzLmN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuaW5pdGFsO1xuICB9XG5cbiAgaXMoY2hlY2tTdGF0ZTogUyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQgPT09IGNoZWNrU3RhdGU7XG4gIH1cbn1cbiIsImltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgV29ybGQsIHsgQ2xhc3NDb25zdHJ1Y3RvciB9IGZyb20gXCIuL1dvcmxkXCI7XG5pbXBvcnQgQ29tcG9uZW50Q29sbGVjdGlvbiBmcm9tIFwiLi9Db21wb25lbnRDb2xsZWN0aW9uXCI7XG5pbXBvcnQgeyBUYWcgfSBmcm9tIFwiLi9UYWdcIjtcbmltcG9ydCBEZXZFbnRpdHkgZnJvbSBcIi4vRGV2RW50aXR5XCI7XG5cbmltcG9ydCBTaW1wbGVGU00gZnJvbSBcIi4vU2ltcGxlRlNNXCI7XG5cbmV4cG9ydCB0eXBlIEVudGl0eUlkID0gc3RyaW5nO1xuXG50eXBlIEVudGl0eVN0YXRlID1cbiAgfCBcImNyZWF0aW5nXCJcbiAgfCBcImNyZWF0ZWRcIlxuICB8IFwiZGVzdHJveWluZ1wiXG4gIHwgXCJkZXN0cm95ZWRcIlxuICB8IFwiZXJyb3JcIjtcblxuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlDb21wRXZlbnRBcmdzPENUPiB7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG4gIGNvbXBvbmVudDogQ1Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudGl0eTxDVD4ge1xuICBwcml2YXRlIF9pZDogc3RyaW5nO1xuICBwcml2YXRlIF93b3JsZDogV29ybGQ8Q1Q+O1xuXG4gIHByaXZhdGUgX2Vycm9yOiBFcnJvciB8IG51bGw7XG5cbiAgcHJpdmF0ZSBfc3RhdGU6IFNpbXBsZUZTTTxFbnRpdHlTdGF0ZSwgRW50aXR5U3RhdGU+O1xuXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuXG4gIGdldCB3b3JsZCgpOiBXb3JsZDxDVD4ge1xuICAgIHJldHVybiB0aGlzLl93b3JsZDtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpOiBFbnRpdHlTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmN1cnJlbnQ7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih3b3JsZDogV29ybGQ8Q1Q+KSB7XG4gICAgdGhpcy5faWQgPSB1dWlkdjQoKTtcbiAgICB0aGlzLl93b3JsZCA9IHdvcmxkO1xuXG4gICAgdGhpcy5fZXJyb3IgPSBudWxsO1xuXG4gICAgY29uc3QgZnNtVHJhbnNpdGlvbiA9IChcbiAgICAgIG5zOiBFbnRpdHlTdGF0ZVxuICAgICk6IEVudGl0eVN0YXRlID0+IHtcbiAgICAgIGlmIChucyA9PT0gXCJlcnJvclwiIHx8IHRoaXMuX2Vycm9yKSByZXR1cm4gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIG5zO1xuICAgIH07XG5cbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBTaW1wbGVGU008RW50aXR5U3RhdGUsIEVudGl0eVN0YXRlPihcImNyZWF0aW5nXCIsIHtcbiAgICAgIGNyZWF0aW5nOiBmc21UcmFuc2l0aW9uLFxuICAgICAgY3JlYXRlZDogZnNtVHJhbnNpdGlvbixcbiAgICAgIGRlc3Ryb3lpbmc6IGZzbVRyYW5zaXRpb24sXG4gICAgICBkZXN0cm95ZWQ6ICgpID0+IFwiZGVzdHJveWVkXCIsXG4gICAgICBlcnJvcjogKCkgPT4gXCJlcnJvclwiLFxuICAgIH0pO1xuXG4gICAgLypcbiAgICBSZWdpc3RlcmluZyB3aXRoIHRoZSBXb3JsZC5cbiAgICAqL1xuICAgIHRoaXMuX3dvcmxkLnJlZ2lzdGVyRW50aXR5KHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX3dvcmxkLnN5c3RlbXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuX3N0YXRlLm5leHQoJ2NyZWF0ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKiBMaWZlQ3ljbGUgbWV0aG9kcywgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiAqL1xuXG4gIG9uQ3JlYXRlKHdvcmxkOiBXb3JsZDxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25EZXN0cm95KHdvcmxkOiBXb3JsZDxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25Db21wb25lbnRBZGQoYXJnczogRW50aXR5Q29tcEV2ZW50QXJnczxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25UcmFja2VkQ29tcG9uZW50VXBkYXRlKGFyZ3M6IEVudGl0eUNvbXBFdmVudEFyZ3M8Q1Q+KTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIG9uQ29tcG9uZW50UmVtb3ZlKGFyZ3M6IEVudGl0eUNvbXBFdmVudEFyZ3M8Q1Q+KTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBjb21wb25lbnQgdG8gYW4gRW50aXR5LCBkb2guXG4gICAqL1xuICBhZGQ8VCBleHRlbmRzIENUPihjb21wb25lbnQ6IFQpOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5hZGQodGhpcy5faWQsIGNvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0YWcgdG8gYSBjb21wb25lbnRcbiAgICovXG4gIGFkZFRhZyh0YWc6IFRhZyk6IHRoaXMge1xuICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmhhcyh0YWcpXG4gICAgICA/IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpXG4gICAgICA6IG5ldyBTZXQ8RW50aXR5SWQ+KCk7XG5cbiAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICBlbnRpdHlTZXQuYWRkKHRoaXMuX2lkKTtcbiAgICAgIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLnNldCh0YWcsIGVudGl0eVNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhbiBlbnRpdHkgaGFzIGEgY29tcG9uZW50IHJlbGF0ZWQgdG8gaXQuXG4gICAqL1xuICBoYXM8VCBleHRlbmRzIENUPihjVHlwZTogQ2xhc3NDb25zdHJ1Y3RvcjxUPik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHxcbiAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgcmV0dXJuIGNjLmhhcyhjVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIGFuIGVudGl0eSB0YWdnZWQgd2l0aCBhIGdpdmVuIHRhZy5cbiAgICovXG4gIGhhc1RhZyh0YWc6IFRhZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5oYXModGFnKSkge1xuICAgICAgY29uc3QgZW50aXR5U2V0ID0gdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZyk7XG4gICAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICAgIHJldHVybiBlbnRpdHlTZXQuaGFzKHRoaXMuX2lkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgY29tcG9uZW50IHRoYXQgYmVsb25ncyB0byBhbiBlbnRpdHkuXG4gICAqL1xuICBnZXQ8VCBleHRlbmRzIENUPihjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPik6IFQge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHxcbiAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvblxuICAgKi9cbiAgZ2V0QWxsKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNvbXBvbmVudCBmcm9tIGFuIGVudGl0eS5cbiAgICogQHBhcmFtIGNUeXBlIEEgY29tcG9uZW50IGNsYXNzLCBlZyBNeUNvbXBvbmVudFxuICAgKi9cbiAgcmVtb3ZlKGNUeXBlOiBDbGFzc0NvbnN0cnVjdG9yPENUPik6IHRoaXMge1xuICAgIHRoaXMuX3dvcmxkLnJlbW92ZSh0aGlzLl9pZCwgY1R5cGUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdGFnIGZyb20gYW4gZW50aXR5XG4gICAqL1xuICByZW1vdmVUYWcodGFnOiBUYWcpOiB0aGlzIHtcbiAgICBpZiAodGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuaGFzKHRhZykpIHtcbiAgICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICAgIGlmIChlbnRpdHlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENsZWFycyBhbGwgY29tcG9uZW50cyBmcm9tIGFuIEVudGl0eSAqL1xuICBjbGVhcigpOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5jbGVhckVudGl0eUNvbXBvbmVudHModGhpcy5faWQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0YWdzIG9uIGFuIGVudGl0eVxuICAgKi9cbiAgY2xlYXJUYWdzKCk6IHRoaXMge1xuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5lbnRyaWVzKCkpIHtcbiAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICBpZiAoZW50aXR5U2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGVudGl0eSB0byAnY3JlYXRlZCcuIHRoYXQncyBpdC5cbiAgICovXG4gIGZpbmlzaENyZWF0aW9uKCk6IHZvaWQge1xuICAgIHRoaXMuX3N0YXRlLm5leHQoJ2NyZWF0ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IGFuIGVudGl0eS4gQWN0dWFsIGRlc3RydWN0aW9uIGlzIGRlZmVycmVkIHVudGlsIGFmdGVyIHRoZSBuZXh0IHBhc3Mgb2Ygc3lzdGVtcy5cbiAgICogVGhpcyBnaXZlcyB0aGUgc3lzdGVtcyBhIGNoYW5jZSB0byBkbyBhbnkgY2xlYW51cCB0aGF0IG1pZ2h0IGJlIG5lZWRlZC5cbiAgICovXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gSWYgbm8gc3lzdGVtcyBhcmUgYWRkZWQsIHRoZSBkZXN0cm95IGltbWVkaWF0ZWx5LlxuICAgIGlmICh0aGlzLl93b3JsZC5zeXN0ZW1zLmNvbXBOYW1lc0J5U3lzdGVtTmFtZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lJbW1lZGlhdGVseSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1hcmsgYXMgXCJkZXN0cm95aW5nXCIgc28gdGhhdCBzeXN0ZW1zIGNhbiBhY3Qgb24gaXQgYmVmb3JlIGFjdHVhbGx5IGJlaW5nIGRlc3Ryb3llZC5cbiAgICB0aGlzLl9zdGF0ZS5uZXh0KCdkZXN0cm95aW5nJyk7XG4gIH1cblxuICBkZXN0cm95SW1tZWRpYXRlbHkoKTogdm9pZCB7XG4gICAgLy8gUmlnaHQgbm93IGNhbGxpbmcgYmVmb3JlIHRoZSBhY3R1YWwgZGVzdG9yeWluZyBvZiB0aGUgZW50aXR5LlxuICAgIC8vIE1pZ2h0IHdhbnQgdG8gY2hhbmdlIHRoaXMgdG8gcG9zdCBkZXN0cnVjdGlvbiBpbiB0aGUgZnV0dXJlLCB3aG8ga25vd3MuXG4gICAgdGhpcy5vbkRlc3Ryb3kodGhpcy5fd29ybGQpO1xuXG4gICAgLy8gQWN0dWFsbHkgZGVzdHJveSBlbnRpdHkuXG4gICAgdGhpcy5fd29ybGQuZGVzdHJveUVudGl0eSh0aGlzLl9pZCk7IC8vIHNob3VsZCByZXR1cm4gYW4gZXJyb3I/P1xuXG4gICAgdGhpcy5fc3RhdGUubmV4dCgnZGVzdHJveWVkJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvbi5cbiAgICogRG9lcyB0aGUgc2FtZSB0aGluZyBhcyBlbnRpdHlJbnN0YW5jZS5nZXRBbGwoKS5cbiAgICovXG4gIGdldCBjb21wb25lbnRzKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgdGhlIHRhZ3MgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhpcyBlbnRpdHkuXG4gICAqL1xuICBnZXQgdGFncygpOiBTZXQ8VGFnPiB7XG4gICAgY29uc3QgdGFncyA9IG5ldyBTZXQ8VGFnPigpO1xuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKHRoaXMuX2lkKSkge1xuICAgICAgICB0YWdzLmFkZCh0YWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YWdzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgRW50aXR5IHRvIGEgRGV2RW50aXR5LiBWZXJ5IGhlbHBmdWwgaW4gZm9yIGRlYnVnZ2luZy5cbiAgICovXG4gIHRvRGV2RW50aXR5KCk6IERldkVudGl0eTxDVD4ge1xuICAgIHJldHVybiBuZXcgRGV2RW50aXR5PENUPih0aGlzLCB0aGlzLl93b3JsZCk7XG4gIH1cbn1cbiIsImltcG9ydCBXb3JsZCBmcm9tICcuL1dvcmxkJztcbmltcG9ydCBEZXZFbnRpdHkgZnJvbSAnLi9EZXZFbnRpdHknO1xuXG5pbnRlcmZhY2UgRGV2U3lzdGVtQ29tcHMge1xuICBzeXN0ZW06IHN0cmluZztcbiAgY29tcG9uZW50czogc3RyaW5nO1xufVxuXG5cbmNsYXNzIERldlRvb2xzPENUPiB7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgfVxuICAvKipcbiAgICogZGlzcGxheSB0aGUgYWxsIHN5c3RlbXMgb2YgdGhlIHdvcmxkLCBhbmQgdGhlIGNvbXBvbmVudHMgcmVxdWlyZWQgYnkgZWFjaCBzeXN0ZW0uXG4gICAqIFN1cGVyIGhlbHBmdWwgdG8gdXNlIHdpdGggY29uc29sZS50YWJsZSgpXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zb2xlLnRhYmxlKHdvcmxkLmRldi5zeXN0ZW1Db21wb25lbnRzKTtcbiAgICogYGBgXG4gICAqL1xuICBnZXQgc3lzdGVtQ29tcG9uZW50cygpOiBEZXZTeXN0ZW1Db21wc1tdIHtcbiAgICBjb25zdCBjb21wc0J5U3lzdGVtcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBbc3lzdGVtLCBjb21wTmFtZXNdIG9mIHRoaXMud29ybGQuc3lzdGVtcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUpIHtcbiAgICAgIGNvbXBzQnlTeXN0ZW1zLnB1c2goeyBzeXN0ZW0sIGNvbXBvbmVudHM6IGNvbXBOYW1lcy5qb2luKFwiLCBcIikgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBzQnlTeXN0ZW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhcnJheSBvZiBEZXZFbnRpdGVzLiBDYW4gYmUgdmVyeSBoZWxwZnVsIGZvciB0aGluZ3MgbGlrZSBpbnNwZWN0aW5nIGNvbXBvbmVudCBzdGF0ZSxcbiAgICogYW5kIHdoaWNoIHN5c3RlbXMgd2lsbCBiZSBjYWxsZWQgb24gYW4gZW50aXR5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMpO1xuICAgKlxuICAgKiAvLyBQcm8gdGlwISB0cnkgZGlzcGxheWluZyBhIHRhYmxlIG9mIGVudGl0aWVzIHdpdGggY29uc29sZS50YWJsZSBhbmQgRGV2RW50aXR5LnRvVGFibGVSb3coKS5cbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMubWFwKGRldkVudGl0eSA9PiBkZXZFbnRpdHkudG9UYWJsZVJvdygpKSk7XG4gICAqIGBgYFxuICAgKi9cblxuICBnZXQgZW50aXRpZXMoKTogRGV2RW50aXR5PENUPltdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMud29ybGQuZW50aXRpZXMudmFsdWVzKCldLm1hcCgoZSkgPT4gZS50b0RldkVudGl0eSgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZXZUb29scztcbiIsImltcG9ydCBFbnRpdHksIHsgRW50aXR5SWQgfSBmcm9tIFwiLi9FbnRpdHlcIjtcbmltcG9ydCBXb3JsZCwgeyBDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSBcIi4vV29ybGRcIjtcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gXCIuL0NvbXBvbmVudENvbGxlY3Rpb25cIjtcblxuLyoqXG4gKiBBcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIGludG8gYSBTeXN0ZW0gZnVuY3Rpb24gb24gZWFjaCBpdGVyYXRpb24uXG4gKiBUaGlzIGlzIGhvdyB5b3UgYWNjZXMgdGhpbmdzIGxpa2UgdGhlIGVudGl0eSB0aGF0IHBhcnRpY3VsYXIgZW50aXR5IHRvIGFjdCBvbixcbiAqIGFzIHdlbGwgYXMgc29tZSBvdGhlciBoZWxwZnVsIHBhcmFtcyBsaWtlIGlmIHRoZSBlbnRpdHkgaXMgdGhlIGZpcnN0IG9yIGxhc3QgZW50aXR5XG4gKiBpbiB0aGUgZ3JvdXAgb2YgZW50aXRpZXMgdGhhdCBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5c3RlbUZ1bmNBcmdzPENUPiB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBlbnRpdHkgYmVpbmcgaXRlcmF0ZWQuXG4gICAqL1xuICBlbnRpdHk6IEVudGl0eTxDVD47XG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB0aGF0IGJlbG9uZyB0byB0aGUgZW50aXR5XG4gICAqL1xuICBjb21wb25lbnRzOiBDb21wb25lbnRDb2xsZWN0aW9uPENUPjtcbiAgLyoqXG4gICAqIFRoZSBXb3JsZCBpbnN0YW5jZS5cbiAgICogVXNlIHRoaXMgdG8gYWNjZXNzIG90aGVyIGVudGl0aWVzLlxuICAgKi9cbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICAvKipcbiAgICogSXMgdGhlIGZpcnN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogSGVscGZ1bCBmb3Igc2V0dGluZyB1cCBzdGF0ZSB0aGF0IGlzIHRoZSBzYW1lIGZvciBhbGwgZW50aXRpZXMgb25seSBvbmNlLlxuICAgKi9cbiAgaXNGaXJzdDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIElzIHRoZSBsYXN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogQ2FuIGJlIGhlbHBmdWwgdG8gdGVhciBkb3duIGFueXRoaW5nIHRoYXQgc2hvdWxkIGJlIGRlYWx0IHdpdGggYWZ0ZXIgYWxsIHRoZSBlbnRpdGVzIGhhdmUgcmFuLlxuICAgKi9cbiAgaXNMYXN0OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBzeXN0ZW0gaXMgcnVuLlxuICovXG5leHBvcnQgdHlwZSBTeXN0ZW1GdW5jPENUPiA9IChcbiAgc3l0ZW1GdW5jQXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+XG4pID0+IHZvaWQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbXM8Q1Q+IHtcbiAgd29ybGQ6IFdvcmxkPENUPjtcblxuICBzeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lOiBNYXA8c3RyaW5nLCBTeXN0ZW1GdW5jPENUPj47IC8vIGRvdWJsZSBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBtYXBzIGFyZSBvcmRlcmVkLlxuXG4gIGNvbXBOYW1lc0J5U3lzdGVtTmFtZTogTWFwPHN0cmluZywgc3RyaW5nW10+O1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZDxDVD4pIHtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5zeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgYWRkKGNUeXBlczogQ2xhc3NDb25zdHJ1Y3RvcjxDVD5bXSwgc3lzdGVtRnVuYzogU3lzdGVtRnVuYzxDVD4sIGZ1bmNOYW1lPzogc3RyaW5nKTogdGhpcyB7XG4gICAgY29uc3QgY05hbWVzID0gY1R5cGVzLm1hcCgoY3QpID0+IGN0Lm5hbWUpO1xuXG4gICAgXG4gICAgbGV0IG5hbWUgPSBzeXN0ZW1GdW5jLm5hbWU7XG4gICAgaWYgKHN5c3RlbUZ1bmMubmFtZSA9PT0gJycpIHtcbiAgICAgIC8vIFN1cGVyIGJydXRlIGZvcmNlLCBhbmQgbWlnaHQgbGVhZCB0byBlcnJvcnMgaW4gdGhlIGZ1dHVyZSwgYnV0IGZvciBub3dcbiAgICAgIC8vIHVzaW5nIHRoZSBzdHJpbmdpZmllZCBzeXN0ZW0gZnVuY3Rpb24gaWYgdGhlIGZ1bmN0aW9uIGRvZXNuJ3QgYWxyZWFkeSBoYXZlIGEgbmFtZS5cbiAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIHVzZWQgYXMgYSBzeXN0ZW0gZnVuY3Rpb24uXG4gICAgICAvLyBNaWdodCBiZSBnb29kIHRvIGZpZ3VyZSBvdXQgaG93IHRvIGdldCBhIGhhc2ggb2YgdGhlIGZ1bmN0aW9uIHN0cmluZy5cbiAgICAgIG5hbWUgPSBzeXN0ZW1GdW5jLnRvU3RyaW5nKCkuc2xpY2UoMCwgMzApO1xuICAgIH1cblxuICAgIGlmIChmdW5jTmFtZSkge1xuICAgICAgbmFtZSA9IGZ1bmNOYW1lO1xuICAgIH1cblxuICAgIHRoaXMuc3lzdGVtRnVuY0J5U3lzdGVtTmFtZS5zZXQobmFtZSwgc3lzdGVtRnVuYyk7XG4gICAgdGhpcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUuc2V0KG5hbWUsIGNOYW1lcyk7XG4gICAgdGhpcy53b3JsZC5lbnRpdGllc0J5Q1R5cGVzLnNldChjTmFtZXMsIG5ldyBTZXQ8RW50aXR5SWQ+KCkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBydW4oKTogdm9pZCB7XG5cbiAgICAvLyBUT0RPOiBNaWdodCBiZSBjb29sIHRvIGFkZCBhIHdheSB0byBzdG9wIHRoZSBzeXN0ZW1zIGxvb3Agd2hlbiBpbiBkZXYuXG4gICAgLy8gICAgICAgTWF5YmUgc29tZXRoaW5nIGxpa2Ugd29ybGQuZGV2LnN0b3AoKSBvciBwYXVzZSgpLlxuICAgIGZvciAoY29uc3QgW1xuICAgICAgZnVuY05hbWUsXG4gICAgICBzeXN0ZW1GdW5jLFxuICAgIF0gb2YgdGhpcy5zeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lLmVudHJpZXMoKSkge1xuICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLndvcmxkLmVudGl0aWVzQnlDVHlwZXMuc2l6ZTtcbiAgICAgIGNvbnN0IGNOYW1lcyA9IHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lLmdldChmdW5jTmFtZSkgfHwgW107XG4gICAgICBjb25zdCBjVHlwZUFycnMgPSB0aGlzLndvcmxkLmVudGl0aWVzQnlDVHlwZXMuZ2V0KGNOYW1lcykgfHwgbmV3IFNldCgpO1xuXG4gICAgICBjb25zdCBlbnRpdGllc0luQ3JlYXRpbmdTdGF0ZSA9IFtdO1xuICAgICAgY29uc3QgZW50aXRpZXNJbkRlc3Ryb3lpbmdTdGF0ZSA9IFtdXG5cbiAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMud29ybGQuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKGVudGl0eS5zdGF0ZSA9PT0gJ2NyZWF0aW5nJykge1xuICAgICAgICAgIGVudGl0aWVzSW5DcmVhdGluZ1N0YXRlLnB1c2goZW50aXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRpdHkuc3RhdGUgPT09ICdkZXN0cm95aW5nJykge1xuICAgICAgICAgIGVudGl0aWVzSW5EZXN0cm95aW5nU3RhdGUucHVzaChlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgZm9yIChjb25zdCBlaWQgb2YgY1R5cGVBcnJzKSB7XG4gICAgICAgIGNvbnN0IGFyZ3M6IFN5c3RlbUZ1bmNBcmdzPENUPiA9IHtcbiAgICAgICAgICBlbnRpdHk6IHRoaXMud29ybGQuZW50aXRpZXMuZ2V0KGVpZCkgfHwgbmV3IEVudGl0eTxDVD4odGhpcy53b3JsZCksXG4gICAgICAgICAgY29tcG9uZW50czpcbiAgICAgICAgICAgIHRoaXMud29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHxcbiAgICAgICAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpLFxuICAgICAgICAgIHdvcmxkOiB0aGlzLndvcmxkLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgaXNGaXJzdDogaW5kZXggPT09IDAsXG4gICAgICAgICAgaXNMYXN0OiBpbmRleCArIDEgPT09IHNpemUsXG4gICAgICAgIH07XG5cbiAgICAgICAgc3lzdGVtRnVuYyhhcmdzKTtcblxuICAgICAgICBpbmRleCArPSAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllc0luQ3JlYXRpbmdTdGF0ZSkge1xuICAgICAgICBlbnRpdHkuZmluaXNoQ3JlYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzSW5EZXN0cm95aW5nU3RhdGUpIHtcbiAgICAgICAgZW50aXR5LmRlc3Ryb3lJbW1lZGlhdGVseSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IFdvcmxkLCB7IENsYXNzQ29uc3RydWN0b3IgfSBmcm9tIFwiLi9Xb3JsZFwiO1xuaW1wb3J0IEVudGl0eSBmcm9tIFwiLi9FbnRpdHlcIjtcblxuLy8gV2FpdGluZyBmb3IgVHlwZXNjcmlwdCA0LjIgdG8gY29tZSBvdXQgc28gdGhhdCBTeW1ib2xzIGFyZSBzdXBwb3JkZWQga2V5cy5cbmV4cG9ydCBjb25zdCBUcmFja2VkQ29tcFN5bWJvbEtleXMgPSB7XG4gIGlzVHJhY2tlZDogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50LmlzVHJhY2tlZFwiKSxcbiAgd29ybGQ6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC53b3JsZFwiKSxcbiAgc2V0V29ybGQ6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5zZXRXb3JsZFwiKSxcbiAgb25BZGQ6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5vbkFkZFwiKSxcbiAgb25VcGRhdGU6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5vblVwZGF0ZVwiKSxcbiAgb25SZW1vdmU6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5vblJlbW92ZVwiKSxcbn0gYXMgY29uc3Q7XG5cbi8vQHRzLWlnbm9yZVxudHlwZSBUcmFja2VkQ29tcG9uZW50PENUPiA9IHtcbiAgbmV3ICguLi5hcmdzOiBhbnlbXSk6IENUO1xuXG4gIC8vQHRzLWlnbm9yZVxuICBbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmlzVHJhY2tlZF06IGJvb2xlYW47XG4gIC8vQHRzLWlnbm9yZVxuICBbVHJhY2tlZENvbXBTeW1ib2xLZXlzLnNldFdvcmxkXTogKHdvcmxkOiBXb3JsZDxDVD4pID0+IHZvaWQ7XG4gIC8vQHRzLWlnbm9yZVxuICBbVHJhY2tlZENvbXBTeW1ib2xLZXlzLndvcmxkXTogV29ybGQ8Q1Q+O1xuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vbkFkZF06IChcbiAgICB3b3JsZDogV29ybGQ8Q1Q+LFxuICAgIGVudGl0eTogRW50aXR5PENUPlxuICApID0+IHZvaWQ7XG4gIC8vQHRzLWlnbm9yZVxuICBbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uUmVtb3ZlXTogKFxuICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgZW50aXR5OiBFbnRpdHk8Q1Q+XG4gICkgPT4gdm9pZDtcbn07XG5cbmludGVyZmFjZSBBZGRFdmVudEFyZ3M8Q1Q+IHtcbiAgY29tcG9uZW50OiBDVDtcbiAgZW50aXR5OiBFbnRpdHk8Q1Q+O1xuICB3b3JsZDogV29ybGQ8Q1Q+O1xufVxuXG5pbnRlcmZhY2UgVXBkYXRlRXZlbnRBcmdzPENUPiB7XG4gIGNvbXBvbmVudDogQ1Q7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG4gIHByZXZpb3VzVmFsOiBDVFtrZXlvZiBDVF07XG4gIHByb3BlcnR5OiBrZXlvZiBDVDtcbn1cblxuaW50ZXJmYWNlIFJlbW92ZUV2ZW50QXJnczxDVD4ge1xuICBjb21wb25lbnQ6IENUO1xuICBlbnRpdHk6IEVudGl0eTxDVD47XG4gIHdvcmxkOiBXb3JsZDxDVD47XG59XG5cbmludGVyZmFjZSBUcmFja2VkRXZlbnRIYW5kbGVyczxDVD4ge1xuICBvbkFkZD86IChhcmdzOiBBZGRFdmVudEFyZ3M8Q1Q+KSA9PiB2b2lkO1xuICBvblVwZGF0ZT86IChhcmdzOiBVcGRhdGVFdmVudEFyZ3M8Q1Q+KSA9PiB2b2lkO1xuICBvblJlbW92ZT86IChhcmdzOiBSZW1vdmVFdmVudEFyZ3M8Q1Q+KSA9PiB2b2lkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0luc3RhbmNlUHJveHlIYW5kbGVyczxDVD4oXG4gIHRyYWNrZWRFdmVudEhhbmRsZXJzOiBUcmFja2VkRXZlbnRIYW5kbGVyczxDVD5cbik6IFByb3h5SGFuZGxlcjxhbnk+IHtcbiAgY29uc3QgdXBkYXRlZFByb3BzID0gbmV3IFNldCgpO1xuICByZXR1cm4ge1xuICAgIHNldChcbiAgICAgIGNvbXBvbmVudDogQ1QsXG4gICAgICBwcm9wZXJ0eToga2V5b2YgQ1QsXG4gICAgICB2YWx1ZTogQ1Rba2V5b2YgQ1RdXG4gICAgKSB7XG4gICAgICB1cGRhdGVkUHJvcHMuYWRkKHByb3BlcnR5KTtcblxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb25zdCB3b3JsZCA9IGNvbXBvbmVudFtcbiAgICAgICAgVHJhY2tlZENvbXBTeW1ib2xLZXlzLndvcmxkXG4gICAgICBdIGFzIFdvcmxkPENUPjtcblxuICAgICAgY29uc3QgcHJldmlvdXNWYWwgPSBjb21wb25lbnRbcHJvcGVydHldO1xuXG4gICAgICBjb21wb25lbnRbcHJvcGVydHldID0gdmFsdWU7XG5cbiAgICAgIGlmICh0cmFja2VkRXZlbnRIYW5kbGVycy5vblVwZGF0ZSkge1xuICAgICAgICB0cmFja2VkRXZlbnRIYW5kbGVycy5vblVwZGF0ZSh7XG4gICAgICAgICAgd29ybGQsXG4gICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgIHByZXZpb3VzVmFsLFxuICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrQ29tcG9uZW50PENUPihcbiAgQ29tcENsYXNzOiBDbGFzc0NvbnN0cnVjdG9yPENUPixcbiAgdHJhY2tlZEV2ZW50SGFuZGxlcnM6IFRyYWNrZWRFdmVudEhhbmRsZXJzPENUPlxuKTogVHJhY2tlZENvbXBvbmVudDxDVD4ge1xuICByZXR1cm4gbmV3IFByb3h5KENvbXBDbGFzcywge1xuICAgIGNvbnN0cnVjdChDb21wb25lbnQ6IGFueSwgYXJnczogYW55KSB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KC4uLmFyZ3MpIGFzIENUICYgVHJhY2tlZENvbXBvbmVudDxDVD47XG4gICAgICAvLyBjb25zdCBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KC4uLmFyZ3MpIGFzIFQgJiBUcmFja2VkQ29tcG9uZW50PENsYXNzPFQ+PjtcbiAgICAgIC8vIGNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoLi4uYXJncykgYXMgSW5zdGFuY2VUeXBlPENsYXNzPFQ+PjtcblxuICAgICAgLy8gRm9yIHVzZSBpbiBpZGVudGlmaW5nIGEgXCJ0cmFja2VkXCIgY2xhc3MgdGhyb3VnaCB0aGUgcHJveHkuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMuaXNUcmFja2VkXSA9IHRydWU7XG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5zZXRXb3JsZF0gPSAoXG4gICAgICAgIHdvcmxkOiBXb3JsZDxDVD5cbiAgICAgICkgPT4ge1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy53b3JsZF0gPSB3b3JsZDtcbiAgICAgIH07XG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vbkFkZF0gPSAoXG4gICAgICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgICAgIGVudGl0eTogRW50aXR5PENUPlxuICAgICAgKSA9PiB7XG4gICAgICAgIGlmICh0cmFja2VkRXZlbnRIYW5kbGVycy5vbkFkZCkge1xuICAgICAgICAgIHRyYWNrZWRFdmVudEhhbmRsZXJzLm9uQWRkKHsgY29tcG9uZW50LCB3b3JsZCwgZW50aXR5IH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMub25SZW1vdmVdID0gKFxuICAgICAgICB3b3JsZDogV29ybGQ8Q1Q+LFxuICAgICAgICBlbnRpdHk6IEVudGl0eTxDVD5cbiAgICAgICkgPT4ge1xuICAgICAgICBpZiAodHJhY2tlZEV2ZW50SGFuZGxlcnMub25SZW1vdmUpIHtcbiAgICAgICAgICB0cmFja2VkRXZlbnRIYW5kbGVycy5vblJlbW92ZSh7IGNvbXBvbmVudCwgd29ybGQsIGVudGl0eSB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm94eShcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICBjcmVhdGVDbGFzc0luc3RhbmNlUHJveHlIYW5kbGVycyh0cmFja2VkRXZlbnRIYW5kbGVycylcbiAgICAgICk7XG4gICAgfSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgRW50aXR5LCB7IEVudGl0eUlkIH0gZnJvbSBcIi4vRW50aXR5XCI7XG5pbXBvcnQgQ29tcG9uZW50Q29sbGVjdGlvbiBmcm9tIFwiLi9Db21wb25lbnRDb2xsZWN0aW9uXCI7XG5pbXBvcnQgeyBUYWcgfSBmcm9tIFwiLi9UYWdcIjtcbmltcG9ydCB7IFN5c3RlbUZ1bmMgfSBmcm9tIFwiLi9TeXN0ZW1zXCI7XG5pbXBvcnQgRGV2VG9vbHMgZnJvbSBcIi4vRGV2VG9vbHNcIjtcbmltcG9ydCBTeXN0ZW1zIGZyb20gJy4vU3lzdGVtcyc7XG5pbXBvcnQgeyBUcmFja2VkQ29tcFN5bWJvbEtleXMgfSBmcm9tICcuL1RyYWNrZWRDb21wb25lbnQnO1xuXG5leHBvcnQgdHlwZSBDbGFzc0NvbnN0cnVjdG9yPFQ+ID0geyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVCB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JsZDxDVD4ge1xuICBjb21wb25lbnRDb2xsZWN0aW9uczogTWFwPEVudGl0eUlkLCBDb21wb25lbnRDb2xsZWN0aW9uPENUPj4gPSBuZXcgTWFwKCk7XG5cbiAgZW50aXRpZXM6IE1hcDxFbnRpdHlJZCwgRW50aXR5PENUPj4gPSBuZXcgTWFwKCk7XG5cbiAgZW50aXRpZXNCeUNUeXBlczogTWFwPHN0cmluZ1tdLCBTZXQ8RW50aXR5SWQ+PiA9IG5ldyBNYXAoKTtcblxuICBlbnRpdGllc0J5VGFnczogTWFwPFRhZywgU2V0PEVudGl0eUlkPj4gPSBuZXcgTWFwKCk7XG5cbiAgc3lzdGVtczogU3lzdGVtczxDVD47XG5cbiAgZGV2OiBEZXZUb29sczxDVD47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kZXYgPSBuZXcgRGV2VG9vbHModGhpcyk7XG4gICAgdGhpcy5zeXN0ZW1zID0gbmV3IFN5c3RlbXModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogXCJmaW5kc1wiIGEgc2luZ2xlIGVudGl0eSBiYXNlZCBvbiBhIHByZWRpY2F0ZVxuICAgKi9cbiAgZmluZCA9IChwcmVkaWNhdGU6IChlbnRpdHk6IEVudGl0eTxDVD4pID0+IGJvb2xlYW4pOiBFbnRpdHk8Q1Q+IHwgbnVsbCA9PiB7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShlbnRpdHkpKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFwiZmluZHNcIiBhbGwgZW50aXRpZXMgYmFzZWQgb24gYSBwcmVkaWNhdGUsIGtpbmRhIGxpa2UgZmlsdGVyLlxuICAgKi9cbiAgZmluZEFsbCA9IChwcmVkaWNhdGU6IChlbnRpdHk6IEVudGl0eTxDVD4pID0+IGJvb2xlYW4pOiBFbnRpdHk8Q1Q+W10gPT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6IEVudGl0eTxDVD5bXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShlbnRpdHkpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBcImxvY2F0ZXNcIiBhIHNpbmdsZSBlbnRpdHkgYmFzZWQgb24gaXRzIENvbXBvbmVudHMuXG4gICAqL1xuICBsb2NhdGUgPSAoY2w6IENsYXNzQ29uc3RydWN0b3I8Q1Q+IHwgQ2xhc3NDb25zdHJ1Y3RvcjxDVD5bXSk6IEVudGl0eTxDVD4gfCBudWxsID0+IHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZW50aXR5LmNvbXBvbmVudHMuaGFzKGNsKSkge1xuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2NhdGVzIGFsbCBlbnRpdGllcyB0aGF0IGNvbnRhaW4gdGhlIGNvbXBvbmVudHMgbmFtZWRcbiAgICovXG4gIGxvY2F0ZUFsbCA9IChjbDogQ2xhc3NDb25zdHJ1Y3RvcjxDVD4gfCBDbGFzc0NvbnN0cnVjdG9yPENUPltdKTogRW50aXR5PENUPltdID0+IHtcbiAgICBjb25zdCByZXN1bHRzOiBFbnRpdHk8Q1Q+W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHkuY29tcG9uZW50cy5oYXMoY2wpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHcmFicyB0aGUgZmlyc3QgZW50aXR5LCBhbmQgaXRzIHJlbGF0ZWQgY29tcG9uZW50LCB0aGF0IG1hdGNoZXMgdGhlIGNvbXBvbmVudCB0eXBlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc3QgeyBlbnRpdHksIGNvbXBvbmVudCB9ID0gd29ybGQuZ3JhYihNeUNvbXBvbmVudCk7XG4gICAqIGBgYFxuICAgKi9cbiAgZ3JhYiA9IDxUIGV4dGVuZHMgQ1Q+KFxuICAgIGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+XG4gICk6IHsgZW50aXR5OiBFbnRpdHk8Q1Q+OyBjb21wb25lbnQ6IFQgfSB8IG51bGwgPT4ge1xuICAgIGNvbnN0IGVudGl0eSA9IHRoaXMubG9jYXRlKGNsKTtcblxuICAgIGlmIChlbnRpdHkpIHtcbiAgICAgIGNvbnN0IGNjID1cbiAgICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZW50aXR5LmlkKSB8fFxuICAgICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW50aXR5LFxuICAgICAgICBjb21wb25lbnQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHcmFiIHNpbmdsZSBjb21wb25lbnQgYmFzZWQgb24gY29tcG9uZW50IHR5cGUgYW5kIHByZWRpY2F0ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCB7IGVudGl0eSwgY29tcG9uZW50IH0gPSB3b3JsZC5ncmFiQnkoRmlyc3RDb21wb25lbnQsIChjb21wKSA9PiBjb21wLmlkID09ICdhd2Vzb21lJylcbiAgICogYGBgXG4gICAqL1xuICBncmFiQnkgPSA8VCBleHRlbmRzIENUPihcbiAgICBjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPixcbiAgICBwcmVkaWNhdGU6IChjb21wOiBUKSA9PiBib29sZWFuXG4gICk6IHsgZW50aXR5OiBFbnRpdHk8Q1Q+OyBjb21wb25lbnQ6IFQgfSB8IG51bGwgPT4ge1xuICAgIGNvbnN0IGVudGl0aWVzID0gdGhpcy5sb2NhdGVBbGwoY2wpO1xuICAgIC8vIGNvbnN0IGVudGl0aWVzID0gdGhpcy5sb2NhdGVBbGwoKGNsIGFzIHVua25vd24pIGFzIENUKTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCBjYyA9XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVudGl0eS5pZCkgfHxcbiAgICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNjLmdldDxUPihjbCk7XG5cbiAgICAgIGlmIChwcmVkaWNhdGUoY29tcG9uZW50KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICBlbnRpdHksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdyYWIgYWxsIHRoZSBjb21wb25lbnRzIHByaW1hcmlseSwgYW5kIHRoZSBlbnRpdGllcyBpZiBuZWVkZWRcbiAgICovXG4gIGdyYWJBbGwgPSA8VCBleHRlbmRzIENUPihcbiAgICBjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPlxuICApOiB7IGVudGl0eTogRW50aXR5PENUPjsgY29tcG9uZW50OiBUIH1bXSA9PiB7XG4gICAgY29uc3QgZW50aXRpZXMgPSB0aGlzLmxvY2F0ZUFsbChjbCk7XG5cbiAgICByZXR1cm4gZW50aXRpZXMubWFwKChlbnRpdHkpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudGl0eSxcbiAgICAgICAgY29tcG9uZW50OiBlbnRpdHkuY29tcG9uZW50cy5nZXQ8VD4oY2wpLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPOiBBZGQgZ3JhYkFsbEJ5IG1ldGhvZFxuXG4gIC8qKlxuICAgKiBHaXZlbiBhbiBlbnRpdHkgaWQgYW5kIGNvbXBvbmVudFR5cGUsIHJldHVybnMgY29tcG9uZW50XG4gICAqL1xuICBnZXQgPSA8VCBleHRlbmRzIENUPihlaWQ6IEVudGl0eUlkLCBjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPik6IFQgPT4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICByZXR1cm4gY2MuZ2V0PFQ+KGNsKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhbmQgZ2V0IHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCwgd2l0aG91dCBhbnkgYXNzb2NpYXRlZCBlbnRpdGllcy5cbiAgICogSGVscGZ1bCBpcyB5b3Uga25vdyB0aGF0IG9ubHkgb25lIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IGV4aXN0cyBhY3Jvc3MgYWxsIGVudGl0aWVzLlxuICAgKiBAcGFyYW0gY2wgQ29tcG9uZW50IENsYXNzIENvbnRydWN0b3JcbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBIGRlZmF1bHQgY29tcG9uZW50IGluc3RhbmNlIGlmIG5vIGNvbXBvbmVudHMgYXJlIGZvdW5kLlxuICAgKi9cbiAgZ2V0Q29tcG9uZW50ID0gPFQgZXh0ZW5kcyBDVD4oXG4gICAgY2w6IENsYXNzQ29uc3RydWN0b3I8VD4sXG4gICAgZGVmYXVsdFZhbHVlPzogVFxuICApOiBUIHwgbnVsbCA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5ncmFiKGNsKTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0LmNvbXBvbmVudDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIGVudGl0eSB0aGF0IGhhcyBiZWVuIHRhZ2dlZCB3aXRoIHRoZSBnaXZlbiB0YWcsIG9yIHJldHVybiBudWxsO1xuICAgKi9cbiAgZ2V0VGFnZ2VkID0gKHRhZzogVGFnKTogRW50aXR5PENUPiB8IG51bGwgPT4ge1xuICAgIGNvbnN0IHRhZ0VudGl0eUlkcyA9IHRoaXMuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZyk7XG5cbiAgICBpZiAodGFnRW50aXR5SWRzKSB7XG4gICAgICBjb25zdCBlbnRpdHlJZCA9IHRhZ0VudGl0eUlkcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG5cbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcblxuICAgICAgaWYgKGVudGl0eSkge1xuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXR0IGFsbCBlbnRpdGllcyB0aGF0IGhhdmUgYmVlbiB0YWdnZWQgd2l0aCB0aGUgZ2l2ZW4gdGFnLlxuICAgKiBAcGFyYW0gdGFnIEEgc3RyaW5nIG9yIG51bWJlci5cbiAgICovXG4gIGdldEFsbFRhZ2dlZCA9ICh0YWc6IFRhZyk6IEVudGl0eTxDVD5bXSA9PiB7XG4gICAgbGV0IGVudGl0aWVzOiBFbnRpdHk8Q1Q+W10gPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY29uc3QgdGFnRW50aXR5SWRzID0gdGhpcy5lbnRpdGllc0J5VGFncy5nZXQodGFnKTtcblxuICAgIGlmICh0YWdFbnRpdHlJZHMpIHtcbiAgICAgIGZvciAoY29uc3QgZW50aXR5SWQgb2YgdGFnRW50aXR5SWRzKSB7XG4gICAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcbiAgICAgICAgaWYgKGVudGl0eSkge1xuICAgICAgICAgIGVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbnRpdGllcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY29tcG9uZW50IG9uIHRoZSBnaXZlbiBlbnRpdHlcbiAgICovXG4gIGFkZCA9IDxUIGV4dGVuZHMgQ1Q+KGVpZDogRW50aXR5SWQsIGNvbXBvbmVudDogVCk6IHRoaXMgPT4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICBjYy5hZGQoY29tcG9uZW50KTtcblxuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVpZCwgY2MpO1xuXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5hZGQoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMuaXNUcmFja2VkXSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5zZXRXb3JsZF0odGhpcyk7XG5cbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW50aXRpZXMuZ2V0KGVpZCk7XG5cbiAgICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgd29ybGQuYWRkOiBVbmFibGUgdG8gbG9jYXRlIGVudGl0eS4gZWlkOiAke2VpZH1gKTtcbiAgICAgIH1cblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vbkFkZF0odGhpcywgZW50aXR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29tcG9uZW50IGZyb20gdGhlIGdpdmVuIGVudGl0eS5cbiAgICogTk9URTogVGhpcyB3aWxsIGNoYW5nZSB3aGF0IHN5c3RlbXMgd2lsbCBiZSBjYWxsZWQgb24gdGhlIGVudGl0eS5cbiAgICovXG4gIHJlbW92ZSA9IChlaWQ6IEVudGl0eUlkLCBjVHlwZTogQ2xhc3NDb25zdHJ1Y3RvcjxDVD4pOiB0aGlzID0+IHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgLy8gbmVlZCB0byBnZXQgY29tcG9uZW50IGluc3RhbmNlLi4uXG4gICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0KGNUeXBlKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5pc1RyYWNrZWRdKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlaWQpO1xuXG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdvcmxkLnJlbW92ZTogVW5hYmxlIHRvIGxvY2F0ZSBlbnRpdHkuIGVpZDogJHtlaWR9LCBjVHlwZTogJHtjVHlwZS5uYW1lfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uUmVtb3ZlXSh0aGlzLCBlbnRpdHkpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBlbnRpdHkgZnJvbSBjdXJyZW50IGVudGl0aWVzQnlDVHlwZXNcbiAgICBmb3IgKGNvbnN0IFtjdEFyciwgZW50aXR5U2V0XSBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMpIHtcbiAgICAgIGlmICgoY3RBcnIgYXMgc3RyaW5nW10pLmV2ZXJ5KGNjLmhhc0J5TmFtZSkpIHtcbiAgICAgICAgZW50aXR5U2V0LmRlbGV0ZShlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNjLnJlbW92ZShjVHlwZSk7XG5cbiAgICAvLyBNb3ZlIGVudGl0eUlkIHRvIG5ldyBDVHlwZXMgaWYgbmVlZGVkLlxuICAgIGZvciAoY29uc3QgW2N0QXJyLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcykge1xuICAgICAgaWYgKChjdEFyciBhcyBzdHJpbmdbXSkuZXZlcnkoY2MuaGFzQnlOYW1lKSkge1xuICAgICAgICBlbnRpdHlTZXQuYWRkKGVpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsdGVybmF0aXZlIG1ldGhvZCBmb3IgYWRkaW5nIHN5c3RlbXMuXG4gICAqL1xuICBhZGRTeXN0ZW0oY1R5cGVzOiBDbGFzc0NvbnN0cnVjdG9yPENUPltdLCBzeXN0ZW1GdW5jOiBTeXN0ZW1GdW5jPENUPiwgZnVuY05hbWU/OiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnN5c3RlbXMuYWRkKGNUeXBlcywgc3lzdGVtRnVuYywgZnVuY05hbWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXG4gIHJlZ2lzdGVyRW50aXR5KGVudGl0eTogRW50aXR5PENUPik6IFdvcmxkPENUPiB7XG4gICAgY29uc3QgY2MgPSBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVudGl0eS5pZCwgY2MpO1xuICAgIHRoaXMuZW50aXRpZXMuc2V0KGVudGl0eS5pZCwgZW50aXR5KTtcblxuICAgIGVudGl0eS5vbkNyZWF0ZSh0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgY29tcG9uZW50cyB0aGF0IGJlbG9uZyB0byBhbiBlbnRpdHkuXG4gICAqL1xuICBjbGVhckVudGl0eUNvbXBvbmVudHMoZW50aXR5SWQ6IEVudGl0eUlkKTogdGhpcyB7XG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZW50aXR5SWQsIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpKTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5U2V0IG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVudGl0eVNldC5oYXMoZW50aXR5SWQpKSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUoZW50aXR5SWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlbnRpdHkgdGhhdCBpcyBpbiB0aGUgd29ybGQuXG4gICAqIEJhc2ljYWxseSBqdXN0IG5ldyBFbnRpdHkod29ybGQpLCBidXQgc2F2ZXMgYW4gaW1wb3J0IG9mIEVudGl0eS5cbiAgICovXG4gIGNyZWF0ZUVudGl0eSgpOiBFbnRpdHk8Q1Q+IHtcbiAgICBjb25zdCBlbnRpdHkgPSBuZXcgRW50aXR5KHRoaXMpO1xuXG4gICAgcmV0dXJuIGVudGl0eTtcblxuICAgIC8vIFJlZ2lzdGVyIGVudGl0eSBoZXJlLi4uLlxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGVudGl0eS5cbiAgICogU2FtZSBhcyBlbnRpdHkuZGVzdHJveSgpLlxuICAgKi9cbiAgZGVzdHJveUVudGl0eShlbnRpdHlJZDogRW50aXR5SWQpOiBXb3JsZDxDVD4ge1xuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZGVsZXRlKGVudGl0eUlkKTtcbiAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG5cbiAgICBpZiAoIWVudGl0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB3b3JsZC5kZXN0cm95RW50aXR5OiBObyBlbnRpdHkgZm91bmQuIGVudGl0eSBpZDogJHtlbnRpdHlJZH1gKTtcbiAgICB9XG5cbiAgICB0aGlzLmVudGl0aWVzLmRlbGV0ZShlbnRpdHlJZCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eVNldCBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVudGl0eUlkKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVudGl0eUlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYW55IHRhZyBhc3NvY2lhdGlvbnMgd2l0aCBkZXN0cm95ZWQgZW50aXRpZXMuXG4gICAgZm9yIChjb25zdCBbdGFnLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeVRhZ3MpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVudGl0eUlkKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVudGl0eUlkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVudGl0eVNldC5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsImltcG9ydCBXb3JsZCBmcm9tICcuL1dvcmxkJztcbmltcG9ydCB7IHRyYWNrQ29tcG9uZW50IH0gZnJvbSAnLi9UcmFja2VkQ29tcG9uZW50JztcblxuZXhwb3J0IHtcbiAgV29ybGQsXG4gIHRyYWNrQ29tcG9uZW50LFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')}])}));