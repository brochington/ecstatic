!function(Q,B){"object"==typeof exports&&"object"==typeof module?module.exports=B():"function"==typeof define&&define.amd?define("ecstatic",[],B):"object"==typeof exports?exports.ecstatic=B():Q.ecstatic=B()}(window,(function(){return function(Q){var B=window.webpackHotUpdateecstatic;window.webpackHotUpdateecstatic=function(Q,n){!function(Q,B){if(!V[Q]||!y[Q])return;for(var n in y[Q]=!1,B)Object.prototype.hasOwnProperty.call(B,n)&&(b[n]=B[n]);0==--G&&0===u&&X()}(Q,n),B&&B(Q,n)};var n,t=!0,e="3e8a0237e7e31d2fdf66",F={},U=[],c=[];function s(Q){var B=N[Q];if(!B)return L;var t=function(t){return B.hot.active?(N[t]?-1===N[t].parents.indexOf(Q)&&N[t].parents.push(Q):(U=[Q],n=t),-1===B.children.indexOf(t)&&B.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+Q),U=[]),L(t)},e=function(Q){return{configurable:!0,enumerable:!0,get:function(){return L[Q]},set:function(B){L[Q]=B}}};for(var F in L)Object.prototype.hasOwnProperty.call(L,F)&&"e"!==F&&"t"!==F&&Object.defineProperty(t,F,e(F));return t.e=function(Q){return"ready"===l&&g("prepare"),u++,L.e(Q).then(B,(function(Q){throw B(),Q}));function B(){u--,"prepare"===l&&(x[Q]||Z(Q),0===u&&0===G&&X())}},t.t=function(Q,B){return 1&B&&(Q=t(Q)),L.t(Q,-2&B)},t}function I(B){var t={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:n!==B,active:!0,accept:function(Q,B){if(void 0===Q)t._selfAccepted=!0;else if("function"==typeof Q)t._selfAccepted=Q;else if("object"==typeof Q)for(var n=0;n<Q.length;n++)t._acceptedDependencies[Q[n]]=B||function(){};else t._acceptedDependencies[Q]=B||function(){}},decline:function(Q){if(void 0===Q)t._selfDeclined=!0;else if("object"==typeof Q)for(var B=0;B<Q.length;B++)t._declinedDependencies[Q[B]]=!0;else t._declinedDependencies[Q]=!0},dispose:function(Q){t._disposeHandlers.push(Q)},addDisposeHandler:function(Q){t._disposeHandlers.push(Q)},removeDisposeHandler:function(Q){var B=t._disposeHandlers.indexOf(Q);B>=0&&t._disposeHandlers.splice(B,1)},invalidate:function(){switch(this._selfInvalidated=!0,l){case"idle":(b={})[B]=Q[B],g("ready");break;case"ready":E(B);break;case"prepare":case"check":case"dispose":case"apply":(o=o||[]).push(B)}},check:a,apply:r,status:function(Q){if(!Q)return l;i.push(Q)},addStatusHandler:function(Q){i.push(Q)},removeStatusHandler:function(Q){var B=i.indexOf(Q);B>=0&&i.splice(B,1)},data:F[B]};return n=void 0,t}var i=[],l="idle";function g(Q){l=Q;for(var B=0;B<i.length;B++)i[B].call(null,Q)}var d,b,C,o,G=0,u=0,x={},y={},V={};function R(Q){return+Q+""===Q?+Q:Q}function a(Q){if("idle"!==l)throw new Error("check() is only allowed in idle status");return t=Q,g("check"),(B=1e4,B=B||1e4,new Promise((function(Q,n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var t=new XMLHttpRequest,e=L.p+"hot/hot-update.json";t.open("GET",e,!0),t.timeout=B,t.send(null)}catch(Q){return n(Q)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)n(new Error("Manifest request to "+e+" timed out."));else if(404===t.status)Q();else if(200!==t.status&&304!==t.status)n(new Error("Manifest request to "+e+" failed."));else{try{var B=JSON.parse(t.responseText)}catch(Q){return void n(Q)}Q(B)}}}))).then((function(Q){if(!Q)return g(m()?"ready":"idle"),null;y={},x={},V=Q.c,C=Q.h,g("prepare");var B=new Promise((function(Q,B){d={resolve:Q,reject:B}}));b={};return Z(0),"prepare"===l&&0===u&&0===G&&X(),B}));var B}function Z(Q){var B;V[Q]?(y[Q]=!0,G++,(B=document.createElement("script")).charset="utf-8",B.src=L.p+"hot/hot-update.js",document.head.appendChild(B)):x[Q]=!0}function X(){g("ready");var Q=d;if(d=null,Q)if(t)Promise.resolve().then((function(){return r(t)})).then((function(B){Q.resolve(B)}),(function(B){Q.reject(B)}));else{var B=[];for(var n in b)Object.prototype.hasOwnProperty.call(b,n)&&B.push(R(n));Q.resolve(B)}}function r(B){if("ready"!==l)throw new Error("apply() is only allowed in ready status");return function B(t){var c,s,I,i,l;function d(Q){for(var B=[Q],n={},t=B.map((function(Q){return{chain:[Q],id:Q}}));t.length>0;){var e=t.pop(),F=e.id,U=e.chain;if((i=N[F])&&(!i.hot._selfAccepted||i.hot._selfInvalidated)){if(i.hot._selfDeclined)return{type:"self-declined",chain:U,moduleId:F};if(i.hot._main)return{type:"unaccepted",chain:U,moduleId:F};for(var c=0;c<i.parents.length;c++){var s=i.parents[c],I=N[s];if(I){if(I.hot._declinedDependencies[F])return{type:"declined",chain:U.concat([s]),moduleId:F,parentId:s};-1===B.indexOf(s)&&(I.hot._acceptedDependencies[F]?(n[s]||(n[s]=[]),G(n[s],[F])):(delete n[s],B.push(s),t.push({chain:U.concat([s]),id:s})))}}}}return{type:"accepted",moduleId:Q,outdatedModules:B,outdatedDependencies:n}}function G(Q,B){for(var n=0;n<B.length;n++){var t=B[n];-1===Q.indexOf(t)&&Q.push(t)}}m();var u={},x=[],y={},a=function(){console.warn("[HMR] unexpected require("+X.moduleId+") to disposed module")};for(var Z in b)if(Object.prototype.hasOwnProperty.call(b,Z)){var X;l=R(Z),X=b[Z]?d(l):{type:"disposed",moduleId:Z};var r=!1,E=!1,W=!1,p="";switch(X.chain&&(p="\nUpdate propagation: "+X.chain.join(" -> ")),X.type){case"self-declined":t.onDeclined&&t.onDeclined(X),t.ignoreDeclined||(r=new Error("Aborted because of self decline: "+X.moduleId+p));break;case"declined":t.onDeclined&&t.onDeclined(X),t.ignoreDeclined||(r=new Error("Aborted because of declined dependency: "+X.moduleId+" in "+X.parentId+p));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(X),t.ignoreUnaccepted||(r=new Error("Aborted because "+l+" is not accepted"+p));break;case"accepted":t.onAccepted&&t.onAccepted(X),E=!0;break;case"disposed":t.onDisposed&&t.onDisposed(X),W=!0;break;default:throw new Error("Unexception type "+X.type)}if(r)return g("abort"),Promise.reject(r);if(E)for(l in y[l]=b[l],G(x,X.outdatedModules),X.outdatedDependencies)Object.prototype.hasOwnProperty.call(X.outdatedDependencies,l)&&(u[l]||(u[l]=[]),G(u[l],X.outdatedDependencies[l]));W&&(G(x,[X.moduleId]),y[l]=a)}var A,h=[];for(s=0;s<x.length;s++)l=x[s],N[l]&&N[l].hot._selfAccepted&&y[l]!==a&&!N[l].hot._selfInvalidated&&h.push({module:l,parents:N[l].parents.slice(),errorHandler:N[l].hot._selfAccepted});g("dispose"),Object.keys(V).forEach((function(Q){!1===V[Q]&&function(Q){delete installedChunks[Q]}(Q)}));var S,D,H=x.slice();for(;H.length>0;)if(l=H.pop(),i=N[l]){var v={},Y=i.hot._disposeHandlers;for(I=0;I<Y.length;I++)(c=Y[I])(v);for(F[l]=v,i.hot.active=!1,delete N[l],delete u[l],I=0;I<i.children.length;I++){var J=N[i.children[I]];J&&((A=J.parents.indexOf(l))>=0&&J.parents.splice(A,1))}}for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=N[l]))for(D=u[l],I=0;I<D.length;I++)S=D[I],(A=i.children.indexOf(S))>=0&&i.children.splice(A,1);g("apply"),void 0!==C&&(e=C,C=void 0);for(l in b=void 0,y)Object.prototype.hasOwnProperty.call(y,l)&&(Q[l]=y[l]);var k=null;for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=N[l])){D=u[l];var T=[];for(s=0;s<D.length;s++)if(S=D[s],c=i.hot._acceptedDependencies[S]){if(-1!==T.indexOf(c))continue;T.push(c)}for(s=0;s<T.length;s++){c=T[s];try{c(D)}catch(Q){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:l,dependencyId:D[s],error:Q}),t.ignoreErrored||k||(k=Q)}}}for(s=0;s<h.length;s++){var z=h[s];l=z.module,U=z.parents,n=l;try{L(l)}catch(Q){if("function"==typeof z.errorHandler)try{z.errorHandler(Q)}catch(B){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:l,error:B,originalError:Q}),t.ignoreErrored||k||(k=B),k||(k=Q)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:l,error:Q}),t.ignoreErrored||k||(k=Q)}}if(k)return g("fail"),Promise.reject(k);if(o)return B(t).then((function(Q){return x.forEach((function(B){Q.indexOf(B)<0&&Q.push(B)})),Q}));return g("idle"),new Promise((function(Q){Q(x)}))}(B=B||{})}function m(){if(o)return b||(b={}),o.forEach(E),o=void 0,!0}function E(B){Object.prototype.hasOwnProperty.call(b,B)||(b[B]=Q[B])}var N={};function L(B){if(N[B])return N[B].exports;var n=N[B]={i:B,l:!1,exports:{},hot:I(B),parents:(c=U,U=[],c),children:[]};return Q[B].call(n.exports,n,n.exports,s(B)),n.l=!0,n.exports}return L.m=Q,L.c=N,L.d=function(Q,B,n){L.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:n})},L.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},L.t=function(Q,B){if(1&B&&(Q=L(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var n=Object.create(null);if(L.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var t in Q)L.d(n,t,function(B){return Q[B]}.bind(null,t));return n},L.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return L.d(B,"a",B),B},L.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},L.p="/static/",L.h=function(){return e},s(0)(L.s=0)}([function(Q,B,n){Q.exports=n(1)},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "World", function() { return /* reexport */ World_World; });\n\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== \'undefined\' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \'undefined\' && typeof msCrypto.getRandomValues === \'function\' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error(\'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js\n/* harmony default export */ var regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js\n\n\nfunction validate(uuid) {\n  return typeof uuid === \'string\' && regex.test(uuid);\n}\n\n/* harmony default export */ var esm_browser_validate = (validate);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var stringify_i = 0; stringify_i < 256; ++stringify_i) {\n  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It\'s been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \'-\' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \'-\' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \'-\' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \'-\' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it\'s likely due to one\n  // of the following:\n  // - One or more input array values don\'t map to a hex octet (leading to\n  // "undefined" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!esm_browser_validate(uuid)) {\n    throw TypeError(\'Stringified UUID is invalid\');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ var esm_browser_stringify = (stringify);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return esm_browser_stringify(rnds);\n}\n\n/* harmony default export */ var esm_browser_v4 = (v4);\n// CONCATENATED MODULE: ./src/guards.ts\n// export function classIsCompType(cl: any)\nfunction isComponentInstance(Class, comp) {\n  if (!comp) {\n    return false;\n  }\n\n  if (!(comp instanceof Class)) {\n    return false;\n  }\n\n  return true;\n}\nfunction isComponentName(possibleName, entitiesByCTypes) {\n  // string\n  if (typeof possibleName !== \'string\') {\n    return false;\n  }\n\n  for (const a of entitiesByCTypes.keys()) {\n    if (a.includes(possibleName)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n// CONCATENATED MODULE: ./src/ComponentCollection.ts\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n// CT is a Union, like `type = typeof FirstComponent | typeof SecondComponent`.\nclass ComponentCollection_ComponentCollection {\n  constructor() {\n    _defineProperty(this, "components", new Map());\n\n    _defineProperty(this, "add", component => {\n      this.components.set(component.constructor.name, component);\n    });\n\n    _defineProperty(this, "update", (cl, func) => {\n      const c = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, c)) {\n        const updatedComponent = func(c);\n        this.components.set(cl.name, updatedComponent);\n      }\n    });\n\n    _defineProperty(this, "remove", cType => {\n      this.components.delete(cType.name);\n    });\n\n    _defineProperty(this, "get", cl => {\n      const comp = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, comp)) {\n        return comp;\n      } else {\n        throw new Error(`ComponentCollection does not have component of type ${cl.name}`);\n      }\n    });\n\n    _defineProperty(this, "has", cType => {\n      return Array.isArray(cType) ? cType.every(ct => this.components.has(ct.name) === true) : this.components.has(cType.name);\n    });\n\n    _defineProperty(this, "hasByName", cName => {\n      return Array.isArray(cName) ? cName.every(ct => this.components.has(ct) === true) : this.components.has(cName);\n    });\n  }\n\n  /**\n   * Get the component type names that are currently being used in the collection.\n   */\n  get componentTypes() {\n    return [...this.components.keys()];\n  }\n  /**\n   * Get the current number of components that are in the collection.\n   */\n\n\n  get size() {\n    return this.components.size;\n  }\n\n  toDevComponents() {\n    const obj = {};\n\n    for (const [compName, comp] of this.components) {\n      obj[compName] = comp;\n    }\n\n    return obj;\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevEntity.ts\nfunction DevEntity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevEntity {\n  constructor(entity, world) {\n    DevEntity_defineProperty(this, "id", void 0);\n\n    DevEntity_defineProperty(this, "components", void 0);\n\n    DevEntity_defineProperty(this, "tags", void 0);\n\n    DevEntity_defineProperty(this, "systems", []);\n\n    this.id = entity.id;\n    this.components = entity.components.toDevComponents(), this.tags = [...entity.tags];\n    const compNames = Object.keys(this.components);\n\n    for (const [systemName, cNames] of world.systems.compNamesBySystemName) {\n      if (cNames.every(cName => compNames.includes(cName))) {\n        this.systems.push(systemName);\n      }\n    }\n  }\n\n  toTableRow() {\n    return {\n      id: this.id,\n      components: Object.keys(this.components).join(", "),\n      tags: this.tags.join(", "),\n      systems: this.systems.join(\', \')\n    };\n  }\n\n}\n\n/* harmony default export */ var src_DevEntity = (DevEntity);\n// CONCATENATED MODULE: ./src/SimpleFSM.ts\nfunction SimpleFSM_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass SimpleFSM {\n  constructor(initialState, transitions) {\n    SimpleFSM_defineProperty(this, "current", void 0);\n\n    SimpleFSM_defineProperty(this, "inital", void 0);\n\n    SimpleFSM_defineProperty(this, "transitions", void 0);\n\n    this.inital = initialState;\n    this.current = initialState;\n    this.transitions = transitions;\n  }\n\n  next(data) {\n    if (this.transitions[this.current]) {\n      this.current = this.transitions[this.current](data, this.current);\n    }\n  }\n\n  reset() {\n    this.current = this.inital;\n  }\n\n  is(checkState) {\n    return this.current === checkState;\n  }\n\n}\n// CONCATENATED MODULE: ./src/Entity.ts\nfunction Entity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n// import { CompTypes } from \'interfaces\';\n\n\nclass Entity_Entity {\n  constructor(world) {\n    Entity_defineProperty(this, "_id", void 0);\n\n    Entity_defineProperty(this, "_world", void 0);\n\n    Entity_defineProperty(this, "_error", void 0);\n\n    Entity_defineProperty(this, "_state", void 0);\n\n    this._id = esm_browser_v4();\n    this._world = world;\n    this._error = null;\n    this._state = new SimpleFSM("creating", {\n      creating: () => this._error ? "error" : "created",\n      created: () => "destroying",\n      destroying: () => this._error ? "error" : "destroyed",\n      destroyed: () => "destroyed",\n      error: () => "error"\n    });\n    /*\n    Registering with the World.\n    */\n\n    this._world.registerEntity(this);\n\n    this._state.next(); // created\n\n\n    this.onCreate();\n  }\n\n  get state() {\n    return this._state.current;\n  }\n\n  checkState(possibleState) {\n    return this._state.is(possibleState);\n  }\n  /* LifeCycle methods, meant to be overridden */\n\n\n  onCreate() {// abstract\n  }\n\n  onDestroy() {// abstract\n  }\n\n  onComponentAdd() {// abstract\n  }\n\n  onComponentUpdate() {// abstract\n  }\n\n  onComponentRemove() {// abstract\n  }\n  /**\n   * Add a component to an Entity, doh.\n   */\n\n\n  add(component) {\n    this._world.set(this._id, component);\n\n    if (component[Symbol.for("ecs.trackedComponent.isTracked")]) {\n      component[Symbol.for("ecs.trackedComponent.setWorld")](this._world);\n      component[Symbol.for("ecs.trackedComponent.onAdd")](this._world, this);\n    }\n\n    return this;\n  }\n  /**\n   * Add a tag to a component\n   */\n\n\n  addTag(tag) {\n    const entitySet = this._world.entitiesByTags.has(tag) ? this._world.entitiesByTags.get(tag) : new Set();\n\n    if (entitySet) {\n      entitySet.add(this._id);\n\n      this._world.entitiesByTags.set(tag, entitySet);\n    }\n\n    return this;\n  }\n  /**\n   * Determines if an entity has a component related to it.\n   */\n\n\n  has(cType) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    return cc.has(cType);\n  }\n  /**\n   * Check to see if an entity tagged with a given tag.\n   */\n\n\n  hasTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        return entitySet.has(this._id);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get a component that belongs to an entity.\n   */\n\n\n  get(cl) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    const component = cc.get(cl);\n    return component;\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection\n   */\n\n\n  getAll() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Remove a component from an entity.\n   * @param cType A component class, eg MyComponent\n   */\n\n\n  remove(cType) {\n    this._world.remove(this._id, cType);\n\n    return this;\n  }\n  /**\n   * Remove a tag from an entity\n   */\n\n\n  removeTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        entitySet.delete(this._id);\n\n        if (entitySet.size === 0) {\n          this._world.entitiesByTags.delete(tag);\n        }\n      }\n    }\n\n    return this;\n  }\n  /** Clears all components from an Entity */\n\n\n  clear() {\n    this._world.clearEntityComponents(this._id);\n\n    return this;\n  }\n  /**\n   * Remove all tags on an entity\n   */\n\n\n  clearTags() {\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      entitySet.delete(this._id);\n\n      if (entitySet.size === 0) {\n        this._world.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n  destroy() {\n    if (!this._state.is("created")) {\n      throw new Error("Ecstatic: Unable to destroy if it isn\'t created, or already destroyed");\n    }\n\n    this._state.next(); // destroying\n    // This will probably be deferred so that Systems can work on it.\n\n\n    this._world.destroyEntity(this._id); // should return an error??\n\n\n    this.onDestroy(); // assuming for now that this is best done after actually removing the entity from the world.\n\n    if (this._state.is("destroying")) {\n      this._state.next(); // destroyed\n\n    } else if (this._state.is("error") && this._error) {// Do something with error!!\n    }\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get world() {\n    return this._world;\n  }\n\n  destroyImmediately() {// placeholder for method that doesn\'t wait for entity to go through the normal\n    // destory pipeline and process.\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection.\n   * Does the same thing as entityInstance.getAll().\n   */\n\n\n  get components() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Retrieves all the tags that have been added to this entity.\n   */\n\n\n  get tags() {\n    const tags = new Set();\n\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      if (entitySet.has(this._id)) {\n        tags.add(tag);\n      }\n    }\n\n    return tags;\n  }\n  /**\n   * Convert Entity to a DevEntity. Very helpful in for debugging.\n   */\n\n\n  toDevEntity() {\n    return new src_DevEntity(this, this._world);\n  }\n\n}\nfunction createEntity(world) {\n  const entity = new Entity_Entity(world);\n  return entity;\n}\n// CONCATENATED MODULE: ./src/DevTools.ts\nfunction DevTools_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevTools {\n  constructor(world) {\n    DevTools_defineProperty(this, "world", void 0);\n\n    this.world = world;\n  }\n  /**\n   * display the all systems of the world, and the components required by each system.\n   * Super helpful to use with console.table()\n   * @example\n   * ```\n   * console.table(world.dev.systemComponents);\n   * ```\n   */\n\n\n  get systemComponents() {\n    const compsBySystems = [];\n\n    for (const [system, compNames] of this.world.systems.compNamesBySystemName) {\n      compsBySystems.push({\n        system,\n        components: compNames.join(", ")\n      });\n    }\n\n    return compsBySystems;\n  }\n  /**\n   * Create an array of DevEntites. Can be very helpful for things like inspecting component state,\n   * and which systems will be called on an entity.\n   * @example\n   * ```\n   * console.table(world.dev.entities);\n   *\n   * // Pro tip! try displaying a table of entities with console.table and DevEntity.toTableRow().\n   * console.table(world.dev.entities.map(devEntity => devEntity.toTableRow()));\n   * ```\n   */\n\n\n  get entities() {\n    return [...this.world.entities.values()].map(e => e.toDevEntity());\n  }\n\n}\n\n/* harmony default export */ var src_DevTools = (DevTools);\n// CONCATENATED MODULE: ./src/Systems.ts\nfunction Systems_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/**\n * Arguments that are passed into a System function on each iteration.\n * This is how you acces things like the entity that particular entity to act on,\n * as well as some other helpful params like if the entity is the first or last entity\n * in the group of entities that being iterated over.\n */\n\nclass Systems_Systems {\n  // double check to make sure that maps are ordered.\n  constructor(world) {\n    Systems_defineProperty(this, "world", void 0);\n\n    Systems_defineProperty(this, "systemFuncBySystemName", void 0);\n\n    Systems_defineProperty(this, "compNamesBySystemName", void 0);\n\n    this.world = world;\n    this.systemFuncBySystemName = new Map();\n    this.compNamesBySystemName = new Map();\n  }\n\n  add(cTypes, systemFunc, funcName) {\n    const cNames = cTypes.map(ct => ct.name);\n    let name = systemFunc.name;\n\n    if (systemFunc.name === \'\') {\n      // Super brute force, and might lead to errors in the future, but for now\n      // using the stringified system function if the function doesn\'t already have a name.\n      // This is useful for anonymous functions used as a system function.\n      // Might be good to figure out how to get a hash of the function string.\n      name = systemFunc.toString().slice(0, 30);\n    }\n\n    if (funcName) {\n      name = funcName;\n    }\n\n    this.systemFuncBySystemName.set(name, systemFunc);\n    this.compNamesBySystemName.set(name, cNames);\n    this.world.entitiesByCTypes.set(cNames, new Set());\n    return this;\n  }\n\n  run() {\n    // TODO: Might be cool to add a way to stop the systems loop when in dev.\n    //       Maybe something like world.dev.stop() or pause().\n    for (const [funcName, systemFunc] of this.systemFuncBySystemName.entries()) {\n      let index = 0;\n      const size = this.world.entitiesByCTypes.size;\n      const cNames = this.compNamesBySystemName.get(funcName) || [];\n      const cTypeArrs = this.world.entitiesByCTypes.get(cNames) || new Set();\n\n      for (const eid of cTypeArrs) {\n        const args = {\n          entity: this.world.entities.get(eid) || new Entity_Entity(this.world),\n          components: this.world.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(),\n          world: this.world,\n          index,\n          size,\n          isFirst: index === 0,\n          isLast: index + 1 === size\n        };\n        systemFunc(args);\n        index += 1;\n      }\n    }\n  }\n\n}\n// CONCATENATED MODULE: ./src/TrackedComponent.ts\n// Waiting for Typescript 4.2 to come out so that Symbols are supporded keys.\nconst TrackedCompSymbolKeys = {\n  isTracked: Symbol.for("ecs.trackedComponent.isTracked"),\n  world: Symbol.for("ecs.trackedComponent.world"),\n  setWorld: Symbol.for("ecs.trackedComponent.setWorld"),\n  onAdd: Symbol.for("ecs.trackedComponent.onAdd"),\n  onUpdate: Symbol.for("ecs.trackedComponent.onUpdate"),\n  onRemove: Symbol.for("ecs.trackedComponent.onRemove")\n}; //@ts-ignore\n\nfunction createClassInstanceProxyHandlers(trackedEventHandlers) {\n  const updatedProps = new Set();\n  return {\n    set(component, property, value) {\n      updatedProps.add(property); //@ts-ignore\n\n      const world = component[TrackedCompSymbolKeys.world];\n      const previousVal = component[property];\n      component[property] = value;\n\n      if (trackedEventHandlers.onUpdate) {\n        trackedEventHandlers.onUpdate({\n          world,\n          component,\n          previousVal,\n          property\n        });\n      }\n\n      return true;\n    }\n\n  };\n}\n\nfunction trackComponent(CompClass, trackedEventHandlers) {\n  return new Proxy(CompClass, {\n    construct(Component, args) {\n      const component = new Component(...args); // const component = new Component(...args) as InstanceType<Class<T>>;\n      // For use in identifing a "tracked" class through the proxy.\n      //@ts-ignore\n\n      component[TrackedCompSymbolKeys.isTracked] = true; //@ts-ignore\n\n      component[TrackedCompSymbolKeys.setWorld] = world => {\n        //@ts-ignore\n        component[TrackedCompSymbolKeys.world] = world;\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onAdd] = (world, entity) => {\n        if (trackedEventHandlers.onAdd) {\n          trackedEventHandlers.onAdd({\n            component,\n            world,\n            entity\n          });\n        }\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onRemove] = (world, entity) => {\n        if (trackedEventHandlers.onRemove) {\n          trackedEventHandlers.onRemove({\n            component,\n            world,\n            entity\n          });\n        }\n      };\n\n      return new Proxy(component, createClassInstanceProxyHandlers(trackedEventHandlers));\n    }\n\n  });\n}\n// CONCATENATED MODULE: ./src/World.ts\nfunction World_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nclass World_World {\n  constructor() {\n    World_defineProperty(this, "componentCollections", new Map());\n\n    World_defineProperty(this, "entities", new Map());\n\n    World_defineProperty(this, "entitiesByCTypes", new Map());\n\n    World_defineProperty(this, "entitiesByTags", new Map());\n\n    World_defineProperty(this, "systems", void 0);\n\n    World_defineProperty(this, "dev", void 0);\n\n    World_defineProperty(this, "find", predicate => {\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "findAll", predicate => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "locate", cl => {\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "locateAll", cl => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "grab", cl => {\n      // const entity = this.locate((cl as unknown) as CT[keyof CT]);\n      const entity = this.locate(cl);\n\n      if (entity) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n        return {\n          entity,\n          component\n        };\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabBy", (cl, predicate) => {\n      const entities = this.locateAll(cl);\n\n      for (const entity of entities) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n\n        if (predicate(component)) {\n          return {\n            component,\n            entity\n          };\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabAll", cl => {\n      const entities = this.locateAll(cl);\n      return entities.map(entity => {\n        return {\n          entity,\n          component: entity.components.get(cl)\n        };\n      });\n    });\n\n    World_defineProperty(this, "get", (eid, cl) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      return cc.get(cl);\n    });\n\n    World_defineProperty(this, "getComponent", (cl, defaultValue) => {\n      const result = this.grab(cl);\n\n      if (!result) {\n        return defaultValue ? defaultValue : null;\n      }\n\n      return result.component;\n    });\n\n    World_defineProperty(this, "getTagged", tag => {\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        const entityId = tagEntityIds.values().next().value;\n        const entity = this.entities.get(entityId);\n\n        if (entity) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "getAllTagged", tag => {\n      let entities = []; // eslint-disable-line\n\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        for (const entityId of tagEntityIds) {\n          const entity = this.entities.get(entityId);\n\n          if (entity) {\n            entities.push(entity);\n          }\n        }\n      }\n\n      return entities;\n    });\n\n    World_defineProperty(this, "add", (eid, component) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      cc.add(component);\n      this.componentCollections.set(eid, cc);\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        component[TrackedCompSymbolKeys.setWorld](this);\n        const entity = this.entities.get(eid);\n\n        if (!entity) {\n          throw new Error(`world.add: Unable to locate entity. eid: ${eid}`);\n        }\n\n        component[TrackedCompSymbolKeys.onAdd](this, entity);\n      }\n\n      return this;\n    });\n\n    World_defineProperty(this, "remove", (eid, cType) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(); // need to get component instance...\n\n      const component = cc.get(cType);\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        const entity = this.entities.get(eid);\n\n        if (!entity) {\n          throw new Error(`world.remove: Unable to locate entity. eid: ${eid}, cType: ${cType.name}`);\n        }\n\n        component[TrackedCompSymbolKeys.onRemove](this, entity);\n      } // remove entity from current entitiesByCTypes\n\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.delete(eid);\n        }\n      }\n\n      cc.remove(cType); // Move entityId to new CTypes if needed.\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      return this;\n    });\n\n    this.dev = new src_DevTools(this);\n    this.systems = new Systems_Systems(this);\n  }\n  /**\n   * "finds" a single entity based on a predicate\n   */\n\n\n  /**\n   * Alternative method for adding systems.\n   */\n  addSystem(cTypes, systemFunc, funcName) {\n    this.systems.add(cTypes, systemFunc, funcName);\n    return this;\n  }\n\n  registerEntity(entity) {\n    const cc = new ComponentCollection_ComponentCollection();\n    this.componentCollections.set(entity.id, cc);\n    this.entities.set(entity.id, entity);\n    return this;\n  }\n  /**\n   * Remove all components that belong to an entity.\n   */\n\n\n  clearEntityComponents(eid) {\n    this.componentCollections.set(eid, new ComponentCollection_ComponentCollection());\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Create an entity that is in the world.\n   * Basically just new Entity(world), but saves an import of Entity.\n   */\n\n\n  createEntity() {\n    const entity = new Entity_Entity(this);\n    return entity; // Register entity here....\n  }\n  /**\n   * Destroys an entity.\n   * Same as entity.destroy().\n   */\n\n\n  destroyEntity(eid) {\n    this.componentCollections.delete(eid);\n    this.entities.delete(eid);\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    } // remove any tag associations with destroyed entities.\n\n\n    for (const [tag, entitySet] of this.entitiesByTags) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n\n      if (entitySet.size === 0) {\n        this.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n}\n// CONCATENATED MODULE: ./src/index.ts\n // import { createEntity } from \'./Entity\';\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY3N0YXRpYy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzP2Q4ZjgiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzPzQwZDYiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzA2ZTQiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3N0cmluZ2lmeS5qcz81OGNmIiwid2VicGFjazovL2Vjc3RhdGljLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz9lYzI2Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL2d1YXJkcy50cz8zYjU3Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL0NvbXBvbmVudENvbGxlY3Rpb24udHM/NTFjNCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZFbnRpdHkudHM/ZDE0MiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9TaW1wbGVGU00udHM/NDY5OSIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9FbnRpdHkudHM/YWM2OCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZUb29scy50cz9lMDFhIiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL1N5c3RlbXMudHM/YTYxMyIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9UcmFja2VkQ29tcG9uZW50LnRzP2JhMjciLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9zcmMvV29ybGQudHM/Y2MwYiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9pbmRleC50cz9mZmI0Il0sIm5hbWVzIjpbImlzQ29tcG9uZW50SW5zdGFuY2UiLCJDbGFzcyIsImNvbXAiLCJpc0NvbXBvbmVudE5hbWUiLCJwb3NzaWJsZU5hbWUiLCJlbnRpdGllc0J5Q1R5cGVzIiwiYSIsImtleXMiLCJpbmNsdWRlcyIsIkNvbXBvbmVudENvbGxlY3Rpb24iLCJNYXAiLCJjb21wb25lbnQiLCJjb21wb25lbnRzIiwic2V0IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY2wiLCJmdW5jIiwiYyIsImdldCIsInVwZGF0ZWRDb21wb25lbnQiLCJjVHlwZSIsImRlbGV0ZSIsIkVycm9yIiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJjdCIsImhhcyIsImNOYW1lIiwiY29tcG9uZW50VHlwZXMiLCJzaXplIiwidG9EZXZDb21wb25lbnRzIiwib2JqIiwiY29tcE5hbWUiLCJEZXZFbnRpdHkiLCJlbnRpdHkiLCJ3b3JsZCIsImlkIiwidGFncyIsImNvbXBOYW1lcyIsIk9iamVjdCIsInN5c3RlbU5hbWUiLCJjTmFtZXMiLCJzeXN0ZW1zIiwiY29tcE5hbWVzQnlTeXN0ZW1OYW1lIiwicHVzaCIsInRvVGFibGVSb3ciLCJqb2luIiwiU2ltcGxlRlNNIiwiaW5pdGlhbFN0YXRlIiwidHJhbnNpdGlvbnMiLCJpbml0YWwiLCJjdXJyZW50IiwibmV4dCIsImRhdGEiLCJyZXNldCIsImlzIiwiY2hlY2tTdGF0ZSIsIkVudGl0eSIsIl9pZCIsInV1aWR2NCIsIl93b3JsZCIsIl9lcnJvciIsIl9zdGF0ZSIsImNyZWF0aW5nIiwiY3JlYXRlZCIsImRlc3Ryb3lpbmciLCJkZXN0cm95ZWQiLCJlcnJvciIsInJlZ2lzdGVyRW50aXR5Iiwib25DcmVhdGUiLCJzdGF0ZSIsInBvc3NpYmxlU3RhdGUiLCJvbkRlc3Ryb3kiLCJvbkNvbXBvbmVudEFkZCIsIm9uQ29tcG9uZW50VXBkYXRlIiwib25Db21wb25lbnRSZW1vdmUiLCJhZGQiLCJTeW1ib2wiLCJmb3IiLCJhZGRUYWciLCJ0YWciLCJlbnRpdHlTZXQiLCJlbnRpdGllc0J5VGFncyIsIlNldCIsImNjIiwiY29tcG9uZW50Q29sbGVjdGlvbnMiLCJoYXNUYWciLCJnZXRBbGwiLCJyZW1vdmUiLCJyZW1vdmVUYWciLCJjbGVhciIsImNsZWFyRW50aXR5Q29tcG9uZW50cyIsImNsZWFyVGFncyIsImVudHJpZXMiLCJkZXN0cm95IiwiZGVzdHJveUVudGl0eSIsImRlc3Ryb3lJbW1lZGlhdGVseSIsInRvRGV2RW50aXR5IiwiY3JlYXRlRW50aXR5IiwiRGV2VG9vbHMiLCJzeXN0ZW1Db21wb25lbnRzIiwiY29tcHNCeVN5c3RlbXMiLCJzeXN0ZW0iLCJlbnRpdGllcyIsInZhbHVlcyIsIm1hcCIsImUiLCJTeXN0ZW1zIiwic3lzdGVtRnVuY0J5U3lzdGVtTmFtZSIsImNUeXBlcyIsInN5c3RlbUZ1bmMiLCJmdW5jTmFtZSIsInRvU3RyaW5nIiwic2xpY2UiLCJydW4iLCJpbmRleCIsImNUeXBlQXJycyIsImVpZCIsImFyZ3MiLCJpc0ZpcnN0IiwiaXNMYXN0IiwiVHJhY2tlZENvbXBTeW1ib2xLZXlzIiwiaXNUcmFja2VkIiwic2V0V29ybGQiLCJvbkFkZCIsIm9uVXBkYXRlIiwib25SZW1vdmUiLCJjcmVhdGVDbGFzc0luc3RhbmNlUHJveHlIYW5kbGVycyIsInRyYWNrZWRFdmVudEhhbmRsZXJzIiwidXBkYXRlZFByb3BzIiwicHJvcGVydHkiLCJ2YWx1ZSIsInByZXZpb3VzVmFsIiwidHJhY2tDb21wb25lbnQiLCJDb21wQ2xhc3MiLCJQcm94eSIsImNvbnN0cnVjdCIsIkNvbXBvbmVudCIsIldvcmxkIiwicHJlZGljYXRlIiwicmVzdWx0cyIsImxvY2F0ZSIsImxvY2F0ZUFsbCIsImRlZmF1bHRWYWx1ZSIsInJlc3VsdCIsImdyYWIiLCJ0YWdFbnRpdHlJZHMiLCJlbnRpdHlJZCIsImN0QXJyIiwiaGFzQnlOYW1lIiwiZGV2IiwiYWRkU3lzdGVtIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7O0FDbEJlLHdEQUFjLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEdBQUcseUNBQXlDLEU7O0FDQXJHOztBQUUvQjtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDOztBQUVlLGlFQUFRLEU7O0FDTmM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxXQUFDLEtBQUssQ0FBQyxXQUFDLE9BQU8sR0FBRyxXQUFDO0FBQzVCLGtCQUFrQixXQUFDO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseWdCQUF5Z0I7QUFDemdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU8sb0JBQVE7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRWUsbUVBQVMsRTs7QUM3Qkc7QUFDWTs7QUFFdkM7QUFDQTtBQUNBLCtDQUErQyxHQUFHLElBQUk7O0FBRXREO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLHFCQUFTO0FBQ2xCOztBQUVlLHFEQUFFLEU7O0FDbkJqQjtBQUVPLFNBQVNBLG1CQUFULENBQ0xDLEtBREssRUFFTEMsSUFGSyxFQUcrQjtBQUNwQyxNQUFJLENBQUNBLElBQUwsRUFBVztBQUNULFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQUksRUFBRUEsSUFBSSxZQUFZRCxLQUFsQixDQUFKLEVBQThCO0FBQzVCLFdBQU8sS0FBUDtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNEO0FBR00sU0FBU0UsZUFBVCxDQUNMQyxZQURLLEVBRUxDLGdCQUZLLEVBR3lCO0FBQzlCO0FBQ0EsTUFBSSxPQUFPRCxZQUFQLEtBQXdCLFFBQTVCLEVBQXNDO0FBQ3BDLFdBQU8sS0FBUDtBQUNEOztBQUVELE9BQUssTUFBTUUsQ0FBWCxJQUFnQkQsZ0JBQWdCLENBQUNFLElBQWpCLEVBQWhCLEVBQXlDO0FBQ3ZDLFFBQUlELENBQUMsQ0FBQ0UsUUFBRixDQUFXSixZQUFYLENBQUosRUFBOEI7QUFDNUIsYUFBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLEtBQVA7QUFDRCxDOzs7O0FDdENEO0FBSUE7QUFDZSxNQUFNSyx1Q0FBTixDQUFpRDtBQUFBO0FBQUEsd0NBQ2xCLElBQUlDLEdBQUosRUFEa0I7O0FBQUEsaUNBS3ZEQyxTQUFELElBQXVDO0FBQzNDLFdBQUtDLFVBQUwsQ0FBZ0JDLEdBQWhCLENBQW9CRixTQUFTLENBQUNHLFdBQVYsQ0FBc0JDLElBQTFDLEVBQWdESixTQUFoRDtBQUNELEtBUDZEOztBQUFBLG9DQVNyRCxDQUNQSyxFQURPLEVBRVBDLElBRk8sS0FHRTtBQUNULFlBQU1DLENBQUMsR0FBRyxLQUFLTixVQUFMLENBQWdCTyxHQUFoQixDQUFvQkgsRUFBRSxDQUFDRCxJQUF2QixDQUFWOztBQUVBLFVBQUlmLG1CQUFtQixDQUFDZ0IsRUFBRCxFQUFLRSxDQUFMLENBQXZCLEVBQWdDO0FBQzlCLGNBQU1FLGdCQUFnQixHQUFHSCxJQUFJLENBQUNDLENBQUQsQ0FBN0I7QUFDQSxhQUFLTixVQUFMLENBQWdCQyxHQUFoQixDQUFvQkcsRUFBRSxDQUFDRCxJQUF2QixFQUE2QkssZ0JBQTdCO0FBQ0Q7QUFDRixLQW5CNkQ7O0FBQUEsb0NBeUJwREMsS0FBRCxJQUFxQjtBQUM1QixXQUFLVCxVQUFMLENBQWdCVSxNQUFoQixDQUF1QkQsS0FBSyxDQUFDTixJQUE3QjtBQUNELEtBM0I2RDs7QUFBQSxpQ0FxQ3BEQyxFQUFKLElBQThDO0FBQ2xELFlBQU1kLElBQUksR0FBRyxLQUFLVSxVQUFMLENBQWdCTyxHQUFoQixDQUFvQkgsRUFBRSxDQUFDRCxJQUF2QixDQUFiOztBQUVBLFVBQUlmLG1CQUFtQixDQUFJZ0IsRUFBSixFQUFRZCxJQUFSLENBQXZCLEVBQXNDO0FBQ3BDLGVBQU9BLElBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxjQUFNLElBQUlxQixLQUFKLENBQ0gsdURBQXNEUCxFQUFFLENBQUNELElBQUssRUFEM0QsQ0FBTjtBQUdEO0FBQ0YsS0EvQzZEOztBQUFBLGlDQWlFdkRNLEtBQUQsSUFBK0I7QUFDbkMsYUFBT0csS0FBSyxDQUFDQyxPQUFOLENBQWNKLEtBQWQsSUFDSEEsS0FBSyxDQUFDSyxLQUFOLENBQWFDLEVBQUQsSUFBUSxLQUFLZixVQUFMLENBQWdCZ0IsR0FBaEIsQ0FBb0JELEVBQUUsQ0FBQ1osSUFBdkIsTUFBaUMsSUFBckQsQ0FERyxHQUVILEtBQUtILFVBQUwsQ0FBZ0JnQixHQUFoQixDQUFvQlAsS0FBSyxDQUFDTixJQUExQixDQUZKO0FBR0QsS0FyRTZEOztBQUFBLHVDQTZFakRjLEtBQUQsSUFBdUM7QUFDakQsYUFBT0wsS0FBSyxDQUFDQyxPQUFOLENBQWNJLEtBQWQsSUFDSEEsS0FBSyxDQUFDSCxLQUFOLENBQVlDLEVBQUUsSUFBSSxLQUFLZixVQUFMLENBQWdCZ0IsR0FBaEIsQ0FBb0JELEVBQXBCLE1BQTRCLElBQTlDLENBREcsR0FFSCxLQUFLZixVQUFMLENBQWdCZ0IsR0FBaEIsQ0FBb0JDLEtBQXBCLENBRko7QUFHRCxLQWpGNkQ7QUFBQTs7QUFtRjlEO0FBQ0Y7QUFDQTtBQUNvQixNQUFkQyxjQUFjLEdBQWE7QUFDN0IsV0FBTyxDQUFDLEdBQUcsS0FBS2xCLFVBQUwsQ0FBZ0JMLElBQWhCLEVBQUosQ0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDVSxNQUFKd0IsSUFBSSxHQUFXO0FBQ2pCLFdBQU8sS0FBS25CLFVBQUwsQ0FBZ0JtQixJQUF2QjtBQUNEOztBQUVEQyxpQkFBZSxHQUFxQztBQUNsRCxVQUFNQyxHQUFxQyxHQUFHLEVBQTlDOztBQUNBLFNBQUssTUFBTSxDQUFDQyxRQUFELEVBQVdoQyxJQUFYLENBQVgsSUFBK0IsS0FBS1UsVUFBcEMsRUFBZ0Q7QUFDOUNxQixTQUFHLENBQUNDLFFBQUQsQ0FBSCxHQUFnQmhDLElBQWhCO0FBQ0Q7O0FBRUQsV0FBTytCLEdBQVA7QUFDRDs7QUF4RzZELEM7Ozs7QUNNaEUsTUFBTUUsU0FBTixDQUF1QztBQVNyQ3JCLGFBQVcsQ0FBQ3NCLE1BQUQsRUFBcUJDLEtBQXJCLEVBQXVDO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUEsOENBRjlCLEVBRThCOztBQUNoRCxTQUFLQyxFQUFMLEdBQVVGLE1BQU0sQ0FBQ0UsRUFBakI7QUFDQSxTQUFLMUIsVUFBTCxHQUFrQndCLE1BQU0sQ0FBQ3hCLFVBQVAsQ0FBa0JvQixlQUFsQixFQUFsQixFQUNBLEtBQUtPLElBQUwsR0FBWSxDQUFDLEdBQUdILE1BQU0sQ0FBQ0csSUFBWCxDQURaO0FBR0EsVUFBTUMsU0FBUyxHQUFHQyxNQUFNLENBQUNsQyxJQUFQLENBQVksS0FBS0ssVUFBakIsQ0FBbEI7O0FBRUEsU0FBSyxNQUFNLENBQUM4QixVQUFELEVBQWFDLE1BQWIsQ0FBWCxJQUFtQ04sS0FBSyxDQUFDTyxPQUFOLENBQWNDLHFCQUFqRCxFQUF3RTtBQUN0RSxVQUFJRixNQUFNLENBQUNqQixLQUFQLENBQWNHLEtBQUQsSUFBV1csU0FBUyxDQUFDaEMsUUFBVixDQUFtQnFCLEtBQW5CLENBQXhCLENBQUosRUFBd0Q7QUFDdEQsYUFBS2UsT0FBTCxDQUFhRSxJQUFiLENBQWtCSixVQUFsQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFREssWUFBVSxHQUFzQjtBQUM5QixXQUFPO0FBQ0xULFFBQUUsRUFBRSxLQUFLQSxFQURKO0FBRUwxQixnQkFBVSxFQUFFNkIsTUFBTSxDQUFDbEMsSUFBUCxDQUFZLEtBQUtLLFVBQWpCLEVBQTZCb0MsSUFBN0IsQ0FBa0MsSUFBbEMsQ0FGUDtBQUdMVCxVQUFJLEVBQUUsS0FBS0EsSUFBTCxDQUFVUyxJQUFWLENBQWUsSUFBZixDQUhEO0FBSUxKLGFBQU8sRUFBRSxLQUFLQSxPQUFMLENBQWFJLElBQWIsQ0FBa0IsSUFBbEI7QUFKSixLQUFQO0FBTUQ7O0FBOUJvQzs7QUFpQ3hCYiwyREFBZixFOzs7O0FDckNlLE1BQU1jLFNBQU4sQ0FBZ0Q7QUFPN0RuQyxhQUFXLENBQUNvQyxZQUFELEVBQWtCQyxXQUFsQixFQUFrRDtBQUFBOztBQUFBOztBQUFBOztBQUMzRCxTQUFLQyxNQUFMLEdBQWNGLFlBQWQ7QUFDQSxTQUFLRyxPQUFMLEdBQWVILFlBQWY7QUFDQSxTQUFLQyxXQUFMLEdBQW1CQSxXQUFuQjtBQUNEOztBQUVERyxNQUFJLENBQUNDLElBQUQsRUFBaUI7QUFDbkIsUUFBSSxLQUFLSixXQUFMLENBQWlCLEtBQUtFLE9BQXRCLENBQUosRUFBb0M7QUFDbEMsV0FBS0EsT0FBTCxHQUFlLEtBQUtGLFdBQUwsQ0FBaUIsS0FBS0UsT0FBdEIsRUFBK0JFLElBQS9CLEVBQXFDLEtBQUtGLE9BQTFDLENBQWY7QUFDRDtBQUNGOztBQUVERyxPQUFLLEdBQVM7QUFDWixTQUFLSCxPQUFMLEdBQWUsS0FBS0QsTUFBcEI7QUFDRDs7QUFFREssSUFBRSxDQUFDQyxVQUFELEVBQXlCO0FBQ3pCLFdBQU8sS0FBS0wsT0FBTCxLQUFpQkssVUFBeEI7QUFDRDs7QUF6QjRELEM7Ozs7QUNQL0Q7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQWFlLE1BQU1DLGFBQU4sQ0FBb0M7QUFRakQ3QyxhQUFXLENBQUN1QixLQUFELEVBQW1CO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQzVCLFNBQUt1QixHQUFMLEdBQVdDLGNBQU0sRUFBakI7QUFDQSxTQUFLQyxNQUFMLEdBQWN6QixLQUFkO0FBRUEsU0FBSzBCLE1BQUwsR0FBYyxJQUFkO0FBRUEsU0FBS0MsTUFBTCxHQUFjLElBQUlmLFNBQUosQ0FBMkIsVUFBM0IsRUFBdUM7QUFDbkRnQixjQUFRLEVBQUUsTUFBTyxLQUFLRixNQUFMLEdBQWMsT0FBZCxHQUF3QixTQURVO0FBRW5ERyxhQUFPLEVBQUUsTUFBTSxZQUZvQztBQUduREMsZ0JBQVUsRUFBRSxNQUFPLEtBQUtKLE1BQUwsR0FBYyxPQUFkLEdBQXdCLFdBSFE7QUFJbkRLLGVBQVMsRUFBRSxNQUFNLFdBSmtDO0FBS25EQyxXQUFLLEVBQUUsTUFBTTtBQUxzQyxLQUF2QyxDQUFkO0FBUUE7QUFDSjtBQUNBOztBQUNJLFNBQUtQLE1BQUwsQ0FBWVEsY0FBWixDQUEyQixJQUEzQjs7QUFFQSxTQUFLTixNQUFMLENBQVlWLElBQVosR0FuQjRCLENBbUJUOzs7QUFFbkIsU0FBS2lCLFFBQUw7QUFFRDs7QUFFUSxNQUFMQyxLQUFLLEdBQWdCO0FBQ3ZCLFdBQU8sS0FBS1IsTUFBTCxDQUFZWCxPQUFuQjtBQUNEOztBQUVESyxZQUFVLENBQUNlLGFBQUQsRUFBc0M7QUFDOUMsV0FBTyxLQUFLVCxNQUFMLENBQVlQLEVBQVosQ0FBZWdCLGFBQWYsQ0FBUDtBQUNEO0FBRUQ7OztBQUVBRixVQUFRLEdBQVMsQ0FDZjtBQUNEOztBQUVERyxXQUFTLEdBQVMsQ0FDaEI7QUFDRDs7QUFFREMsZ0JBQWMsR0FBUyxDQUNyQjtBQUNEOztBQUVEQyxtQkFBaUIsR0FBUyxDQUN4QjtBQUNEOztBQUVEQyxtQkFBaUIsR0FBUyxDQUN4QjtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDRUMsS0FBRyxDQUFDbkUsU0FBRCxFQUFvQztBQUNyQyxTQUFLbUQsTUFBTCxDQUFZakQsR0FBWixDQUFnQixLQUFLK0MsR0FBckIsRUFBMEJqRCxTQUExQjs7QUFFQSxRQUFJQSxTQUFTLENBQUNvRSxNQUFNLENBQUNDLEdBQVAsQ0FBVyxnQ0FBWCxDQUFELENBQWIsRUFBNkQ7QUFDM0RyRSxlQUFTLENBQUNvRSxNQUFNLENBQUNDLEdBQVAsQ0FBVywrQkFBWCxDQUFELENBQVQsQ0FBdUQsS0FBS2xCLE1BQTVEO0FBRUFuRCxlQUFTLENBQUNvRSxNQUFNLENBQUNDLEdBQVAsQ0FBVyw0QkFBWCxDQUFELENBQVQsQ0FBb0QsS0FBS2xCLE1BQXpELEVBQWlFLElBQWpFO0FBQ0Q7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7OztBQUNFbUIsUUFBTSxDQUFDQyxHQUFELEVBQWlCO0FBQ3JCLFVBQU1DLFNBQVMsR0FBRyxLQUFLckIsTUFBTCxDQUFZc0IsY0FBWixDQUEyQnhELEdBQTNCLENBQStCc0QsR0FBL0IsSUFDZCxLQUFLcEIsTUFBTCxDQUFZc0IsY0FBWixDQUEyQmpFLEdBQTNCLENBQStCK0QsR0FBL0IsQ0FEYyxHQUVkLElBQUlHLEdBQUosRUFGSjs7QUFJQSxRQUFJRixTQUFKLEVBQWU7QUFDYkEsZUFBUyxDQUFDTCxHQUFWLENBQWMsS0FBS2xCLEdBQW5COztBQUNBLFdBQUtFLE1BQUwsQ0FBWXNCLGNBQVosQ0FBMkJ2RSxHQUEzQixDQUErQnFFLEdBQS9CLEVBQW9DQyxTQUFwQztBQUNEOztBQUVELFdBQU8sSUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDRXZELEtBQUcsQ0FBQ1AsS0FBRCxFQUFxQjtBQUN0QixVQUFNaUUsRUFBRSxHQUNOLEtBQUt4QixNQUFMLENBQVl5QixvQkFBWixDQUFpQ3BFLEdBQWpDLENBQXFDLEtBQUt5QyxHQUExQyxLQUNBLElBQUluRCx1Q0FBSixFQUZGO0FBSUEsV0FBTzZFLEVBQUUsQ0FBQzFELEdBQUgsQ0FBT1AsS0FBUCxDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7OztBQUNFbUUsUUFBTSxDQUFDTixHQUFELEVBQW9CO0FBQ3hCLFFBQUksS0FBS3BCLE1BQUwsQ0FBWXNCLGNBQVosQ0FBMkJ4RCxHQUEzQixDQUErQnNELEdBQS9CLENBQUosRUFBeUM7QUFDdkMsWUFBTUMsU0FBUyxHQUFHLEtBQUtyQixNQUFMLENBQVlzQixjQUFaLENBQTJCakUsR0FBM0IsQ0FBK0IrRCxHQUEvQixDQUFsQjs7QUFDQSxVQUFJQyxTQUFKLEVBQWU7QUFDYixlQUFPQSxTQUFTLENBQUN2RCxHQUFWLENBQWMsS0FBS2dDLEdBQW5CLENBQVA7QUFDRDtBQUNGOztBQUVELFdBQU8sS0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDRXpDLEtBQUcsQ0FBSUgsRUFBSixFQUEyQztBQUM1QyxVQUFNc0UsRUFBRSxHQUNOLEtBQUt4QixNQUFMLENBQVl5QixvQkFBWixDQUFpQ3BFLEdBQWpDLENBQXFDLEtBQUt5QyxHQUExQyxLQUNBLElBQUluRCx1Q0FBSixFQUZGO0FBSUEsVUFBTUUsU0FBUyxHQUFHMkUsRUFBRSxDQUFDbkUsR0FBSCxDQUFVSCxFQUFWLENBQWxCO0FBRUEsV0FBT0wsU0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDRThFLFFBQU0sR0FBNEI7QUFDaEMsV0FDRSxLQUFLM0IsTUFBTCxDQUFZeUIsb0JBQVosQ0FBaUNwRSxHQUFqQyxDQUFxQyxLQUFLeUMsR0FBMUMsS0FDQSxJQUFJbkQsdUNBQUosRUFGRjtBQUlEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7OztBQUNFaUYsUUFBTSxDQUFDckUsS0FBRCxFQUFrQjtBQUN0QixTQUFLeUMsTUFBTCxDQUFZNEIsTUFBWixDQUFtQixLQUFLOUIsR0FBeEIsRUFBNkJ2QyxLQUE3Qjs7QUFFQSxXQUFPLElBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ0VzRSxXQUFTLENBQUNULEdBQUQsRUFBaUI7QUFDeEIsUUFBSSxLQUFLcEIsTUFBTCxDQUFZc0IsY0FBWixDQUEyQnhELEdBQTNCLENBQStCc0QsR0FBL0IsQ0FBSixFQUF5QztBQUN2QyxZQUFNQyxTQUFTLEdBQUcsS0FBS3JCLE1BQUwsQ0FBWXNCLGNBQVosQ0FBMkJqRSxHQUEzQixDQUErQitELEdBQS9CLENBQWxCOztBQUVBLFVBQUlDLFNBQUosRUFBZTtBQUNiQSxpQkFBUyxDQUFDN0QsTUFBVixDQUFpQixLQUFLc0MsR0FBdEI7O0FBRUEsWUFBSXVCLFNBQVMsQ0FBQ3BELElBQVYsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsZUFBSytCLE1BQUwsQ0FBWXNCLGNBQVosQ0FBMkI5RCxNQUEzQixDQUFrQzRELEdBQWxDO0FBQ0Q7QUFDRjtBQUNGOztBQUNELFdBQU8sSUFBUDtBQUNEO0FBRUQ7OztBQUNBVSxPQUFLLEdBQVM7QUFDWixTQUFLOUIsTUFBTCxDQUFZK0IscUJBQVosQ0FBa0MsS0FBS2pDLEdBQXZDOztBQUVBLFdBQU8sSUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDRWtDLFdBQVMsR0FBUztBQUNoQixTQUFLLE1BQU0sQ0FBQ1osR0FBRCxFQUFNQyxTQUFOLENBQVgsSUFBK0IsS0FBS3JCLE1BQUwsQ0FBWXNCLGNBQVosQ0FBMkJXLE9BQTNCLEVBQS9CLEVBQXFFO0FBQ25FWixlQUFTLENBQUM3RCxNQUFWLENBQWlCLEtBQUtzQyxHQUF0Qjs7QUFFQSxVQUFJdUIsU0FBUyxDQUFDcEQsSUFBVixLQUFtQixDQUF2QixFQUEwQjtBQUN4QixhQUFLK0IsTUFBTCxDQUFZc0IsY0FBWixDQUEyQjlELE1BQTNCLENBQWtDNEQsR0FBbEM7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNEOztBQUVEYyxTQUFPLEdBQVM7QUFDZCxRQUFJLENBQUMsS0FBS2hDLE1BQUwsQ0FBWVAsRUFBWixDQUFlLFNBQWYsQ0FBTCxFQUFnQztBQUM5QixZQUFNLElBQUlsQyxLQUFKLENBQ0osdUVBREksQ0FBTjtBQUdEOztBQUVELFNBQUt5QyxNQUFMLENBQVlWLElBQVosR0FQYyxDQU9NO0FBRXBCOzs7QUFDQSxTQUFLUSxNQUFMLENBQVltQyxhQUFaLENBQTBCLEtBQUtyQyxHQUEvQixFQVZjLENBVXVCOzs7QUFFckMsU0FBS2MsU0FBTCxHQVpjLENBWUk7O0FBRWxCLFFBQUksS0FBS1YsTUFBTCxDQUFZUCxFQUFaLENBQWUsWUFBZixDQUFKLEVBQWtDO0FBQ2hDLFdBQUtPLE1BQUwsQ0FBWVYsSUFBWixHQURnQyxDQUNaOztBQUNyQixLQUZELE1BRU8sSUFBSSxLQUFLVSxNQUFMLENBQVlQLEVBQVosQ0FBZSxPQUFmLEtBQTJCLEtBQUtNLE1BQXBDLEVBQTRDLENBQ2pEO0FBQ0Q7QUFDRjs7QUFFSyxNQUFGekIsRUFBRSxHQUFXO0FBQ2YsV0FBTyxLQUFLc0IsR0FBWjtBQUNEOztBQUVRLE1BQUx2QixLQUFLLEdBQWM7QUFDckIsV0FBTyxLQUFLeUIsTUFBWjtBQUNEOztBQUVEb0Msb0JBQWtCLEdBQVMsQ0FDekI7QUFDQTtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7OztBQUNnQixNQUFWdEYsVUFBVSxHQUE0QjtBQUN4QyxXQUNFLEtBQUtrRCxNQUFMLENBQVl5QixvQkFBWixDQUFpQ3BFLEdBQWpDLENBQXFDLEtBQUt5QyxHQUExQyxLQUNBLElBQUluRCx1Q0FBSixFQUZGO0FBSUQ7QUFFRDtBQUNGO0FBQ0E7OztBQUNVLE1BQUo4QixJQUFJLEdBQWE7QUFDbkIsVUFBTUEsSUFBSSxHQUFHLElBQUk4QyxHQUFKLEVBQWI7O0FBQ0EsU0FBSyxNQUFNLENBQUNILEdBQUQsRUFBTUMsU0FBTixDQUFYLElBQStCLEtBQUtyQixNQUFMLENBQVlzQixjQUFaLENBQTJCVyxPQUEzQixFQUEvQixFQUFxRTtBQUNuRSxVQUFJWixTQUFTLENBQUN2RCxHQUFWLENBQWMsS0FBS2dDLEdBQW5CLENBQUosRUFBNkI7QUFDM0JyQixZQUFJLENBQUN1QyxHQUFMLENBQVNJLEdBQVQ7QUFDRDtBQUNGOztBQUVELFdBQU8zQyxJQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7OztBQUNFNEQsYUFBVyxHQUFrQjtBQUMzQixXQUFPLElBQUloRSxhQUFKLENBQWtCLElBQWxCLEVBQXdCLEtBQUsyQixNQUE3QixDQUFQO0FBQ0Q7O0FBaFFnRDtBQW1RNUMsU0FBU3NDLFlBQVQsQ0FDTC9ELEtBREssRUFFTztBQUNaLFFBQU1ELE1BQU0sR0FBRyxJQUFJdUIsYUFBSixDQUFldEIsS0FBZixDQUFmO0FBRUEsU0FBT0QsTUFBUDtBQUNELEM7Ozs7QUNwUkQsTUFBTWlFLFFBQU4sQ0FBc0M7QUFHcEN2RixhQUFXLENBQUN1QixLQUFELEVBQW1CO0FBQUE7O0FBQzVCLFNBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNEO0FBQ0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ3NCLE1BQWhCaUUsZ0JBQWdCLEdBQXFCO0FBQ3ZDLFVBQU1DLGNBQWMsR0FBRyxFQUF2Qjs7QUFFQSxTQUFLLE1BQU0sQ0FBQ0MsTUFBRCxFQUFTaEUsU0FBVCxDQUFYLElBQWtDLEtBQUtILEtBQUwsQ0FBV08sT0FBWCxDQUFtQkMscUJBQXJELEVBQTRFO0FBQzFFMEQsb0JBQWMsQ0FBQ3pELElBQWYsQ0FBb0I7QUFBRTBELGNBQUY7QUFBVTVGLGtCQUFVLEVBQUU0QixTQUFTLENBQUNRLElBQVYsQ0FBZSxJQUFmO0FBQXRCLE9BQXBCO0FBQ0Q7O0FBRUQsV0FBT3VELGNBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVjLE1BQVJFLFFBQVEsR0FBb0I7QUFDOUIsV0FBTyxDQUFDLEdBQUcsS0FBS3BFLEtBQUwsQ0FBV29FLFFBQVgsQ0FBb0JDLE1BQXBCLEVBQUosRUFBa0NDLEdBQWxDLENBQXVDQyxDQUFELElBQU9BLENBQUMsQ0FBQ1QsV0FBRixFQUE3QyxDQUFQO0FBQ0Q7O0FBdENtQzs7QUF5Q3ZCRSx5REFBZixFOzs7O0FDbERBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBb0NlLE1BQU1RLGVBQU4sQ0FBcUM7QUFHRztBQUlyRC9GLGFBQVcsQ0FBQ3VCLEtBQUQsRUFBbUI7QUFBQTs7QUFBQTs7QUFBQTs7QUFDNUIsU0FBS0EsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS3lFLHNCQUFMLEdBQThCLElBQUlwRyxHQUFKLEVBQTlCO0FBQ0EsU0FBS21DLHFCQUFMLEdBQTZCLElBQUluQyxHQUFKLEVBQTdCO0FBQ0Q7O0FBRURvRSxLQUFHLENBQUNpQyxNQUFELEVBQWVDLFVBQWYsRUFBMkNDLFFBQTNDLEVBQW9FO0FBQ3JFLFVBQU10RSxNQUFNLEdBQUdvRSxNQUFNLENBQUNKLEdBQVAsQ0FBWWhGLEVBQUQsSUFBUUEsRUFBRSxDQUFDWixJQUF0QixDQUFmO0FBR0EsUUFBSUEsSUFBSSxHQUFHaUcsVUFBVSxDQUFDakcsSUFBdEI7O0FBQ0EsUUFBSWlHLFVBQVUsQ0FBQ2pHLElBQVgsS0FBb0IsRUFBeEIsRUFBNEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQUEsVUFBSSxHQUFHaUcsVUFBVSxDQUFDRSxRQUFYLEdBQXNCQyxLQUF0QixDQUE0QixDQUE1QixFQUErQixFQUEvQixDQUFQO0FBQ0Q7O0FBRUQsUUFBSUYsUUFBSixFQUFjO0FBQ1psRyxVQUFJLEdBQUdrRyxRQUFQO0FBQ0Q7O0FBRUQsU0FBS0gsc0JBQUwsQ0FBNEJqRyxHQUE1QixDQUFnQ0UsSUFBaEMsRUFBc0NpRyxVQUF0QztBQUNBLFNBQUtuRSxxQkFBTCxDQUEyQmhDLEdBQTNCLENBQStCRSxJQUEvQixFQUFxQzRCLE1BQXJDO0FBQ0EsU0FBS04sS0FBTCxDQUFXaEMsZ0JBQVgsQ0FBNEJRLEdBQTVCLENBQWdDOEIsTUFBaEMsRUFBd0MsSUFBSTBDLEdBQUosRUFBeEM7QUFFQSxXQUFPLElBQVA7QUFDRDs7QUFFRCtCLEtBQUcsR0FBUztBQUVWO0FBQ0E7QUFDQSxTQUFLLE1BQU0sQ0FDVEgsUUFEUyxFQUVURCxVQUZTLENBQVgsSUFHSyxLQUFLRixzQkFBTCxDQUE0QmYsT0FBNUIsRUFITCxFQUc0QztBQUMxQyxVQUFJc0IsS0FBSyxHQUFHLENBQVo7QUFDQSxZQUFNdEYsSUFBSSxHQUFHLEtBQUtNLEtBQUwsQ0FBV2hDLGdCQUFYLENBQTRCMEIsSUFBekM7QUFDQSxZQUFNWSxNQUFNLEdBQUcsS0FBS0UscUJBQUwsQ0FBMkIxQixHQUEzQixDQUErQjhGLFFBQS9CLEtBQTRDLEVBQTNEO0FBQ0EsWUFBTUssU0FBUyxHQUFHLEtBQUtqRixLQUFMLENBQVdoQyxnQkFBWCxDQUE0QmMsR0FBNUIsQ0FBZ0N3QixNQUFoQyxLQUEyQyxJQUFJMEMsR0FBSixFQUE3RDs7QUFFQSxXQUFLLE1BQU1rQyxHQUFYLElBQWtCRCxTQUFsQixFQUE2QjtBQUMzQixjQUFNRSxJQUF3QixHQUFHO0FBQy9CcEYsZ0JBQU0sRUFBRSxLQUFLQyxLQUFMLENBQVdvRSxRQUFYLENBQW9CdEYsR0FBcEIsQ0FBd0JvRyxHQUF4QixLQUFnQyxJQUFJNUQsYUFBSixDQUFlLEtBQUt0QixLQUFwQixDQURUO0FBRS9CekIsb0JBQVUsRUFDUixLQUFLeUIsS0FBTCxDQUFXa0Qsb0JBQVgsQ0FBZ0NwRSxHQUFoQyxDQUFvQ29HLEdBQXBDLEtBQ0EsSUFBSTlHLHVDQUFKLEVBSjZCO0FBSy9CNEIsZUFBSyxFQUFFLEtBQUtBLEtBTG1CO0FBTS9CZ0YsZUFOK0I7QUFPL0J0RixjQVArQjtBQVEvQjBGLGlCQUFPLEVBQUVKLEtBQUssS0FBSyxDQVJZO0FBUy9CSyxnQkFBTSxFQUFFTCxLQUFLLEdBQUcsQ0FBUixLQUFjdEY7QUFUUyxTQUFqQztBQVlBaUYsa0JBQVUsQ0FBQ1EsSUFBRCxDQUFWO0FBRUFILGFBQUssSUFBSSxDQUFUO0FBQ0Q7QUFDRjtBQUNGOztBQXBFaUQsQzs7QUMxQ3BEO0FBQ08sTUFBTU0scUJBQXFCLEdBQUc7QUFDbkNDLFdBQVMsRUFBRTdDLE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLGdDQUFYLENBRHdCO0FBRW5DM0MsT0FBSyxFQUFFMEMsTUFBTSxDQUFDQyxHQUFQLENBQVcsNEJBQVgsQ0FGNEI7QUFHbkM2QyxVQUFRLEVBQUU5QyxNQUFNLENBQUNDLEdBQVAsQ0FBVywrQkFBWCxDQUh5QjtBQUluQzhDLE9BQUssRUFBRS9DLE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLDRCQUFYLENBSjRCO0FBS25DK0MsVUFBUSxFQUFFaEQsTUFBTSxDQUFDQyxHQUFQLENBQVcsK0JBQVgsQ0FMeUI7QUFNbkNnRCxVQUFRLEVBQUVqRCxNQUFNLENBQUNDLEdBQVAsQ0FBVywrQkFBWDtBQU55QixDQUE5QixDLENBU1A7O0FBNkNBLFNBQVNpRCxnQ0FBVCxDQUNFQyxvQkFERixFQUVxQjtBQUNuQixRQUFNQyxZQUFZLEdBQUcsSUFBSTlDLEdBQUosRUFBckI7QUFDQSxTQUFPO0FBQ0x4RSxPQUFHLENBQ0RGLFNBREMsRUFFRHlILFFBRkMsRUFHREMsS0FIQyxFQUlEO0FBQ0FGLGtCQUFZLENBQUNyRCxHQUFiLENBQWlCc0QsUUFBakIsRUFEQSxDQUdBOztBQUNBLFlBQU0vRixLQUFLLEdBQUcxQixTQUFTLENBQ3JCZ0gscUJBQXFCLENBQUN0RixLQURELENBQXZCO0FBSUEsWUFBTWlHLFdBQVcsR0FBRzNILFNBQVMsQ0FBQ3lILFFBQUQsQ0FBN0I7QUFFQXpILGVBQVMsQ0FBQ3lILFFBQUQsQ0FBVCxHQUFzQkMsS0FBdEI7O0FBRUEsVUFBSUgsb0JBQW9CLENBQUNILFFBQXpCLEVBQW1DO0FBQ2pDRyw0QkFBb0IsQ0FBQ0gsUUFBckIsQ0FBOEI7QUFDNUIxRixlQUQ0QjtBQUU1QjFCLG1CQUY0QjtBQUc1QjJILHFCQUg0QjtBQUk1QkY7QUFKNEIsU0FBOUI7QUFNRDs7QUFFRCxhQUFPLElBQVA7QUFDRDs7QUEzQkksR0FBUDtBQTZCRDs7QUFFTSxTQUFTRyxjQUFULENBQ0xDLFNBREssRUFFTE4sb0JBRkssRUFHNEI7QUFDakMsU0FBTyxJQUFJTyxLQUFKLENBQVVELFNBQVYsRUFBcUI7QUFDMUJFLGFBQVMsQ0FBQ0MsU0FBRCxFQUFpQm5CLElBQWpCLEVBQTRCO0FBQ25DLFlBQU03RyxTQUFTLEdBQUcsSUFBSWdJLFNBQUosQ0FBYyxHQUFHbkIsSUFBakIsQ0FBbEIsQ0FEbUMsQ0FFbkM7QUFFQTtBQUNBOztBQUNBN0csZUFBUyxDQUFDZ0gscUJBQXFCLENBQUNDLFNBQXZCLENBQVQsR0FBNkMsSUFBN0MsQ0FObUMsQ0FRbkM7O0FBQ0FqSCxlQUFTLENBQUNnSCxxQkFBcUIsQ0FBQ0UsUUFBdkIsQ0FBVCxHQUNFeEYsS0FEMEMsSUFFdkM7QUFDSDtBQUNBMUIsaUJBQVMsQ0FBQ2dILHFCQUFxQixDQUFDdEYsS0FBdkIsQ0FBVCxHQUF5Q0EsS0FBekM7QUFDRCxPQUxELENBVG1DLENBZ0JuQzs7O0FBQ0ExQixlQUFTLENBQUNnSCxxQkFBcUIsQ0FBQ0csS0FBdkIsQ0FBVCxHQUF5QyxDQUN2Q3pGLEtBRHVDLEVBRXZDRCxNQUZ1QyxLQUdwQztBQUNILFlBQUk4RixvQkFBb0IsQ0FBQ0osS0FBekIsRUFBZ0M7QUFDOUJJLDhCQUFvQixDQUFDSixLQUFyQixDQUEyQjtBQUFFbkgscUJBQUY7QUFBYTBCLGlCQUFiO0FBQW9CRDtBQUFwQixXQUEzQjtBQUNEO0FBQ0YsT0FQRCxDQWpCbUMsQ0EwQm5DOzs7QUFDQXpCLGVBQVMsQ0FBQ2dILHFCQUFxQixDQUFDSyxRQUF2QixDQUFULEdBQTRDLENBQzFDM0YsS0FEMEMsRUFFMUNELE1BRjBDLEtBR3ZDO0FBQ0gsWUFBSThGLG9CQUFvQixDQUFDRixRQUF6QixFQUFtQztBQUNqQ0UsOEJBQW9CLENBQUNGLFFBQXJCLENBQThCO0FBQUVySCxxQkFBRjtBQUFhMEIsaUJBQWI7QUFBb0JEO0FBQXBCLFdBQTlCO0FBQ0Q7QUFDRixPQVBEOztBQVNBLGFBQU8sSUFBSXFHLEtBQUosQ0FDTDlILFNBREssRUFFTHNILGdDQUFnQyxDQUFDQyxvQkFBRCxDQUYzQixDQUFQO0FBSUQ7O0FBekN5QixHQUFyQixDQUFQO0FBMkNELEM7Ozs7QUM1SUQ7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUllLE1BQU1VLFdBQU4sQ0FBbUM7QUFhaEQ5SCxhQUFXLEdBQUc7QUFBQSx1REFaaUQsSUFBSUosR0FBSixFQVlqRDs7QUFBQSwyQ0FWd0IsSUFBSUEsR0FBSixFQVV4Qjs7QUFBQSxtREFSbUMsSUFBSUEsR0FBSixFQVFuQzs7QUFBQSxpREFONEIsSUFBSUEsR0FBSixFQU01Qjs7QUFBQTs7QUFBQTs7QUFBQSx1Q0FRTm1JLFNBQUQsSUFBbUU7QUFDeEUsV0FBSyxNQUFNekcsTUFBWCxJQUFxQixLQUFLcUUsUUFBTCxDQUFjQyxNQUFkLEVBQXJCLEVBQTZDO0FBQzNDLFlBQUltQyxTQUFTLENBQUN6RyxNQUFELENBQWIsRUFBdUI7QUFDckIsaUJBQU9BLE1BQVA7QUFDRDtBQUNGOztBQUVELGFBQU8sSUFBUDtBQUNELEtBaEJhOztBQUFBLDBDQXFCSHlHLFNBQUQsSUFBOEQ7QUFDdEUsWUFBTUMsT0FBcUIsR0FBRyxFQUE5Qjs7QUFFQSxXQUFLLE1BQU0xRyxNQUFYLElBQXFCLEtBQUtxRSxRQUFMLENBQWNDLE1BQWQsRUFBckIsRUFBNkM7QUFDM0MsWUFBSW1DLFNBQVMsQ0FBQ3pHLE1BQUQsQ0FBYixFQUF1QjtBQUNyQjBHLGlCQUFPLENBQUNoRyxJQUFSLENBQWFWLE1BQWI7QUFDRDtBQUNGOztBQUVELGFBQU8wRyxPQUFQO0FBQ0QsS0EvQmE7O0FBQUEseUNBb0NKOUgsRUFBRCxJQUFzQztBQUM3QyxXQUFLLE1BQU1vQixNQUFYLElBQXFCLEtBQUtxRSxRQUFMLENBQWNDLE1BQWQsRUFBckIsRUFBNkM7QUFDM0MsWUFBSXRFLE1BQU0sQ0FBQ3hCLFVBQVAsQ0FBa0JnQixHQUFsQixDQUFzQlosRUFBdEIsQ0FBSixFQUErQjtBQUM3QixpQkFBT29CLE1BQVA7QUFDRDtBQUNGOztBQUVELGFBQU8sSUFBUDtBQUNELEtBNUNhOztBQUFBLDRDQWlERHBCLEVBQUQsSUFBaUM7QUFDM0MsWUFBTThILE9BQXFCLEdBQUcsRUFBOUI7O0FBRUEsV0FBSyxNQUFNMUcsTUFBWCxJQUFxQixLQUFLcUUsUUFBTCxDQUFjQyxNQUFkLEVBQXJCLEVBQTZDO0FBQzNDLFlBQUl0RSxNQUFNLENBQUN4QixVQUFQLENBQWtCZ0IsR0FBbEIsQ0FBc0JaLEVBQXRCLENBQUosRUFBK0I7QUFDN0I4SCxpQkFBTyxDQUFDaEcsSUFBUixDQUFhVixNQUFiO0FBQ0Q7QUFDRjs7QUFFRCxhQUFPMEcsT0FBUDtBQUNELEtBM0RhOztBQUFBLHVDQXFFWjlILEVBREssSUFFaUU7QUFDdEU7QUFDQSxZQUFNb0IsTUFBTSxHQUFHLEtBQUsyRyxNQUFMLENBQWEvSCxFQUFiLENBQWY7O0FBRUEsVUFBSW9CLE1BQUosRUFBWTtBQUNWLGNBQU1rRCxFQUFFLEdBQ04sS0FBS0Msb0JBQUwsQ0FBMEJwRSxHQUExQixDQUE4QmlCLE1BQU0sQ0FBQ0UsRUFBckMsS0FDQSxJQUFJN0IsdUNBQUosRUFGRjtBQUlBLGNBQU1FLFNBQVMsR0FBRzJFLEVBQUUsQ0FBQ25FLEdBQUgsQ0FBVUgsRUFBVixDQUFsQjtBQUVBLGVBQU87QUFDTG9CLGdCQURLO0FBRUx6QjtBQUZLLFNBQVA7QUFJRDs7QUFFRCxhQUFPLElBQVA7QUFDRCxLQXhGYTs7QUFBQSx5Q0FrR0wsQ0FDUEssRUFETyxFQUVQNkgsU0FGTyxLQUcrRDtBQUN0RSxZQUFNcEMsUUFBUSxHQUFHLEtBQUt1QyxTQUFMLENBQWdCaEksRUFBaEIsQ0FBakI7O0FBRUEsV0FBSyxNQUFNb0IsTUFBWCxJQUFxQnFFLFFBQXJCLEVBQStCO0FBQzdCLGNBQU1uQixFQUFFLEdBQ04sS0FBS0Msb0JBQUwsQ0FBMEJwRSxHQUExQixDQUE4QmlCLE1BQU0sQ0FBQ0UsRUFBckMsS0FDQSxJQUFJN0IsdUNBQUosRUFGRjtBQUlBLGNBQU1FLFNBQVMsR0FBRzJFLEVBQUUsQ0FBQ25FLEdBQUgsQ0FBVUgsRUFBVixDQUFsQjs7QUFFQSxZQUFJNkgsU0FBUyxDQUFDbEksU0FBRCxDQUFiLEVBQTBCO0FBQ3hCLGlCQUFPO0FBQ0xBLHFCQURLO0FBRUx5QjtBQUZLLFdBQVA7QUFJRDtBQUNGOztBQUVELGFBQU8sSUFBUDtBQUNELEtBeEhhOztBQUFBLDBDQThIWnBCLEVBRFEsSUFFeUQ7QUFDakUsWUFBTXlGLFFBQVEsR0FBRyxLQUFLdUMsU0FBTCxDQUFnQmhJLEVBQWhCLENBQWpCO0FBRUEsYUFBT3lGLFFBQVEsQ0FBQ0UsR0FBVCxDQUFjdkUsTUFBRCxJQUFZO0FBQzlCLGVBQU87QUFDTEEsZ0JBREs7QUFFTHpCLG1CQUFTLEVBQUV5QixNQUFNLENBQUN4QixVQUFQLENBQWtCTyxHQUFsQixDQUF5QkgsRUFBekI7QUFGTixTQUFQO0FBSUQsT0FMTSxDQUFQO0FBTUQsS0F4SWE7O0FBQUEsc0NBK0lSLENBQUl1RyxHQUFKLEVBQW1CdkcsRUFBbkIsS0FBNkQ7QUFDakUsWUFBTXNFLEVBQUUsR0FDTixLQUFLQyxvQkFBTCxDQUEwQnBFLEdBQTFCLENBQThCb0csR0FBOUIsS0FBc0MsSUFBSTlHLHVDQUFKLEVBRHhDO0FBR0EsYUFBTzZFLEVBQUUsQ0FBQ25FLEdBQUgsQ0FBVUgsRUFBVixDQUFQO0FBQ0QsS0FwSmE7O0FBQUEsK0NBNEpDLENBQ2JBLEVBRGEsRUFFYmlJLFlBRmEsS0FHc0I7QUFDbkMsWUFBTUMsTUFBTSxHQUFHLEtBQUtDLElBQUwsQ0FBVW5JLEVBQVYsQ0FBZjs7QUFFQSxVQUFJLENBQUNrSSxNQUFMLEVBQWE7QUFDWCxlQUFPRCxZQUFZLEdBQUdBLFlBQUgsR0FBa0IsSUFBckM7QUFDRDs7QUFFRCxhQUFPQyxNQUFNLENBQUN2SSxTQUFkO0FBQ0QsS0F2S2E7O0FBQUEsNENBNEtEdUUsR0FBRCxJQUFpQztBQUMzQyxZQUFNa0UsWUFBWSxHQUFHLEtBQUtoRSxjQUFMLENBQW9CakUsR0FBcEIsQ0FBd0IrRCxHQUF4QixDQUFyQjs7QUFFQSxVQUFJa0UsWUFBSixFQUFrQjtBQUNoQixjQUFNQyxRQUFRLEdBQUdELFlBQVksQ0FBQzFDLE1BQWIsR0FBc0JwRCxJQUF0QixHQUE2QitFLEtBQTlDO0FBRUEsY0FBTWpHLE1BQU0sR0FBRyxLQUFLcUUsUUFBTCxDQUFjdEYsR0FBZCxDQUFrQmtJLFFBQWxCLENBQWY7O0FBRUEsWUFBSWpILE1BQUosRUFBWTtBQUNWLGlCQUFPQSxNQUFQO0FBQ0Q7QUFDRjs7QUFFRCxhQUFPLElBQVA7QUFDRCxLQTFMYTs7QUFBQSwrQ0FnTUU4QyxHQUFELElBQTRCO0FBQ3pDLFVBQUl1QixRQUFzQixHQUFHLEVBQTdCLENBRHlDLENBQ1I7O0FBRWpDLFlBQU0yQyxZQUFZLEdBQUcsS0FBS2hFLGNBQUwsQ0FBb0JqRSxHQUFwQixDQUF3QitELEdBQXhCLENBQXJCOztBQUVBLFVBQUlrRSxZQUFKLEVBQWtCO0FBQ2hCLGFBQUssTUFBTUMsUUFBWCxJQUF1QkQsWUFBdkIsRUFBcUM7QUFDbkMsZ0JBQU1oSCxNQUFNLEdBQUcsS0FBS3FFLFFBQUwsQ0FBY3RGLEdBQWQsQ0FBa0JrSSxRQUFsQixDQUFmOztBQUNBLGNBQUlqSCxNQUFKLEVBQVk7QUFDVnFFLG9CQUFRLENBQUMzRCxJQUFULENBQWNWLE1BQWQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsYUFBT3FFLFFBQVA7QUFDRCxLQS9NYTs7QUFBQSxzQ0FvTlIsQ0FBQ2MsR0FBRCxFQUFnQjVHLFNBQWhCLEtBQXNEO0FBQzFELFlBQU0yRSxFQUFFLEdBQ04sS0FBS0Msb0JBQUwsQ0FBMEJwRSxHQUExQixDQUE4Qm9HLEdBQTlCLEtBQXNDLElBQUk5Ryx1Q0FBSixFQUR4QztBQUdBNkUsUUFBRSxDQUFDUixHQUFILENBQU9uRSxTQUFQO0FBRUEsV0FBSzRFLG9CQUFMLENBQTBCMUUsR0FBMUIsQ0FBOEIwRyxHQUE5QixFQUFtQ2pDLEVBQW5DOztBQUVBLFdBQUssTUFBTSxDQUFDZ0UsS0FBRCxFQUFRbkUsU0FBUixDQUFYLElBQWlDLEtBQUs5RSxnQkFBdEMsRUFBd0Q7QUFDdEQsWUFBS2lKLEtBQUQsQ0FBb0I1SCxLQUFwQixDQUEwQjRELEVBQUUsQ0FBQ2lFLFNBQTdCLENBQUosRUFBNkM7QUFDM0NwRSxtQkFBUyxDQUFDTCxHQUFWLENBQWN5QyxHQUFkO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJNUcsU0FBUyxDQUFDZ0gscUJBQXFCLENBQUNDLFNBQXZCLENBQWIsRUFBZ0Q7QUFDOUNqSCxpQkFBUyxDQUFDZ0gscUJBQXFCLENBQUNFLFFBQXZCLENBQVQsQ0FBMEMsSUFBMUM7QUFFQSxjQUFNekYsTUFBTSxHQUFHLEtBQUtxRSxRQUFMLENBQWN0RixHQUFkLENBQWtCb0csR0FBbEIsQ0FBZjs7QUFFQSxZQUFJLENBQUNuRixNQUFMLEVBQWE7QUFDWCxnQkFBTSxJQUFJYixLQUFKLENBQVcsNENBQTJDZ0csR0FBSSxFQUExRCxDQUFOO0FBQ0Q7O0FBRUQ1RyxpQkFBUyxDQUFDZ0gscUJBQXFCLENBQUNHLEtBQXZCLENBQVQsQ0FBdUMsSUFBdkMsRUFBNkMxRixNQUE3QztBQUNEOztBQUVELGFBQU8sSUFBUDtBQUNELEtBL09hOztBQUFBLHlDQXFQTCxDQUFDbUYsR0FBRCxFQUFnQmxHLEtBQWhCLEtBQW9DO0FBQzNDLFlBQU1pRSxFQUFFLEdBQ04sS0FBS0Msb0JBQUwsQ0FBMEJwRSxHQUExQixDQUE4Qm9HLEdBQTlCLEtBQXNDLElBQUk5Ryx1Q0FBSixFQUR4QyxDQUQyQyxDQUkzQzs7QUFDQSxZQUFNRSxTQUFTLEdBQUcyRSxFQUFFLENBQUNuRSxHQUFILENBQU9FLEtBQVAsQ0FBbEI7O0FBRUEsVUFBSVYsU0FBUyxDQUFDZ0gscUJBQXFCLENBQUNDLFNBQXZCLENBQWIsRUFBZ0Q7QUFDOUMsY0FBTXhGLE1BQU0sR0FBRyxLQUFLcUUsUUFBTCxDQUFjdEYsR0FBZCxDQUFrQm9HLEdBQWxCLENBQWY7O0FBRUEsWUFBSSxDQUFDbkYsTUFBTCxFQUFhO0FBQ1gsZ0JBQU0sSUFBSWIsS0FBSixDQUFXLCtDQUE4Q2dHLEdBQUksWUFBV2xHLEtBQUssQ0FBQ04sSUFBSyxFQUFuRixDQUFOO0FBQ0Q7O0FBRURKLGlCQUFTLENBQUNnSCxxQkFBcUIsQ0FBQ0ssUUFBdkIsQ0FBVCxDQUEwQyxJQUExQyxFQUFnRDVGLE1BQWhEO0FBQ0QsT0FmMEMsQ0FpQjNDOzs7QUFDQSxXQUFLLE1BQU0sQ0FBQ2tILEtBQUQsRUFBUW5FLFNBQVIsQ0FBWCxJQUFpQyxLQUFLOUUsZ0JBQXRDLEVBQXdEO0FBQ3RELFlBQUtpSixLQUFELENBQW9CNUgsS0FBcEIsQ0FBMEI0RCxFQUFFLENBQUNpRSxTQUE3QixDQUFKLEVBQTZDO0FBQzNDcEUsbUJBQVMsQ0FBQzdELE1BQVYsQ0FBaUJpRyxHQUFqQjtBQUNEO0FBQ0Y7O0FBRURqQyxRQUFFLENBQUNJLE1BQUgsQ0FBVXJFLEtBQVYsRUF4QjJDLENBMEIzQzs7QUFDQSxXQUFLLE1BQU0sQ0FBQ2lJLEtBQUQsRUFBUW5FLFNBQVIsQ0FBWCxJQUFpQyxLQUFLOUUsZ0JBQXRDLEVBQXdEO0FBQ3RELFlBQUtpSixLQUFELENBQW9CNUgsS0FBcEIsQ0FBMEI0RCxFQUFFLENBQUNpRSxTQUE3QixDQUFKLEVBQTZDO0FBQzNDcEUsbUJBQVMsQ0FBQ0wsR0FBVixDQUFjeUMsR0FBZDtBQUNEO0FBQ0Y7O0FBRUQsYUFBTyxJQUFQO0FBQ0QsS0F2UmE7O0FBQ1osU0FBS2lDLEdBQUwsR0FBVyxJQUFJbkQsWUFBSixDQUFhLElBQWIsQ0FBWDtBQUNBLFNBQUt6RCxPQUFMLEdBQWUsSUFBSWlFLGVBQUosQ0FBWSxJQUFaLENBQWY7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBa1JFO0FBQ0Y7QUFDQTtBQUNFNEMsV0FBUyxDQUFDMUMsTUFBRCxFQUFlQyxVQUFmLEVBQTJDQyxRQUEzQyxFQUFvRTtBQUMzRSxTQUFLckUsT0FBTCxDQUFha0MsR0FBYixDQUFpQmlDLE1BQWpCLEVBQXlCQyxVQUF6QixFQUFxQ0MsUUFBckM7QUFFQSxXQUFPLElBQVA7QUFDRDs7QUFFRDNDLGdCQUFjLENBQUNsQyxNQUFELEVBQWdDO0FBQzVDLFVBQU1rRCxFQUFFLEdBQUcsSUFBSTdFLHVDQUFKLEVBQVg7QUFFQSxTQUFLOEUsb0JBQUwsQ0FBMEIxRSxHQUExQixDQUE4QnVCLE1BQU0sQ0FBQ0UsRUFBckMsRUFBeUNnRCxFQUF6QztBQUNBLFNBQUttQixRQUFMLENBQWM1RixHQUFkLENBQWtCdUIsTUFBTSxDQUFDRSxFQUF6QixFQUE2QkYsTUFBN0I7QUFFQSxXQUFPLElBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ0V5RCx1QkFBcUIsQ0FBQzBCLEdBQUQsRUFBc0I7QUFDekMsU0FBS2hDLG9CQUFMLENBQTBCMUUsR0FBMUIsQ0FBOEIwRyxHQUE5QixFQUFtQyxJQUFJOUcsdUNBQUosRUFBbkM7O0FBRUEsU0FBSyxNQUFNMEUsU0FBWCxJQUF3QixLQUFLOUUsZ0JBQUwsQ0FBc0JxRyxNQUF0QixFQUF4QixFQUF3RDtBQUN0RCxVQUFJdkIsU0FBUyxDQUFDdkQsR0FBVixDQUFjMkYsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCcEMsaUJBQVMsQ0FBQzdELE1BQVYsQ0FBaUJpRyxHQUFqQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTs7O0FBQ0VuQixjQUFZLEdBQWU7QUFDekIsVUFBTWhFLE1BQU0sR0FBRyxJQUFJdUIsYUFBSixDQUFXLElBQVgsQ0FBZjtBQUVBLFdBQU92QixNQUFQLENBSHlCLENBS3pCO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTs7O0FBQ0U2RCxlQUFhLENBQUNzQixHQUFELEVBQTJCO0FBQ3RDLFNBQUtoQyxvQkFBTCxDQUEwQmpFLE1BQTFCLENBQWlDaUcsR0FBakM7QUFDQSxTQUFLZCxRQUFMLENBQWNuRixNQUFkLENBQXFCaUcsR0FBckI7O0FBRUEsU0FBSyxNQUFNcEMsU0FBWCxJQUF3QixLQUFLOUUsZ0JBQUwsQ0FBc0JxRyxNQUF0QixFQUF4QixFQUF3RDtBQUN0RCxVQUFJdkIsU0FBUyxDQUFDdkQsR0FBVixDQUFjMkYsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCcEMsaUJBQVMsQ0FBQzdELE1BQVYsQ0FBaUJpRyxHQUFqQjtBQUNEO0FBQ0YsS0FScUMsQ0FVdEM7OztBQUNBLFNBQUssTUFBTSxDQUFDckMsR0FBRCxFQUFNQyxTQUFOLENBQVgsSUFBK0IsS0FBS0MsY0FBcEMsRUFBb0Q7QUFDbEQsVUFBSUQsU0FBUyxDQUFDdkQsR0FBVixDQUFjMkYsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCcEMsaUJBQVMsQ0FBQzdELE1BQVYsQ0FBaUJpRyxHQUFqQjtBQUNEOztBQUVELFVBQUlwQyxTQUFTLENBQUNwRCxJQUFWLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLGFBQUtxRCxjQUFMLENBQW9COUQsTUFBcEIsQ0FBMkI0RCxHQUEzQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7O0FBN1crQyxDOztDQ1RsRCIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG52YXIgZ2V0UmFuZG9tVmFsdWVzO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4gICAgLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSIsImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTsiLCJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiLCJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxudmFyIGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyKSB7XG4gIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICB2YXIgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiLCJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5KHJuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2NDsiLCJpbXBvcnQgRW50aXR5LCB7IEVudGl0eUlkIH0gZnJvbSBcIi4vRW50aXR5XCI7XG5pbXBvcnQgeyBDb21wVHlwZXMgfSBmcm9tICdpbnRlcmZhY2VzJztcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gJy4vQ29tcG9uZW50Q29sbGVjdGlvbic7XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBjbGFzc0lzQ29tcFR5cGUoY2w6IGFueSlcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tcG9uZW50SW5zdGFuY2U8VD4oXG4gIENsYXNzOiBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gVCxcbiAgY29tcDogYW55XG4pOiBjb21wIGlzIEluc3RhbmNlVHlwZTx0eXBlb2YgQ2xhc3M+IHtcbiAgaWYgKCFjb21wKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENsYXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbXBvbmVudE5hbWU8Q1QgZXh0ZW5kcyBDb21wVHlwZXM8Q1Q+PihcbiAgcG9zc2libGVOYW1lOiBhbnksXG4gIGVudGl0aWVzQnlDVHlwZXM6IE1hcDwoa2V5b2YgQ1QpW10sIFNldDxFbnRpdHlJZD4+XG4pOiBwb3NzaWJsZU5hbWUgaXMgQ1Rba2V5b2YgQ1RdIHtcbiAgLy8gc3RyaW5nXG4gIGlmICh0eXBlb2YgcG9zc2libGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgYSBvZiBlbnRpdGllc0J5Q1R5cGVzLmtleXMoKSkge1xuICAgIGlmIChhLmluY2x1ZGVzKHBvc3NpYmxlTmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCB7IGlzQ29tcG9uZW50SW5zdGFuY2UgfSBmcm9tIFwiLi9ndWFyZHNcIjtcblxudHlwZSBDbGFzczxUPiA9IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQgfTtcblxuLy8gQ1QgaXMgYSBVbmlvbiwgbGlrZSBgdHlwZSA9IHR5cGVvZiBGaXJzdENvbXBvbmVudCB8IHR5cGVvZiBTZWNvbmRDb21wb25lbnRgLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9uZW50Q29sbGVjdGlvbjxDVCBleHRlbmRzIENsYXNzPGFueT4+IHtcbiAgY29tcG9uZW50czogTWFwPHN0cmluZywgSW5zdGFuY2VUeXBlPENUPj4gPSBuZXcgTWFwKCk7XG5cbiAgLy8gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnRcbiAgLy8gYWRkID0gKGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPENUW2tleW9mIENUXT4pOiB2b2lkID0+IHtcbiAgYWRkID0gKGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPENUPik6IHZvaWQgPT4ge1xuICAgIHRoaXMuY29tcG9uZW50cy5zZXQoY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWUsIGNvbXBvbmVudCk7XG4gIH07XG5cbiAgdXBkYXRlID0gPFQ+KFxuICAgIGNsOiBDbGFzczxUPixcbiAgICBmdW5jOiAoYzogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4pID0+IEluc3RhbmNlVHlwZTx0eXBlb2YgY2w+XG4gICk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IGMgPSB0aGlzLmNvbXBvbmVudHMuZ2V0KGNsLm5hbWUpO1xuXG4gICAgaWYgKGlzQ29tcG9uZW50SW5zdGFuY2UoY2wsIGMpKSB7XG4gICAgICBjb25zdCB1cGRhdGVkQ29tcG9uZW50ID0gZnVuYyhjKTtcbiAgICAgIHRoaXMuY29tcG9uZW50cy5zZXQoY2wubmFtZSwgdXBkYXRlZENvbXBvbmVudCBhcyBJbnN0YW5jZVR5cGU8Q1Q+KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGNUeXBlIENsYXNzIG9mIGNvbXBvbmVudCB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmUgPSAoY1R5cGU6IENUKTogdm9pZCA9PiB7XG4gICAgdGhpcy5jb21wb25lbnRzLmRlbGV0ZShjVHlwZS5uYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgY29tcG9uZW50IHRoYXQgbWF0Y2hlcyB0aGUgcGFzc2VkIGNsYXNzLlxuICAgKiBXaWxsIHRocm93IGFuIGVycm9yIGlmIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBjb21wb25lbnRcbiAgICogZG9lc24ndCBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiwgc28gaWYgeW91IGRvbid0IGtub3cgaWYgaXQncyBzYWZlXG4gICAqIHRvIGdldCBhIGNvbXBvbmVudCwgeW91IHNob3VsZCB0ZXN0IHdpdGggaGFzKCkgb3IgaGFzQnlOYW1lKCkgZmlyc3QuXG4gICAqIFlvdSBoYXZlIGJlZW4gd2FybmVkLlxuICAgKiBAcGFyYW0gY2wgY29tcG9uZW50IENsYXNzIHJlZmVyZW5jZS5cbiAgICovXG4gIGdldCA9IDxUPihjbDogQ2xhc3M8VD4pOiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPiA9PiB7XG4gICAgY29uc3QgY29tcCA9IHRoaXMuY29tcG9uZW50cy5nZXQoY2wubmFtZSk7XG5cbiAgICBpZiAoaXNDb21wb25lbnRJbnN0YW5jZTxUPihjbCwgY29tcCkpIHtcbiAgICAgIHJldHVybiBjb21wO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb21wb25lbnRDb2xsZWN0aW9uIGRvZXMgbm90IGhhdmUgY29tcG9uZW50IG9mIHR5cGUgJHtjbC5uYW1lfWBcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBvc3NpYmxlIG90aGVyIHdheSB0byB3cml0ZSBhIGdldCBtZXRob2QgdGhhdCBtYWludGFpbnMgdGhlIHR5cGUgb2YgdGhlXG4gIC8vIENvbXBvbmVudCB0aHJvdWdob3V0LiBLZWVwaW5nIGFyb3VuZCBmb3Igbm93IGFyZSBhIHJlZmVyZW5jZS5cbiAgLy8gZ2V0PFUgZXh0ZW5kcyBDVD4oY29tcENsYXNzOiBDbGFzczxVPik6IFUge1xuICAvLyAgIGlmICghdGhpcy5jb21wb25lbnRzLmhhcyhjb21wQ2xhc3MubmFtZSkpIHtcbiAgLy8gICAgIHRocm93IG5ldyBFcnJvcihcbiAgLy8gICAgICAgYENvbXBvbmVudENvbGxlY3Rpb24gZG9lcyBub3QgaGF2ZSBjb21wb25lbnQgb2YgdHlwZSAke2NvbXBDbGFzcy5uYW1lfWBcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuXG4gIC8vICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5nZXQoY29tcENsYXNzLm5hbWUpISBhcyB1bmtub3duIGFzIFU7XG4gIC8vIH1cblxuICAvKipcbiAgICogVGVzdCB0byBzZWUgaWYgdGhlIGNvbGxlY3Rpb24gY29udGFpbnMgYSBzcGVjaWZpYyBDbGFzcyBvciBDbGFzc2VzLlxuICAgKiBAcGFyYW0gY1R5cGUgY29tcG9uZW50IENsYXNzLCBvciBhcnJheSBvZiBjb21wb25lbnQgQ2xhc3Nlcy5cbiAgICovXG4gIGhhcyA9IChjVHlwZTogQ1QgfCBDVFtdKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY1R5cGUpXG4gICAgICA/IGNUeXBlLmV2ZXJ5KChjdCkgPT4gdGhpcy5jb21wb25lbnRzLmhhcyhjdC5uYW1lKSA9PT0gdHJ1ZSlcbiAgICAgIDogdGhpcy5jb21wb25lbnRzLmhhcyhjVHlwZS5uYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB0byBzZWUgaWYgdGhlIGNvbGxlY3Rpb24gaGFzIGEgY29tcG9uZW50IGluc3RhbmNlIGJhc2VkIG9uIGFcbiAgICogY2xhc3MgbmFtZS4gU29tZSBidWlsZCBzdGVwcy9taW5pZmllcnMgd2lsbCBjaGFuZ2UgdGhlIG5hbWUgb2YgQ2xhc3NlcyxcbiAgICogc28gaXQncyB1c3VhbGx5IGJlc3QgdG8gcGFzcyBpbiBhIE15Q2xhc3MubmFtZSBpbnN0ZWFkIG9mICdNeUNsYXNzJy5cbiAgICogQHBhcmFtIGNOYW1lIFRoZSBuYW1lIG9mIGEgQ2xhc3MsIG9yIGFycmF5IG9mIENsYXNzIG5hbWVzLlxuICAgKi9cbiAgaGFzQnlOYW1lID0gKGNOYW1lOiBzdHJpbmcgfCBzdHJpbmdbXSk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNOYW1lKVxuICAgICAgPyBjTmFtZS5ldmVyeShjdCA9PiB0aGlzLmNvbXBvbmVudHMuaGFzKGN0KSA9PT0gdHJ1ZSlcbiAgICAgIDogdGhpcy5jb21wb25lbnRzLmhhcyhjTmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcG9uZW50IHR5cGUgbmFtZXMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIHVzZWQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqL1xuICBnZXQgY29tcG9uZW50VHlwZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5jb21wb25lbnRzLmtleXMoKV07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG51bWJlciBvZiBjb21wb25lbnRzIHRoYXQgYXJlIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzLnNpemU7XG4gIH1cblxuICB0b0RldkNvbXBvbmVudHMoKTogUmVjb3JkPHN0cmluZywgSW5zdGFuY2VUeXBlPENUPj4ge1xuICAgIGNvbnN0IG9iajogUmVjb3JkPHN0cmluZywgSW5zdGFuY2VUeXBlPENUPj4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtjb21wTmFtZSwgY29tcF0gb2YgdGhpcy5jb21wb25lbnRzKSB7XG4gICAgICBvYmpbY29tcE5hbWVdID0gY29tcDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG4iLCJpbXBvcnQgV29ybGQsIHsgQ2xhc3MgfSBmcm9tIFwiLi9Xb3JsZFwiO1xuaW1wb3J0IEVudGl0eSBmcm9tIFwiLi9FbnRpdHlcIjtcbmltcG9ydCB7IFRhZyB9IGZyb20gXCIuL1RhZ1wiO1xuXG5pbnRlcmZhY2UgRGV2RW50aXR5VGFibGVSb3cge1xuICBpZDogc3RyaW5nO1xuICBjb21wb25lbnRzOiBzdHJpbmc7XG4gIHRhZ3M6IHN0cmluZztcbiAgc3lzdGVtczogc3RyaW5nO1xufVxuXG5jbGFzcyBEZXZFbnRpdHk8Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PiB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgY29tcG9uZW50czogUmVjb3JkPHN0cmluZywgSW5zdGFuY2VUeXBlPENUPj47XG5cbiAgdGFnczogVGFnW107XG5cbiAgc3lzdGVtczogc3RyaW5nW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihlbnRpdHk6IEVudGl0eTxDVD4sIHdvcmxkOiBXb3JsZDxDVD4pIHtcbiAgICB0aGlzLmlkID0gZW50aXR5LmlkO1xuICAgIHRoaXMuY29tcG9uZW50cyA9IGVudGl0eS5jb21wb25lbnRzLnRvRGV2Q29tcG9uZW50cygpLFxuICAgIHRoaXMudGFncyA9IFsuLi5lbnRpdHkudGFnc107XG5cbiAgICBjb25zdCBjb21wTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbXBvbmVudHMpO1xuXG4gICAgZm9yIChjb25zdCBbc3lzdGVtTmFtZSwgY05hbWVzXSBvZiB3b3JsZC5zeXN0ZW1zLmNvbXBOYW1lc0J5U3lzdGVtTmFtZSkge1xuICAgICAgaWYgKGNOYW1lcy5ldmVyeSgoY05hbWUpID0+IGNvbXBOYW1lcy5pbmNsdWRlcyhjTmFtZSkpKSB7XG4gICAgICAgIHRoaXMuc3lzdGVtcy5wdXNoKHN5c3RlbU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRvVGFibGVSb3coKTogRGV2RW50aXR5VGFibGVSb3cge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGNvbXBvbmVudHM6IE9iamVjdC5rZXlzKHRoaXMuY29tcG9uZW50cykuam9pbihcIiwgXCIpLFxuICAgICAgdGFnczogdGhpcy50YWdzLmpvaW4oXCIsIFwiKSxcbiAgICAgIHN5c3RlbXM6IHRoaXMuc3lzdGVtcy5qb2luKCcsICcpLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGV2RW50aXR5O1xuIiwiZXhwb3J0IHR5cGUgU3RhdGUgPSBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2w7XG5cbmV4cG9ydCB0eXBlIFRyYW5zaXRpb25zPFMgZXh0ZW5kcyBTdGF0ZSwgRD4gPSBSZWNvcmQ8XG4gIFMsXG4gIChkYXRhOiBEIHwgdW5kZWZpbmVkLCBjdXJyZW50OiBTKSA9PiBTXG4+O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW1wbGVGU008UyBleHRlbmRzIFN0YXRlLCBEID0gdW5kZWZpbmVkPiB7XG4gIGN1cnJlbnQ6IFM7XG5cbiAgaW5pdGFsOiBTO1xuXG4gIHRyYW5zaXRpb25zOiBUcmFuc2l0aW9uczxTLCBEPjtcblxuICBjb25zdHJ1Y3Rvcihpbml0aWFsU3RhdGU6IFMsIHRyYW5zaXRpb25zOiBUcmFuc2l0aW9uczxTLCBEPikge1xuICAgIHRoaXMuaW5pdGFsID0gaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMuY3VycmVudCA9IGluaXRpYWxTdGF0ZTtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnM7XG4gIH1cblxuICBuZXh0KGRhdGE/OiBEKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbnNbdGhpcy5jdXJyZW50XSkge1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy50cmFuc2l0aW9uc1t0aGlzLmN1cnJlbnRdKGRhdGEsIHRoaXMuY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5pbml0YWw7XG4gIH1cblxuICBpcyhjaGVja1N0YXRlOiBTKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudCA9PT0gY2hlY2tTdGF0ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSBcInV1aWRcIjtcbmltcG9ydCBXb3JsZCBmcm9tIFwiLi9Xb3JsZFwiO1xuaW1wb3J0IENvbXBvbmVudENvbGxlY3Rpb24gZnJvbSBcIi4vQ29tcG9uZW50Q29sbGVjdGlvblwiO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSBcIi4vVGFnXCI7XG4vLyBpbXBvcnQgeyBDb21wVHlwZXMgfSBmcm9tICdpbnRlcmZhY2VzJztcbmltcG9ydCBEZXZFbnRpdHkgZnJvbSBcIi4vRGV2RW50aXR5XCI7XG5cbmltcG9ydCBTaW1wbGVGU00gZnJvbSBcIi4vU2ltcGxlRlNNXCI7XG5cbmV4cG9ydCB0eXBlIEVudGl0eUlkID0gc3RyaW5nO1xuXG50eXBlIENsYXNzPFQ+ID0geyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVCB9O1xuXG50eXBlIEVudGl0eVN0YXRlID1cbiAgfCBcImNyZWF0aW5nXCJcbiAgfCBcImNyZWF0ZWRcIlxuICB8IFwiZGVzdHJveWluZ1wiXG4gIHwgXCJkZXN0cm95ZWRcIlxuICB8IFwiZXJyb3JcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50aXR5PENUIGV4dGVuZHMgQ2xhc3M8YW55Pj4ge1xuICBwcml2YXRlIF9pZDogc3RyaW5nO1xuICBwcml2YXRlIF93b3JsZDogV29ybGQ8Q1Q+O1xuXG4gIHByaXZhdGUgX2Vycm9yOiBFcnJvciB8IG51bGw7XG5cbiAgcHJpdmF0ZSBfc3RhdGU6IFNpbXBsZUZTTTxFbnRpdHlTdGF0ZT47XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMuX2lkID0gdXVpZHY0KCk7XG4gICAgdGhpcy5fd29ybGQgPSB3b3JsZDtcblxuICAgIHRoaXMuX2Vycm9yID0gbnVsbDtcblxuICAgIHRoaXMuX3N0YXRlID0gbmV3IFNpbXBsZUZTTTxFbnRpdHlTdGF0ZT4oXCJjcmVhdGluZ1wiLCB7XG4gICAgICBjcmVhdGluZzogKCkgPT4gKHRoaXMuX2Vycm9yID8gXCJlcnJvclwiIDogXCJjcmVhdGVkXCIpLFxuICAgICAgY3JlYXRlZDogKCkgPT4gXCJkZXN0cm95aW5nXCIsXG4gICAgICBkZXN0cm95aW5nOiAoKSA9PiAodGhpcy5fZXJyb3IgPyBcImVycm9yXCIgOiBcImRlc3Ryb3llZFwiKSxcbiAgICAgIGRlc3Ryb3llZDogKCkgPT4gXCJkZXN0cm95ZWRcIixcbiAgICAgIGVycm9yOiAoKSA9PiBcImVycm9yXCIsXG4gICAgfSk7XG5cbiAgICAvKlxuICAgIFJlZ2lzdGVyaW5nIHdpdGggdGhlIFdvcmxkLlxuICAgICovXG4gICAgdGhpcy5fd29ybGQucmVnaXN0ZXJFbnRpdHkodGhpcyk7XG5cbiAgICB0aGlzLl9zdGF0ZS5uZXh0KCkgLy8gY3JlYXRlZFxuXG4gICAgdGhpcy5vbkNyZWF0ZSgpO1xuXG4gIH1cblxuICBnZXQgc3RhdGUoKTogRW50aXR5U3RhdGUge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5jdXJyZW50O1xuICB9XG5cbiAgY2hlY2tTdGF0ZShwb3NzaWJsZVN0YXRlOiBFbnRpdHlTdGF0ZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5pcyhwb3NzaWJsZVN0YXRlKTtcbiAgfVxuXG4gIC8qIExpZmVDeWNsZSBtZXRob2RzLCBtZWFudCB0byBiZSBvdmVycmlkZGVuICovXG5cbiAgb25DcmVhdGUoKTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIG9uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25Db21wb25lbnRBZGQoKTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIG9uQ29tcG9uZW50VXBkYXRlKCk6IHZvaWQge1xuICAgIC8vIGFic3RyYWN0XG4gIH1cblxuICBvbkNvbXBvbmVudFJlbW92ZSgpOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNvbXBvbmVudCB0byBhbiBFbnRpdHksIGRvaC5cbiAgICovXG4gIGFkZChjb21wb25lbnQ6IEluc3RhbmNlVHlwZTxDVD4pOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5zZXQodGhpcy5faWQsIGNvbXBvbmVudCk7XG5cbiAgICBpZiAoY29tcG9uZW50W1N5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5pc1RyYWNrZWRcIildKSB7XG4gICAgICBjb21wb25lbnRbU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50LnNldFdvcmxkXCIpXSh0aGlzLl93b3JsZCk7XG5cbiAgICAgIGNvbXBvbmVudFtTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQub25BZGRcIildKHRoaXMuX3dvcmxkLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0YWcgdG8gYSBjb21wb25lbnRcbiAgICovXG4gIGFkZFRhZyh0YWc6IFRhZyk6IHRoaXMge1xuICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmhhcyh0YWcpXG4gICAgICA/IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpXG4gICAgICA6IG5ldyBTZXQ8RW50aXR5SWQ+KCk7XG5cbiAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICBlbnRpdHlTZXQuYWRkKHRoaXMuX2lkKTtcbiAgICAgIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLnNldCh0YWcsIGVudGl0eVNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhbiBlbnRpdHkgaGFzIGEgY29tcG9uZW50IHJlbGF0ZWQgdG8gaXQuXG4gICAqL1xuICBoYXMoY1R5cGU6IENUKTogYm9vbGVhbiB7XG4gICAgY29uc3QgY2MgPVxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICByZXR1cm4gY2MuaGFzKGNUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgYW4gZW50aXR5IHRhZ2dlZCB3aXRoIGEgZ2l2ZW4gdGFnLlxuICAgKi9cbiAgaGFzVGFnKHRhZzogVGFnKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmhhcyh0YWcpKSB7XG4gICAgICBjb25zdCBlbnRpdHlTZXQgPSB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5nZXQodGFnKTtcbiAgICAgIGlmIChlbnRpdHlTZXQpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eVNldC5oYXModGhpcy5faWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBjb21wb25lbnQgdGhhdCBiZWxvbmdzIHRvIGFuIGVudGl0eS5cbiAgICovXG4gIGdldDxUPihjbDogQ2xhc3M8VD4pOiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPiB7XG4gICAgY29uc3QgY2MgPVxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICBjb25zdCBjb21wb25lbnQgPSBjYy5nZXQ8VD4oY2wpO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGNvbXBvbmVudHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gYW4gZW50aXR5LCB2aWEgYSBDb21wb25lbnRDb2xsZWN0aW9uXG4gICAqL1xuICBnZXRBbGwoKTogQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl93b3JsZC5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQodGhpcy5faWQpIHx8XG4gICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29tcG9uZW50IGZyb20gYW4gZW50aXR5LlxuICAgKiBAcGFyYW0gY1R5cGUgQSBjb21wb25lbnQgY2xhc3MsIGVnIE15Q29tcG9uZW50XG4gICAqL1xuICByZW1vdmUoY1R5cGU6IENUKTogdGhpcyB7XG4gICAgdGhpcy5fd29ybGQucmVtb3ZlKHRoaXMuX2lkLCBjVHlwZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB0YWcgZnJvbSBhbiBlbnRpdHlcbiAgICovXG4gIHJlbW92ZVRhZyh0YWc6IFRhZyk6IHRoaXMge1xuICAgIGlmICh0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5oYXModGFnKSkge1xuICAgICAgY29uc3QgZW50aXR5U2V0ID0gdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZyk7XG5cbiAgICAgIGlmIChlbnRpdHlTZXQpIHtcbiAgICAgICAgZW50aXR5U2V0LmRlbGV0ZSh0aGlzLl9pZCk7XG5cbiAgICAgICAgaWYgKGVudGl0eVNldC5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ2xlYXJzIGFsbCBjb21wb25lbnRzIGZyb20gYW4gRW50aXR5ICovXG4gIGNsZWFyKCk6IHRoaXMge1xuICAgIHRoaXMuX3dvcmxkLmNsZWFyRW50aXR5Q29tcG9uZW50cyh0aGlzLl9pZCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHRhZ3Mgb24gYW4gZW50aXR5XG4gICAqL1xuICBjbGVhclRhZ3MoKTogdGhpcyB7XG4gICAgZm9yIChjb25zdCBbdGFnLCBlbnRpdHlTZXRdIG9mIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmVudHJpZXMoKSkge1xuICAgICAgZW50aXR5U2V0LmRlbGV0ZSh0aGlzLl9pZCk7XG5cbiAgICAgIGlmIChlbnRpdHlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5kZWxldGUodGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9zdGF0ZS5pcyhcImNyZWF0ZWRcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFY3N0YXRpYzogVW5hYmxlIHRvIGRlc3Ryb3kgaWYgaXQgaXNuJ3QgY3JlYXRlZCwgb3IgYWxyZWFkeSBkZXN0cm95ZWRcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0ZS5uZXh0KCk7IC8vIGRlc3Ryb3lpbmdcblxuICAgIC8vIFRoaXMgd2lsbCBwcm9iYWJseSBiZSBkZWZlcnJlZCBzbyB0aGF0IFN5c3RlbXMgY2FuIHdvcmsgb24gaXQuXG4gICAgdGhpcy5fd29ybGQuZGVzdHJveUVudGl0eSh0aGlzLl9pZCk7IC8vIHNob3VsZCByZXR1cm4gYW4gZXJyb3I/P1xuXG4gICAgdGhpcy5vbkRlc3Ryb3koKTsgLy8gYXNzdW1pbmcgZm9yIG5vdyB0aGF0IHRoaXMgaXMgYmVzdCBkb25lIGFmdGVyIGFjdHVhbGx5IHJlbW92aW5nIHRoZSBlbnRpdHkgZnJvbSB0aGUgd29ybGQuXG5cbiAgICBpZiAodGhpcy5fc3RhdGUuaXMoXCJkZXN0cm95aW5nXCIpKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5uZXh0KCk7IC8vIGRlc3Ryb3llZFxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUuaXMoXCJlcnJvclwiKSAmJiB0aGlzLl9lcnJvcikge1xuICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggZXJyb3IhIVxuICAgIH1cbiAgfVxuXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuXG4gIGdldCB3b3JsZCgpOiBXb3JsZDxDVD4ge1xuICAgIHJldHVybiB0aGlzLl93b3JsZDtcbiAgfVxuXG4gIGRlc3Ryb3lJbW1lZGlhdGVseSgpOiB2b2lkIHtcbiAgICAvLyBwbGFjZWhvbGRlciBmb3IgbWV0aG9kIHRoYXQgZG9lc24ndCB3YWl0IGZvciBlbnRpdHkgdG8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsXG4gICAgLy8gZGVzdG9yeSBwaXBlbGluZSBhbmQgcHJvY2Vzcy5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGNvbXBvbmVudHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gYW4gZW50aXR5LCB2aWEgYSBDb21wb25lbnRDb2xsZWN0aW9uLlxuICAgKiBEb2VzIHRoZSBzYW1lIHRoaW5nIGFzIGVudGl0eUluc3RhbmNlLmdldEFsbCgpLlxuICAgKi9cbiAgZ2V0IGNvbXBvbmVudHMoKTogQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl93b3JsZC5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQodGhpcy5faWQpIHx8XG4gICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGFsbCB0aGUgdGFncyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGlzIGVudGl0eS5cbiAgICovXG4gIGdldCB0YWdzKCk6IFNldDxUYWc+IHtcbiAgICBjb25zdCB0YWdzID0gbmV3IFNldDxUYWc+KCk7XG4gICAgZm9yIChjb25zdCBbdGFnLCBlbnRpdHlTZXRdIG9mIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGVudGl0eVNldC5oYXModGhpcy5faWQpKSB7XG4gICAgICAgIHRhZ3MuYWRkKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBFbnRpdHkgdG8gYSBEZXZFbnRpdHkuIFZlcnkgaGVscGZ1bCBpbiBmb3IgZGVidWdnaW5nLlxuICAgKi9cbiAgdG9EZXZFbnRpdHkoKTogRGV2RW50aXR5PENUPiB7XG4gICAgcmV0dXJuIG5ldyBEZXZFbnRpdHk8Q1Q+KHRoaXMsIHRoaXMuX3dvcmxkKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW50aXR5PENUIGV4dGVuZHMgQ2xhc3M8YW55Pj4oXG4gIHdvcmxkOiBXb3JsZDxDVD5cbik6IEVudGl0eTxDVD4ge1xuICBjb25zdCBlbnRpdHkgPSBuZXcgRW50aXR5PENUPih3b3JsZCk7XG5cbiAgcmV0dXJuIGVudGl0eTtcbn1cbiIsImltcG9ydCBXb3JsZCwgeyBDbGFzcyB9IGZyb20gJy4vV29ybGQnO1xuaW1wb3J0IERldkVudGl0eSBmcm9tICcuL0RldkVudGl0eSc7XG5cbmludGVyZmFjZSBEZXZTeXN0ZW1Db21wcyB7XG4gIHN5c3RlbTogc3RyaW5nO1xuICBjb21wb25lbnRzOiBzdHJpbmc7XG59XG5cblxuY2xhc3MgRGV2VG9vbHM8Q1QgZXh0ZW5kcyBDbGFzczxhbnk+PiB7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgfVxuICAvKipcbiAgICogZGlzcGxheSB0aGUgYWxsIHN5c3RlbXMgb2YgdGhlIHdvcmxkLCBhbmQgdGhlIGNvbXBvbmVudHMgcmVxdWlyZWQgYnkgZWFjaCBzeXN0ZW0uXG4gICAqIFN1cGVyIGhlbHBmdWwgdG8gdXNlIHdpdGggY29uc29sZS50YWJsZSgpXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zb2xlLnRhYmxlKHdvcmxkLmRldi5zeXN0ZW1Db21wb25lbnRzKTtcbiAgICogYGBgXG4gICAqL1xuICBnZXQgc3lzdGVtQ29tcG9uZW50cygpOiBEZXZTeXN0ZW1Db21wc1tdIHtcbiAgICBjb25zdCBjb21wc0J5U3lzdGVtcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBbc3lzdGVtLCBjb21wTmFtZXNdIG9mIHRoaXMud29ybGQuc3lzdGVtcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUpIHtcbiAgICAgIGNvbXBzQnlTeXN0ZW1zLnB1c2goeyBzeXN0ZW0sIGNvbXBvbmVudHM6IGNvbXBOYW1lcy5qb2luKFwiLCBcIikgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBzQnlTeXN0ZW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhcnJheSBvZiBEZXZFbnRpdGVzLiBDYW4gYmUgdmVyeSBoZWxwZnVsIGZvciB0aGluZ3MgbGlrZSBpbnNwZWN0aW5nIGNvbXBvbmVudCBzdGF0ZSxcbiAgICogYW5kIHdoaWNoIHN5c3RlbXMgd2lsbCBiZSBjYWxsZWQgb24gYW4gZW50aXR5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMpO1xuICAgKlxuICAgKiAvLyBQcm8gdGlwISB0cnkgZGlzcGxheWluZyBhIHRhYmxlIG9mIGVudGl0aWVzIHdpdGggY29uc29sZS50YWJsZSBhbmQgRGV2RW50aXR5LnRvVGFibGVSb3coKS5cbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMubWFwKGRldkVudGl0eSA9PiBkZXZFbnRpdHkudG9UYWJsZVJvdygpKSk7XG4gICAqIGBgYFxuICAgKi9cblxuICBnZXQgZW50aXRpZXMoKTogRGV2RW50aXR5PENUPltdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMud29ybGQuZW50aXRpZXMudmFsdWVzKCldLm1hcCgoZSkgPT4gZS50b0RldkVudGl0eSgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZXZUb29scztcbiIsImltcG9ydCBFbnRpdHksIHsgRW50aXR5SWQgfSBmcm9tIFwiLi9FbnRpdHlcIjtcbmltcG9ydCBXb3JsZCwgeyBDbGFzcyB9IGZyb20gXCIuL1dvcmxkXCI7XG5pbXBvcnQgQ29tcG9uZW50Q29sbGVjdGlvbiBmcm9tIFwiLi9Db21wb25lbnRDb2xsZWN0aW9uXCI7XG5cbi8qKlxuICogQXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZCBpbnRvIGEgU3lzdGVtIGZ1bmN0aW9uIG9uIGVhY2ggaXRlcmF0aW9uLlxuICogVGhpcyBpcyBob3cgeW91IGFjY2VzIHRoaW5ncyBsaWtlIHRoZSBlbnRpdHkgdGhhdCBwYXJ0aWN1bGFyIGVudGl0eSB0byBhY3Qgb24sXG4gKiBhcyB3ZWxsIGFzIHNvbWUgb3RoZXIgaGVscGZ1bCBwYXJhbXMgbGlrZSBpZiB0aGUgZW50aXR5IGlzIHRoZSBmaXJzdCBvciBsYXN0IGVudGl0eVxuICogaW4gdGhlIGdyb3VwIG9mIGVudGl0aWVzIHRoYXQgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeXN0ZW1GdW5jQXJnczxDVCBleHRlbmRzIENsYXNzPGFueT4+IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGVudGl0eSBiZWluZyBpdGVyYXRlZC5cbiAgICovXG4gIGVudGl0eTogRW50aXR5PENUPjtcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnRzIHRoYXQgYmVsb25nIHRvIHRoZSBlbnRpdHlcbiAgICovXG4gIGNvbXBvbmVudHM6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+O1xuICAvKipcbiAgICogVGhlIFdvcmxkIGluc3RhbmNlLlxuICAgKiBVc2UgdGhpcyB0byBhY2Nlc3Mgb3RoZXIgZW50aXRpZXMuXG4gICAqL1xuICB3b3JsZDogV29ybGQ8Q1Q+O1xuICBpbmRleDogbnVtYmVyO1xuICBzaXplOiBudW1iZXI7XG4gIC8qKlxuICAgKiBJcyB0aGUgZmlyc3QgZW50aXR5IHRvIGJlIGl0ZXJhdGVkIG9uIHRoaXMgcnVuIG9mIGEgc3lzdGVtLlxuICAgKiBIZWxwZnVsIGZvciBzZXR0aW5nIHVwIHN0YXRlIHRoYXQgaXMgdGhlIHNhbWUgZm9yIGFsbCBlbnRpdGllcyBvbmx5IG9uY2UuXG4gICAqL1xuICBpc0ZpcnN0OiBib29sZWFuO1xuICAvKipcbiAgICogSXMgdGhlIGxhc3QgZW50aXR5IHRvIGJlIGl0ZXJhdGVkIG9uIHRoaXMgcnVuIG9mIGEgc3lzdGVtLlxuICAgKiBDYW4gYmUgaGVscGZ1bCB0byB0ZWFyIGRvd24gYW55dGhpbmcgdGhhdCBzaG91bGQgYmUgZGVhbHQgd2l0aCBhZnRlciBhbGwgdGhlIGVudGl0ZXMgaGF2ZSByYW4uXG4gICAqL1xuICBpc0xhc3Q6IGJvb2xlYW47XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIHN5c3RlbSBpcyBydW4uXG4gKi9cbmV4cG9ydCB0eXBlIFN5c3RlbUZ1bmM8Q1QgZXh0ZW5kcyBDbGFzczxDVD4+ID0gKFxuICBzeXRlbUZ1bmNBcmdzOiBTeXN0ZW1GdW5jQXJnczxDVD5cbikgPT4gdm9pZDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3lzdGVtczxDVCBleHRlbmRzIENsYXNzPGFueT4+IHtcbiAgd29ybGQ6IFdvcmxkPENUPjtcblxuICBzeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lOiBNYXA8c3RyaW5nLCBTeXN0ZW1GdW5jPENUPj47IC8vIGRvdWJsZSBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBtYXBzIGFyZSBvcmRlcmVkLlxuXG4gIGNvbXBOYW1lc0J5U3lzdGVtTmFtZTogTWFwPHN0cmluZywgc3RyaW5nW10+O1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZDxDVD4pIHtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5zeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgYWRkKGNUeXBlczogQ1RbXSwgc3lzdGVtRnVuYzogU3lzdGVtRnVuYzxDVD4sIGZ1bmNOYW1lPzogc3RyaW5nKTogdGhpcyB7XG4gICAgY29uc3QgY05hbWVzID0gY1R5cGVzLm1hcCgoY3QpID0+IGN0Lm5hbWUpO1xuXG4gICAgXG4gICAgbGV0IG5hbWUgPSBzeXN0ZW1GdW5jLm5hbWU7XG4gICAgaWYgKHN5c3RlbUZ1bmMubmFtZSA9PT0gJycpIHtcbiAgICAgIC8vIFN1cGVyIGJydXRlIGZvcmNlLCBhbmQgbWlnaHQgbGVhZCB0byBlcnJvcnMgaW4gdGhlIGZ1dHVyZSwgYnV0IGZvciBub3dcbiAgICAgIC8vIHVzaW5nIHRoZSBzdHJpbmdpZmllZCBzeXN0ZW0gZnVuY3Rpb24gaWYgdGhlIGZ1bmN0aW9uIGRvZXNuJ3QgYWxyZWFkeSBoYXZlIGEgbmFtZS5cbiAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIHVzZWQgYXMgYSBzeXN0ZW0gZnVuY3Rpb24uXG4gICAgICAvLyBNaWdodCBiZSBnb29kIHRvIGZpZ3VyZSBvdXQgaG93IHRvIGdldCBhIGhhc2ggb2YgdGhlIGZ1bmN0aW9uIHN0cmluZy5cbiAgICAgIG5hbWUgPSBzeXN0ZW1GdW5jLnRvU3RyaW5nKCkuc2xpY2UoMCwgMzApO1xuICAgIH1cblxuICAgIGlmIChmdW5jTmFtZSkge1xuICAgICAgbmFtZSA9IGZ1bmNOYW1lO1xuICAgIH1cblxuICAgIHRoaXMuc3lzdGVtRnVuY0J5U3lzdGVtTmFtZS5zZXQobmFtZSwgc3lzdGVtRnVuYyk7XG4gICAgdGhpcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUuc2V0KG5hbWUsIGNOYW1lcyk7XG4gICAgdGhpcy53b3JsZC5lbnRpdGllc0J5Q1R5cGVzLnNldChjTmFtZXMsIG5ldyBTZXQ8RW50aXR5SWQ+KCkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBydW4oKTogdm9pZCB7XG5cbiAgICAvLyBUT0RPOiBNaWdodCBiZSBjb29sIHRvIGFkZCBhIHdheSB0byBzdG9wIHRoZSBzeXN0ZW1zIGxvb3Agd2hlbiBpbiBkZXYuXG4gICAgLy8gICAgICAgTWF5YmUgc29tZXRoaW5nIGxpa2Ugd29ybGQuZGV2LnN0b3AoKSBvciBwYXVzZSgpLlxuICAgIGZvciAoY29uc3QgW1xuICAgICAgZnVuY05hbWUsXG4gICAgICBzeXN0ZW1GdW5jLFxuICAgIF0gb2YgdGhpcy5zeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lLmVudHJpZXMoKSkge1xuICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLndvcmxkLmVudGl0aWVzQnlDVHlwZXMuc2l6ZTtcbiAgICAgIGNvbnN0IGNOYW1lcyA9IHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lLmdldChmdW5jTmFtZSkgfHwgW107XG4gICAgICBjb25zdCBjVHlwZUFycnMgPSB0aGlzLndvcmxkLmVudGl0aWVzQnlDVHlwZXMuZ2V0KGNOYW1lcykgfHwgbmV3IFNldCgpO1xuXG4gICAgICBmb3IgKGNvbnN0IGVpZCBvZiBjVHlwZUFycnMpIHtcbiAgICAgICAgY29uc3QgYXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+ID0ge1xuICAgICAgICAgIGVudGl0eTogdGhpcy53b3JsZC5lbnRpdGllcy5nZXQoZWlkKSB8fCBuZXcgRW50aXR5PENUPih0aGlzLndvcmxkKSxcbiAgICAgICAgICBjb21wb25lbnRzOlxuICAgICAgICAgICAgdGhpcy53b3JsZC5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZWlkKSB8fFxuICAgICAgICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCksXG4gICAgICAgICAgd29ybGQ6IHRoaXMud29ybGQsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBpc0ZpcnN0OiBpbmRleCA9PT0gMCxcbiAgICAgICAgICBpc0xhc3Q6IGluZGV4ICsgMSA9PT0gc2l6ZSxcbiAgICAgICAgfTtcblxuICAgICAgICBzeXN0ZW1GdW5jKGFyZ3MpO1xuXG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgV29ybGQsIHsgQ2xhc3MgfSBmcm9tIFwiLi9Xb3JsZFwiO1xuaW1wb3J0IEVudGl0eSBmcm9tIFwiLi9FbnRpdHlcIjtcblxuLy8gV2FpdGluZyBmb3IgVHlwZXNjcmlwdCA0LjIgdG8gY29tZSBvdXQgc28gdGhhdCBTeW1ib2xzIGFyZSBzdXBwb3JkZWQga2V5cy5cbmV4cG9ydCBjb25zdCBUcmFja2VkQ29tcFN5bWJvbEtleXMgPSB7XG4gIGlzVHJhY2tlZDogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50LmlzVHJhY2tlZFwiKSxcbiAgd29ybGQ6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC53b3JsZFwiKSxcbiAgc2V0V29ybGQ6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5zZXRXb3JsZFwiKSxcbiAgb25BZGQ6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5vbkFkZFwiKSxcbiAgb25VcGRhdGU6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5vblVwZGF0ZVwiKSxcbiAgb25SZW1vdmU6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5vblJlbW92ZVwiKSxcbn0gYXMgY29uc3Q7XG5cbi8vQHRzLWlnbm9yZVxudHlwZSBUcmFja2VkQ29tcG9uZW50PENUIGV4dGVuZHMgQ2xhc3M+ID0ge1xuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy5pc1RyYWNrZWRdOiBib29sZWFuO1xuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy5zZXRXb3JsZF06ICh3b3JsZDogV29ybGQ8Q1Q+KSA9PiB2b2lkO1xuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy53b3JsZF06IFdvcmxkPENUPjtcbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMub25BZGRdOiAoXG4gICAgd29ybGQ6IFdvcmxkPENUPixcbiAgICBlbnRpdHk6IEVudGl0eTxDVD5cbiAgKSA9PiB2b2lkO1xuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vblJlbW92ZV06IChcbiAgICB3b3JsZDogV29ybGQ8Q1Q+LFxuICAgIGVudGl0eTogRW50aXR5PENUPlxuICApID0+IHZvaWQ7XG59O1xuXG5pbnRlcmZhY2UgQWRkRXZlbnRBcmdzPFQsIENUIGV4dGVuZHMgQ2xhc3M+IHtcbiAgY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8Q2xhc3M8VD4+O1xuICBlbnRpdHk6IEVudGl0eTxDVD47XG4gIHdvcmxkOiBXb3JsZDxDVD47XG59XG5cbmludGVyZmFjZSBVcGRhdGVFdmVudEFyZ3M8VCwgQ1QgZXh0ZW5kcyBDbGFzcz4ge1xuICBjb21wb25lbnQ6IEluc3RhbmNlVHlwZTxDbGFzczxUPj47XG4gIHdvcmxkOiBXb3JsZDxDVD47XG4gIHByZXZpb3VzVmFsOiBUW2tleW9mIFRdO1xuICBwcm9wZXJ0eToga2V5b2YgVDtcbn1cblxuaW50ZXJmYWNlIFJlbW92ZUV2ZW50QXJnczxULCBDVCBleHRlbmRzIENsYXNzPiB7XG4gIGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPENsYXNzPFQ+PjtcbiAgZW50aXR5OiBFbnRpdHk8Q1Q+O1xuICB3b3JsZDogV29ybGQ8Q1Q+O1xufVxuXG5pbnRlcmZhY2UgVHJhY2tlZEV2ZW50SGFuZGxlcnM8VCwgQ1QgZXh0ZW5kcyBDbGFzcz4ge1xuICBvbkFkZD86IChhcmdzOiBBZGRFdmVudEFyZ3M8VCwgQ1Q+KSA9PiB2b2lkO1xuICBvblVwZGF0ZT86IChhcmdzOiBVcGRhdGVFdmVudEFyZ3M8VCwgQ1Q+KSA9PiB2b2lkO1xuICBvblJlbW92ZT86IChhcmdzOiBSZW1vdmVFdmVudEFyZ3M8VCwgQ1Q+KSA9PiB2b2lkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0luc3RhbmNlUHJveHlIYW5kbGVyczxULCBDVCBleHRlbmRzIENsYXNzPihcbiAgdHJhY2tlZEV2ZW50SGFuZGxlcnM6IFRyYWNrZWRFdmVudEhhbmRsZXJzPFQsIENUPlxuKTogUHJveHlIYW5kbGVyPGFueT4ge1xuICBjb25zdCB1cGRhdGVkUHJvcHMgPSBuZXcgU2V0KCk7XG4gIHJldHVybiB7XG4gICAgc2V0KFxuICAgICAgY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8Q2xhc3M8VD4+LFxuICAgICAgcHJvcGVydHk6IGtleW9mIFQsXG4gICAgICB2YWx1ZTogVFtrZXlvZiBUXVxuICAgICkge1xuICAgICAgdXBkYXRlZFByb3BzLmFkZChwcm9wZXJ0eSk7XG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29uc3Qgd29ybGQgPSBjb21wb25lbnRbXG4gICAgICAgIFRyYWNrZWRDb21wU3ltYm9sS2V5cy53b3JsZFxuICAgICAgXSBhcyBXb3JsZDxDVD47XG5cbiAgICAgIGNvbnN0IHByZXZpb3VzVmFsID0gY29tcG9uZW50W3Byb3BlcnR5XTtcblxuICAgICAgY29tcG9uZW50W3Byb3BlcnR5XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodHJhY2tlZEV2ZW50SGFuZGxlcnMub25VcGRhdGUpIHtcbiAgICAgICAgdHJhY2tlZEV2ZW50SGFuZGxlcnMub25VcGRhdGUoe1xuICAgICAgICAgIHdvcmxkLFxuICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICBwcmV2aW91c1ZhbCxcbiAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0NvbXBvbmVudDxDVCBleHRlbmRzIENsYXNzPGFueT4sIFQ+KFxuICBDb21wQ2xhc3M6IENsYXNzPFQ+LFxuICB0cmFja2VkRXZlbnRIYW5kbGVyczogVHJhY2tlZEV2ZW50SGFuZGxlcnM8VCwgQ1Q+XG4pOiBDbGFzczxUPiAmIFRyYWNrZWRDb21wb25lbnQ8Q1Q+IHtcbiAgcmV0dXJuIG5ldyBQcm94eShDb21wQ2xhc3MsIHtcbiAgICBjb25zdHJ1Y3QoQ29tcG9uZW50OiBhbnksIGFyZ3M6IGFueSkge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudCguLi5hcmdzKSBhcyBUICYgVHJhY2tlZENvbXBvbmVudDxDVD47XG4gICAgICAvLyBjb25zdCBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KC4uLmFyZ3MpIGFzIEluc3RhbmNlVHlwZTxDbGFzczxUPj47XG5cbiAgICAgIC8vIEZvciB1c2UgaW4gaWRlbnRpZmluZyBhIFwidHJhY2tlZFwiIGNsYXNzIHRocm91Z2ggdGhlIHByb3h5LlxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmlzVHJhY2tlZF0gPSB0cnVlO1xuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMuc2V0V29ybGRdID0gKFxuICAgICAgICB3b3JsZDogV29ybGQ8Q1Q+XG4gICAgICApID0+IHtcbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMud29ybGRdID0gd29ybGQ7XG4gICAgICB9O1xuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMub25BZGRdID0gKFxuICAgICAgICB3b3JsZDogV29ybGQ8Q1Q+LFxuICAgICAgICBlbnRpdHk6IEVudGl0eTxDVD5cbiAgICAgICkgPT4ge1xuICAgICAgICBpZiAodHJhY2tlZEV2ZW50SGFuZGxlcnMub25BZGQpIHtcbiAgICAgICAgICB0cmFja2VkRXZlbnRIYW5kbGVycy5vbkFkZCh7IGNvbXBvbmVudCwgd29ybGQsIGVudGl0eSB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uUmVtb3ZlXSA9IChcbiAgICAgICAgd29ybGQ6IFdvcmxkPENUPixcbiAgICAgICAgZW50aXR5OiBFbnRpdHk8Q1Q+XG4gICAgICApID0+IHtcbiAgICAgICAgaWYgKHRyYWNrZWRFdmVudEhhbmRsZXJzLm9uUmVtb3ZlKSB7XG4gICAgICAgICAgdHJhY2tlZEV2ZW50SGFuZGxlcnMub25SZW1vdmUoeyBjb21wb25lbnQsIHdvcmxkLCBlbnRpdHkgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgUHJveHkoXG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgY3JlYXRlQ2xhc3NJbnN0YW5jZVByb3h5SGFuZGxlcnModHJhY2tlZEV2ZW50SGFuZGxlcnMpXG4gICAgICApO1xuICAgIH0sXG4gIH0pO1xufVxuIiwiaW1wb3J0IEVudGl0eSwgeyBFbnRpdHlJZCB9IGZyb20gXCIuL0VudGl0eVwiO1xuaW1wb3J0IENvbXBvbmVudENvbGxlY3Rpb24gZnJvbSBcIi4vQ29tcG9uZW50Q29sbGVjdGlvblwiO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSBcIi4vVGFnXCI7XG5pbXBvcnQgeyBTeXN0ZW1GdW5jIH0gZnJvbSBcIi4vU3lzdGVtc1wiO1xuaW1wb3J0IERldlRvb2xzIGZyb20gXCIuL0RldlRvb2xzXCI7XG5pbXBvcnQgU3lzdGVtcyBmcm9tICcuL1N5c3RlbXMnO1xuaW1wb3J0IHsgVHJhY2tlZENvbXBTeW1ib2xLZXlzIH0gZnJvbSAnLi9UcmFja2VkQ29tcG9uZW50JztcblxuZXhwb3J0IHR5cGUgQ2xhc3M8VCA9IGFueT4gPSB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUIH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdvcmxkPENUIGV4dGVuZHMgQ2xhc3M8YW55Pj4ge1xuICBjb21wb25lbnRDb2xsZWN0aW9uczogTWFwPEVudGl0eUlkLCBDb21wb25lbnRDb2xsZWN0aW9uPENUPj4gPSBuZXcgTWFwKCk7XG5cbiAgZW50aXRpZXM6IE1hcDxFbnRpdHlJZCwgRW50aXR5PENUPj4gPSBuZXcgTWFwKCk7XG5cbiAgZW50aXRpZXNCeUNUeXBlczogTWFwPHN0cmluZ1tdLCBTZXQ8RW50aXR5SWQ+PiA9IG5ldyBNYXAoKTtcblxuICBlbnRpdGllc0J5VGFnczogTWFwPFRhZywgU2V0PEVudGl0eUlkPj4gPSBuZXcgTWFwKCk7XG5cbiAgc3lzdGVtczogU3lzdGVtczxDVD47XG5cbiAgZGV2OiBEZXZUb29sczxDVD47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kZXYgPSBuZXcgRGV2VG9vbHModGhpcyk7XG4gICAgdGhpcy5zeXN0ZW1zID0gbmV3IFN5c3RlbXModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogXCJmaW5kc1wiIGEgc2luZ2xlIGVudGl0eSBiYXNlZCBvbiBhIHByZWRpY2F0ZVxuICAgKi9cbiAgZmluZCA9IChwcmVkaWNhdGU6IChlbnRpdHk6IEVudGl0eTxDVD4pID0+IGJvb2xlYW4pOiBFbnRpdHk8Q1Q+IHwgbnVsbCA9PiB7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShlbnRpdHkpKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFwiZmluZHNcIiBhbGwgZW50aXRpZXMgYmFzZWQgb24gYSBwcmVkaWNhdGUsIGtpbmRhIGxpa2UgZmlsdGVyLlxuICAgKi9cbiAgZmluZEFsbCA9IChwcmVkaWNhdGU6IChlbnRpdHk6IEVudGl0eTxDVD4pID0+IGJvb2xlYW4pOiBFbnRpdHk8Q1Q+W10gPT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6IEVudGl0eTxDVD5bXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShlbnRpdHkpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBcImxvY2F0ZXNcIiBhIHNpbmdsZSBlbnRpdHkgYmFzZWQgb24gaXRzIENvbXBvbmVudHMuXG4gICAqL1xuICBsb2NhdGUgPSAoY2w6IENUIHwgQ1RbXSk6IEVudGl0eTxDVD4gfCBudWxsID0+IHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZW50aXR5LmNvbXBvbmVudHMuaGFzKGNsKSkge1xuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2NhdGVzIGFsbCBlbnRpdGllcyB0aGF0IGNvbnRhaW4gdGhlIGNvbXBvbmVudHMgbmFtZWRcbiAgICovXG4gIGxvY2F0ZUFsbCA9IChjbDogQ1QgfCBDVFtdKTogRW50aXR5PENUPltdID0+IHtcbiAgICBjb25zdCByZXN1bHRzOiBFbnRpdHk8Q1Q+W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHkuY29tcG9uZW50cy5oYXMoY2wpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHcmFicyB0aGUgZmlyc3QgZW50aXR5LCBhbmQgaXRzIHJlbGF0ZWQgY29tcG9uZW50LCB0aGF0IG1hdGNoZXMgdGhlIGNvbXBvbmVudCB0eXBlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc3QgeyBlbnRpdHksIGNvbXBvbmVudCB9ID0gd29ybGQuZ3JhYihNeUNvbXBvbmVudCk7XG4gICAqIGBgYFxuICAgKi9cbiAgZ3JhYiA9IDxUPihcbiAgICBjbDogQ2xhc3M8VD5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gfSB8IG51bGwgPT4ge1xuICAgIC8vIGNvbnN0IGVudGl0eSA9IHRoaXMubG9jYXRlKChjbCBhcyB1bmtub3duKSBhcyBDVFtrZXlvZiBDVF0pO1xuICAgIGNvbnN0IGVudGl0eSA9IHRoaXMubG9jYXRlKChjbCBhcyB1bmtub3duKSBhcyBDVCk7XG5cbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBjb25zdCBjYyA9XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVudGl0eS5pZCkgfHxcbiAgICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNjLmdldDxUPihjbCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudGl0eSxcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR3JhYiBzaW5nbGUgY29tcG9uZW50IGJhc2VkIG9uIGNvbXBvbmVudCB0eXBlIGFuZCBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgeyBlbnRpdHksIGNvbXBvbmVudCB9ID0gd29ybGQuZ3JhYkJ5KEZpcnN0Q29tcG9uZW50LCAoY29tcCkgPT4gY29tcC5pZCA9PSAnYXdlc29tZScpXG4gICAqIGBgYFxuICAgKi9cbiAgZ3JhYkJ5ID0gPFQ+KFxuICAgIGNsOiBDbGFzczxUPixcbiAgICBwcmVkaWNhdGU6IChjb21wOiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPikgPT4gYm9vbGVhblxuICApOiB7IGVudGl0eTogRW50aXR5PENUPjsgY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPiB9IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgZW50aXRpZXMgPSB0aGlzLmxvY2F0ZUFsbCgoY2wgYXMgdW5rbm93bikgYXMgQ1QpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGNjID1cbiAgICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZW50aXR5LmlkKSB8fFxuICAgICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgICAgaWYgKHByZWRpY2F0ZShjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgIGVudGl0eSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR3JhYiBhbGwgdGhlIGNvbXBvbmVudHMgcHJpbWFyaWx5LCBhbmQgdGhlIGVudGl0aWVzIGlmIG5lZWRlZFxuICAgKi9cbiAgZ3JhYkFsbCA9IDxUPihcbiAgICBjbDogQ2xhc3M8VD5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gfVtdID0+IHtcbiAgICBjb25zdCBlbnRpdGllcyA9IHRoaXMubG9jYXRlQWxsKChjbCBhcyB1bmtub3duKSBhcyBDVCk7XG5cbiAgICByZXR1cm4gZW50aXRpZXMubWFwKChlbnRpdHkpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudGl0eSxcbiAgICAgICAgY29tcG9uZW50OiBlbnRpdHkuY29tcG9uZW50cy5nZXQ8VD4oY2wpLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPOiBBZGQgZ3JhYkFsbEJ5IG1ldGhvZFxuXG4gIC8qKlxuICAgKiBHaXZlbiBhbiBlbnRpdHkgaWQgYW5kIGNvbXBvbmVudFR5cGUsIHJldHVybnMgY29tcG9uZW50XG4gICAqL1xuICBnZXQgPSA8VD4oZWlkOiBFbnRpdHlJZCwgY2w6IENsYXNzPFQ+KTogSW5zdGFuY2VUeXBlPHR5cGVvZiBjbD4gPT4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICByZXR1cm4gY2MuZ2V0PFQ+KGNsKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhbmQgZ2V0IHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCwgd2l0aG91dCBhbnkgYXNzb2NpYXRlZCBlbnRpdGllcy5cbiAgICogSGVscGZ1bCBpcyB5b3Uga25vdyB0aGF0IG9ubHkgb25lIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IGV4aXN0cyBhY3Jvc3MgYWxsIGVudGl0aWVzLlxuICAgKiBAcGFyYW0gY2wgQ29tcG9uZW50IENsYXNzIENvbnRydWN0b3JcbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBIGRlZmF1bHQgY29tcG9uZW50IGluc3RhbmNlIGlmIG5vIGNvbXBvbmVudHMgYXJlIGZvdW5kLlxuICAgKi9cbiAgZ2V0Q29tcG9uZW50ID0gPFQ+KFxuICAgIGNsOiBDbGFzczxUPixcbiAgICBkZWZhdWx0VmFsdWU/OiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPlxuICApOiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPiB8IG51bGwgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ3JhYihjbCk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSA/IGRlZmF1bHRWYWx1ZSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5jb21wb25lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBlbnRpdHkgdGhhdCBoYXMgYmVlbiB0YWdnZWQgd2l0aCB0aGUgZ2l2ZW4gdGFnLCBvciByZXR1cm4gbnVsbDtcbiAgICovXG4gIGdldFRhZ2dlZCA9ICh0YWc6IFRhZyk6IEVudGl0eTxDVD4gfCBudWxsID0+IHtcbiAgICBjb25zdCB0YWdFbnRpdHlJZHMgPSB0aGlzLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgaWYgKHRhZ0VudGl0eUlkcykge1xuICAgICAgY29uc3QgZW50aXR5SWQgPSB0YWdFbnRpdHlJZHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG5cbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0dCBhbGwgZW50aXRpZXMgdGhhdCBoYXZlIGJlZW4gdGFnZ2VkIHdpdGggdGhlIGdpdmVuIHRhZy5cbiAgICogQHBhcmFtIHRhZyBBIHN0cmluZyBvciBudW1iZXIuXG4gICAqL1xuICBnZXRBbGxUYWdnZWQgPSAodGFnOiBUYWcpOiBFbnRpdHk8Q1Q+W10gPT4ge1xuICAgIGxldCBlbnRpdGllczogRW50aXR5PENUPltdID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNvbnN0IHRhZ0VudGl0eUlkcyA9IHRoaXMuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZyk7XG5cbiAgICBpZiAodGFnRW50aXR5SWRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIHRhZ0VudGl0eUlkcykge1xuICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG4gICAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW50aXRpZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGNvbXBvbmVudCBvbiB0aGUgZ2l2ZW4gZW50aXR5XG4gICAqL1xuICBhZGQgPSAoZWlkOiBFbnRpdHlJZCwgY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8Q1Q+KTogdGhpcyA9PiB7XG4gICAgY29uc3QgY2MgPVxuICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZWlkKSB8fCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIGNjLmFkZChjb21wb25lbnQpO1xuXG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZWlkLCBjYyk7XG5cbiAgICBmb3IgKGNvbnN0IFtjdEFyciwgZW50aXR5U2V0XSBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMpIHtcbiAgICAgIGlmICgoY3RBcnIgYXMgc3RyaW5nW10pLmV2ZXJ5KGNjLmhhc0J5TmFtZSkpIHtcbiAgICAgICAgZW50aXR5U2V0LmFkZChlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmlzVHJhY2tlZF0pIHtcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMuc2V0V29ybGRdKHRoaXMpO1xuXG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlaWQpO1xuXG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdvcmxkLmFkZDogVW5hYmxlIHRvIGxvY2F0ZSBlbnRpdHkuIGVpZDogJHtlaWR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMub25BZGRdKHRoaXMsIGVudGl0eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNvbXBvbmVudCBmcm9tIHRoZSBnaXZlbiBlbnRpdHkuXG4gICAqIE5PVEU6IFRoaXMgd2lsbCBjaGFuZ2Ugd2hhdCBzeXN0ZW1zIHdpbGwgYmUgY2FsbGVkIG9uIHRoZSBlbnRpdHkuXG4gICAqL1xuICByZW1vdmUgPSAoZWlkOiBFbnRpdHlJZCwgY1R5cGU6IENUKTogdGhpcyA9PiB7XG4gICAgY29uc3QgY2MgPVxuICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZWlkKSB8fCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIC8vIG5lZWQgdG8gZ2V0IGNvbXBvbmVudCBpbnN0YW5jZS4uLlxuICAgIGNvbnN0IGNvbXBvbmVudCA9IGNjLmdldChjVHlwZSk7XG5cbiAgICBpZiAoY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5pc1RyYWNrZWRdKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlaWQpO1xuXG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdvcmxkLnJlbW92ZTogVW5hYmxlIHRvIGxvY2F0ZSBlbnRpdHkuIGVpZDogJHtlaWR9LCBjVHlwZTogJHtjVHlwZS5uYW1lfWApO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uUmVtb3ZlXSh0aGlzLCBlbnRpdHkpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBlbnRpdHkgZnJvbSBjdXJyZW50IGVudGl0aWVzQnlDVHlwZXNcbiAgICBmb3IgKGNvbnN0IFtjdEFyciwgZW50aXR5U2V0XSBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMpIHtcbiAgICAgIGlmICgoY3RBcnIgYXMgc3RyaW5nW10pLmV2ZXJ5KGNjLmhhc0J5TmFtZSkpIHtcbiAgICAgICAgZW50aXR5U2V0LmRlbGV0ZShlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNjLnJlbW92ZShjVHlwZSk7XG5cbiAgICAvLyBNb3ZlIGVudGl0eUlkIHRvIG5ldyBDVHlwZXMgaWYgbmVlZGVkLlxuICAgIGZvciAoY29uc3QgW2N0QXJyLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcykge1xuICAgICAgaWYgKChjdEFyciBhcyBzdHJpbmdbXSkuZXZlcnkoY2MuaGFzQnlOYW1lKSkge1xuICAgICAgICBlbnRpdHlTZXQuYWRkKGVpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsdGVybmF0aXZlIG1ldGhvZCBmb3IgYWRkaW5nIHN5c3RlbXMuXG4gICAqL1xuICBhZGRTeXN0ZW0oY1R5cGVzOiBDVFtdLCBzeXN0ZW1GdW5jOiBTeXN0ZW1GdW5jPENUPiwgZnVuY05hbWU/OiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnN5c3RlbXMuYWRkKGNUeXBlcywgc3lzdGVtRnVuYywgZnVuY05hbWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZWdpc3RlckVudGl0eShlbnRpdHk6IEVudGl0eTxDVD4pOiBXb3JsZDxDVD4ge1xuICAgIGNvbnN0IGNjID0gbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLnNldChlbnRpdHkuaWQsIGNjKTtcbiAgICB0aGlzLmVudGl0aWVzLnNldChlbnRpdHkuaWQsIGVudGl0eSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGNvbXBvbmVudHMgdGhhdCBiZWxvbmcgdG8gYW4gZW50aXR5LlxuICAgKi9cbiAgY2xlYXJFbnRpdHlDb21wb25lbnRzKGVpZDogRW50aXR5SWQpOiB0aGlzIHtcbiAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLnNldChlaWQsIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpKTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5U2V0IG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVudGl0eVNldC5oYXMoZWlkKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGVudGl0eSB0aGF0IGlzIGluIHRoZSB3b3JsZC5cbiAgICogQmFzaWNhbGx5IGp1c3QgbmV3IEVudGl0eSh3b3JsZCksIGJ1dCBzYXZlcyBhbiBpbXBvcnQgb2YgRW50aXR5LlxuICAgKi9cbiAgY3JlYXRlRW50aXR5KCk6IEVudGl0eTxDVD4ge1xuICAgIGNvbnN0IGVudGl0eSA9IG5ldyBFbnRpdHkodGhpcyk7XG5cbiAgICByZXR1cm4gZW50aXR5O1xuXG4gICAgLy8gUmVnaXN0ZXIgZW50aXR5IGhlcmUuLi4uXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgYW4gZW50aXR5LlxuICAgKiBTYW1lIGFzIGVudGl0eS5kZXN0cm95KCkuXG4gICAqL1xuICBkZXN0cm95RW50aXR5KGVpZDogRW50aXR5SWQpOiBXb3JsZDxDVD4ge1xuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZGVsZXRlKGVpZCk7XG4gICAgdGhpcy5lbnRpdGllcy5kZWxldGUoZWlkKTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5U2V0IG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVudGl0eVNldC5oYXMoZWlkKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFueSB0YWcgYXNzb2NpYXRpb25zIHdpdGggZGVzdHJveWVkIGVudGl0aWVzLlxuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLmVudGl0aWVzQnlUYWdzKSB7XG4gICAgICBpZiAoZW50aXR5U2V0LmhhcyhlaWQpKSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUoZWlkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVudGl0eVNldC5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsImltcG9ydCBXb3JsZCBmcm9tICcuL1dvcmxkJztcbi8vIGltcG9ydCB7IGNyZWF0ZUVudGl0eSB9IGZyb20gJy4vRW50aXR5JztcblxuZXhwb3J0IHtcbiAgV29ybGQsXG4gIC8vIGNyZWF0ZUVudGl0eSxcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')}])}));