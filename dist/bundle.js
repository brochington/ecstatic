!function(Q,B){"object"==typeof exports&&"object"==typeof module?module.exports=B():"function"==typeof define&&define.amd?define("ecstatic",[],B):"object"==typeof exports?exports.ecstatic=B():Q.ecstatic=B()}(window,(function(){return function(Q){var B=window.webpackHotUpdateecstatic;window.webpackHotUpdateecstatic=function(Q,n){!function(Q,B){if(!R[Q]||!a[Q])return;for(var n in a[Q]=!1,B)Object.prototype.hasOwnProperty.call(B,n)&&(b[n]=B[n]);0==--G&&0===u&&V()}(Q,n),B&&B(Q,n)};var n,t=!0,F="f681ab343720a405cc81",e={},U=[],I=[];function s(Q){var B=E[Q];if(!B)return m;var t=function(t){return B.hot.active?(E[t]?-1===E[t].parents.indexOf(Q)&&E[t].parents.push(Q):(U=[Q],n=t),-1===B.children.indexOf(t)&&B.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+Q),U=[]),m(t)},F=function(Q){return{configurable:!0,enumerable:!0,get:function(){return m[Q]},set:function(B){m[Q]=B}}};for(var e in m)Object.prototype.hasOwnProperty.call(m,e)&&"e"!==e&&"t"!==e&&Object.defineProperty(t,e,F(e));return t.e=function(Q){return"ready"===l&&g("prepare"),u++,m.e(Q).then(B,(function(Q){throw B(),Q}));function B(){u--,"prepare"===l&&(y[Q]||Z(Q),0===u&&0===G&&V())}},t.t=function(Q,B){return 1&B&&(Q=t(Q)),m.t(Q,-2&B)},t}function c(B){var t={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:n!==B,active:!0,accept:function(Q,B){if(void 0===Q)t._selfAccepted=!0;else if("function"==typeof Q)t._selfAccepted=Q;else if("object"==typeof Q)for(var n=0;n<Q.length;n++)t._acceptedDependencies[Q[n]]=B||function(){};else t._acceptedDependencies[Q]=B||function(){}},decline:function(Q){if(void 0===Q)t._selfDeclined=!0;else if("object"==typeof Q)for(var B=0;B<Q.length;B++)t._declinedDependencies[Q[B]]=!0;else t._declinedDependencies[Q]=!0},dispose:function(Q){t._disposeHandlers.push(Q)},addDisposeHandler:function(Q){t._disposeHandlers.push(Q)},removeDisposeHandler:function(Q){var B=t._disposeHandlers.indexOf(Q);B>=0&&t._disposeHandlers.splice(B,1)},invalidate:function(){switch(this._selfInvalidated=!0,l){case"idle":(b={})[B]=Q[B],g("ready");break;case"ready":N(B);break;case"prepare":case"check":case"dispose":case"apply":(o=o||[]).push(B)}},check:X,apply:r,status:function(Q){if(!Q)return l;i.push(Q)},addStatusHandler:function(Q){i.push(Q)},removeStatusHandler:function(Q){var B=i.indexOf(Q);B>=0&&i.splice(B,1)},data:e[B]};return n=void 0,t}var i=[],l="idle";function g(Q){l=Q;for(var B=0;B<i.length;B++)i[B].call(null,Q)}var d,b,C,o,G=0,u=0,y={},a={},R={};function x(Q){return+Q+""===Q?+Q:Q}function X(Q){if("idle"!==l)throw new Error("check() is only allowed in idle status");return t=Q,g("check"),(B=1e4,B=B||1e4,new Promise((function(Q,n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var t=new XMLHttpRequest,F=m.p+"hot/hot-update.json";t.open("GET",F,!0),t.timeout=B,t.send(null)}catch(Q){return n(Q)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)n(new Error("Manifest request to "+F+" timed out."));else if(404===t.status)Q();else if(200!==t.status&&304!==t.status)n(new Error("Manifest request to "+F+" failed."));else{try{var B=JSON.parse(t.responseText)}catch(Q){return void n(Q)}Q(B)}}}))).then((function(Q){if(!Q)return g(L()?"ready":"idle"),null;a={},y={},R=Q.c,C=Q.h,g("prepare");var B=new Promise((function(Q,B){d={resolve:Q,reject:B}}));b={};return Z(0),"prepare"===l&&0===u&&0===G&&V(),B}));var B}function Z(Q){var B;R[Q]?(a[Q]=!0,G++,(B=document.createElement("script")).charset="utf-8",B.src=m.p+"hot/hot-update.js",document.head.appendChild(B)):y[Q]=!0}function V(){g("ready");var Q=d;if(d=null,Q)if(t)Promise.resolve().then((function(){return r(t)})).then((function(B){Q.resolve(B)}),(function(B){Q.reject(B)}));else{var B=[];for(var n in b)Object.prototype.hasOwnProperty.call(b,n)&&B.push(x(n));Q.resolve(B)}}function r(B){if("ready"!==l)throw new Error("apply() is only allowed in ready status");return function B(t){var I,s,c,i,l;function d(Q){for(var B=[Q],n={},t=B.map((function(Q){return{chain:[Q],id:Q}}));t.length>0;){var F=t.pop(),e=F.id,U=F.chain;if((i=E[e])&&(!i.hot._selfAccepted||i.hot._selfInvalidated)){if(i.hot._selfDeclined)return{type:"self-declined",chain:U,moduleId:e};if(i.hot._main)return{type:"unaccepted",chain:U,moduleId:e};for(var I=0;I<i.parents.length;I++){var s=i.parents[I],c=E[s];if(c){if(c.hot._declinedDependencies[e])return{type:"declined",chain:U.concat([s]),moduleId:e,parentId:s};-1===B.indexOf(s)&&(c.hot._acceptedDependencies[e]?(n[s]||(n[s]=[]),G(n[s],[e])):(delete n[s],B.push(s),t.push({chain:U.concat([s]),id:s})))}}}}return{type:"accepted",moduleId:Q,outdatedModules:B,outdatedDependencies:n}}function G(Q,B){for(var n=0;n<B.length;n++){var t=B[n];-1===Q.indexOf(t)&&Q.push(t)}}L();var u={},y=[],a={},X=function(){console.warn("[HMR] unexpected require("+V.moduleId+") to disposed module")};for(var Z in b)if(Object.prototype.hasOwnProperty.call(b,Z)){var V;l=x(Z),V=b[Z]?d(l):{type:"disposed",moduleId:Z};var r=!1,N=!1,W=!1,p="";switch(V.chain&&(p="\nUpdate propagation: "+V.chain.join(" -> ")),V.type){case"self-declined":t.onDeclined&&t.onDeclined(V),t.ignoreDeclined||(r=new Error("Aborted because of self decline: "+V.moduleId+p));break;case"declined":t.onDeclined&&t.onDeclined(V),t.ignoreDeclined||(r=new Error("Aborted because of declined dependency: "+V.moduleId+" in "+V.parentId+p));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(V),t.ignoreUnaccepted||(r=new Error("Aborted because "+l+" is not accepted"+p));break;case"accepted":t.onAccepted&&t.onAccepted(V),N=!0;break;case"disposed":t.onDisposed&&t.onDisposed(V),W=!0;break;default:throw new Error("Unexception type "+V.type)}if(r)return g("abort"),Promise.reject(r);if(N)for(l in a[l]=b[l],G(y,V.outdatedModules),V.outdatedDependencies)Object.prototype.hasOwnProperty.call(V.outdatedDependencies,l)&&(u[l]||(u[l]=[]),G(u[l],V.outdatedDependencies[l]));W&&(G(y,[V.moduleId]),a[l]=X)}var A,h=[];for(s=0;s<y.length;s++)l=y[s],E[l]&&E[l].hot._selfAccepted&&a[l]!==X&&!E[l].hot._selfInvalidated&&h.push({module:l,parents:E[l].parents.slice(),errorHandler:E[l].hot._selfAccepted});g("dispose"),Object.keys(R).forEach((function(Q){!1===R[Q]&&function(Q){delete installedChunks[Q]}(Q)}));var D,S,Y=y.slice();for(;Y.length>0;)if(l=Y.pop(),i=E[l]){var H={},v=i.hot._disposeHandlers;for(c=0;c<v.length;c++)(I=v[c])(H);for(e[l]=H,i.hot.active=!1,delete E[l],delete u[l],c=0;c<i.children.length;c++){var T=E[i.children[c]];T&&((A=T.parents.indexOf(l))>=0&&T.parents.splice(A,1))}}for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=E[l]))for(S=u[l],c=0;c<S.length;c++)D=S[c],(A=i.children.indexOf(D))>=0&&i.children.splice(A,1);g("apply"),void 0!==C&&(F=C,C=void 0);for(l in b=void 0,a)Object.prototype.hasOwnProperty.call(a,l)&&(Q[l]=a[l]);var J=null;for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=E[l])){S=u[l];var k=[];for(s=0;s<S.length;s++)if(D=S[s],I=i.hot._acceptedDependencies[D]){if(-1!==k.indexOf(I))continue;k.push(I)}for(s=0;s<k.length;s++){I=k[s];try{I(S)}catch(Q){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:l,dependencyId:S[s],error:Q}),t.ignoreErrored||J||(J=Q)}}}for(s=0;s<h.length;s++){var z=h[s];l=z.module,U=z.parents,n=l;try{m(l)}catch(Q){if("function"==typeof z.errorHandler)try{z.errorHandler(Q)}catch(B){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:l,error:B,originalError:Q}),t.ignoreErrored||J||(J=B),J||(J=Q)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:l,error:Q}),t.ignoreErrored||J||(J=Q)}}if(J)return g("fail"),Promise.reject(J);if(o)return B(t).then((function(Q){return y.forEach((function(B){Q.indexOf(B)<0&&Q.push(B)})),Q}));return g("idle"),new Promise((function(Q){Q(y)}))}(B=B||{})}function L(){if(o)return b||(b={}),o.forEach(N),o=void 0,!0}function N(B){Object.prototype.hasOwnProperty.call(b,B)||(b[B]=Q[B])}var E={};function m(B){if(E[B])return E[B].exports;var n=E[B]={i:B,l:!1,exports:{},hot:c(B),parents:(I=U,U=[],I),children:[]};return Q[B].call(n.exports,n,n.exports,s(B)),n.l=!0,n.exports}return m.m=Q,m.c=E,m.d=function(Q,B,n){m.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:n})},m.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},m.t=function(Q,B){if(1&B&&(Q=m(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var n=Object.create(null);if(m.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var t in Q)m.d(n,t,function(B){return Q[B]}.bind(null,t));return n},m.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return m.d(B,"a",B),B},m.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},m.p="/static/",m.h=function(){return F},s(0)(m.s=0)}([function(Q,B,n){Q.exports=n(1)},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "World", function() { return /* reexport */ World_World; });\n__webpack_require__.d(__webpack_exports__, "trackComponent", function() { return /* reexport */ trackComponent; });\n\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== \'undefined\' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \'undefined\' && typeof msCrypto.getRandomValues === \'function\' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error(\'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js\n/* harmony default export */ var regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js\n\n\nfunction validate(uuid) {\n  return typeof uuid === \'string\' && regex.test(uuid);\n}\n\n/* harmony default export */ var esm_browser_validate = (validate);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var stringify_i = 0; stringify_i < 256; ++stringify_i) {\n  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It\'s been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \'-\' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \'-\' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \'-\' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \'-\' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it\'s likely due to one\n  // of the following:\n  // - One or more input array values don\'t map to a hex octet (leading to\n  // "undefined" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!esm_browser_validate(uuid)) {\n    throw TypeError(\'Stringified UUID is invalid\');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ var esm_browser_stringify = (stringify);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return esm_browser_stringify(rnds);\n}\n\n/* harmony default export */ var esm_browser_v4 = (v4);\n// CONCATENATED MODULE: ./src/guards.ts\nfunction isComponentInstance(Class, comp) {\n  if (!comp) {\n    return false;\n  }\n\n  if (!(comp instanceof Class)) {\n    return false;\n  }\n\n  return true;\n}\n// CONCATENATED MODULE: ./src/ComponentCollection.ts\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n// CT is a Union, like `type = FirstComponent | SecondComponent`.\nclass ComponentCollection_ComponentCollection {\n  constructor() {\n    _defineProperty(this, "components", new Map());\n\n    _defineProperty(this, "add", component => {\n      this.components.set(component.constructor.name, component);\n    });\n\n    _defineProperty(this, "update", (cl, func) => {\n      const c = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, c)) {\n        const updatedComponent = func(c);\n        this.components.set(cl.name, updatedComponent);\n      }\n    });\n\n    _defineProperty(this, "remove", cType => {\n      this.components.delete(cType.name);\n    });\n\n    _defineProperty(this, "get", cl => {\n      const comp = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, comp)) {\n        return comp;\n      } else {\n        throw new Error(`ComponentCollection does not have component of type ${cl.name}`);\n      }\n    });\n\n    _defineProperty(this, "has", cType => {\n      return Array.isArray(cType) ? cType.every(ct => this.components.has(ct.name) === true) : this.components.has(cType.name);\n    });\n\n    _defineProperty(this, "hasByName", cName => {\n      return Array.isArray(cName) ? cName.every(ct => this.components.has(ct) === true) : this.components.has(cName);\n    });\n  }\n\n  /**\n   * Get the component type names that are currently being used in the collection.\n   */\n  get componentTypes() {\n    return [...this.components.keys()];\n  }\n  /**\n   * Get the current number of components that are in the collection.\n   */\n\n\n  get size() {\n    return this.components.size;\n  }\n\n  toDevComponents() {\n    const obj = {};\n\n    for (const [compName, comp] of this.components) {\n      obj[compName] = comp;\n    }\n\n    return obj;\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevEntity.ts\nfunction DevEntity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevEntity {\n  constructor(entity, world) {\n    DevEntity_defineProperty(this, "id", void 0);\n\n    DevEntity_defineProperty(this, "components", void 0);\n\n    DevEntity_defineProperty(this, "tags", void 0);\n\n    DevEntity_defineProperty(this, "systems", []);\n\n    this.id = entity.id;\n    this.components = entity.components.toDevComponents(), this.tags = [...entity.tags];\n    const compNames = Object.keys(this.components);\n\n    for (const [systemName, cNames] of world.systems.compNamesBySystemName) {\n      if (cNames.every(cName => compNames.includes(cName))) {\n        this.systems.push(systemName);\n      }\n    }\n  }\n\n  toTableRow() {\n    return {\n      id: this.id,\n      components: Object.keys(this.components).join(", "),\n      tags: this.tags.join(", "),\n      systems: this.systems.join(\', \')\n    };\n  }\n\n}\n\n/* harmony default export */ var src_DevEntity = (DevEntity);\n// CONCATENATED MODULE: ./src/SimpleFSM.ts\nfunction SimpleFSM_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass SimpleFSM {\n  constructor(initialState, transitions) {\n    SimpleFSM_defineProperty(this, "current", void 0);\n\n    SimpleFSM_defineProperty(this, "inital", void 0);\n\n    SimpleFSM_defineProperty(this, "transitions", void 0);\n\n    this.inital = initialState;\n    this.current = initialState;\n    this.transitions = transitions;\n  }\n\n  next(data) {\n    if (this.transitions[this.current]) {\n      this.current = this.transitions[this.current](data, this.current);\n    }\n  }\n\n  reset() {\n    this.current = this.inital;\n  }\n\n  is(checkState) {\n    return this.current === checkState;\n  }\n\n}\n// CONCATENATED MODULE: ./src/Entity.ts\nfunction Entity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nclass Entity_Entity {\n  constructor(world) {\n    Entity_defineProperty(this, "_id", void 0);\n\n    Entity_defineProperty(this, "_world", void 0);\n\n    Entity_defineProperty(this, "_error", void 0);\n\n    Entity_defineProperty(this, "_state", void 0);\n\n    this._id = esm_browser_v4();\n    this._world = world;\n    this._error = null;\n\n    const fsmTransition = ns => {\n      if (ns === "error" || this._error) return "error";\n      return ns;\n    };\n\n    this._state = new SimpleFSM("creating", {\n      creating: fsmTransition,\n      created: fsmTransition,\n      destroying: fsmTransition,\n      destroyed: () => "destroyed",\n      error: () => "error"\n    });\n    /*\n    Registering with the World.\n    */\n\n    this._world.registerEntity(this);\n\n    if (this._world.systems.compNamesBySystemName.size === 0) {\n      this._state.next(\'created\');\n    }\n  }\n\n  get state() {\n    return this._state.current;\n  }\n\n  checkState(possibleState) {\n    return this._state.is(possibleState);\n  }\n  /* LifeCycle methods, meant to be overridden */\n\n\n  onCreate(world) {// abstract\n  }\n\n  onDestroy(world) {// abstract\n  }\n\n  onComponentAdd(args) {// abstract\n  }\n\n  onTrackedComponentUpdate(args) {// abstract\n  }\n\n  onComponentRemove(args) {// abstract\n  }\n  /**\n   * Add a component to an Entity, doh.\n   */\n\n\n  add(component) {\n    this._world.add(this._id, component);\n\n    return this;\n  }\n  /**\n   * Add a tag to a component\n   */\n\n\n  addTag(tag) {\n    const entitySet = this._world.entitiesByTags.has(tag) ? this._world.entitiesByTags.get(tag) : new Set();\n\n    if (entitySet) {\n      entitySet.add(this._id);\n\n      this._world.entitiesByTags.set(tag, entitySet);\n    }\n\n    return this;\n  }\n  /**\n   * Determines if an entity has a component related to it.\n   */\n\n\n  has(cType) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    return cc.has(cType);\n  }\n  /**\n   * Check to see if an entity tagged with a given tag.\n   */\n\n\n  hasTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        return entitySet.has(this._id);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get a component that belongs to an entity.\n   */\n\n\n  get(cl) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    const component = cc.get(cl);\n    return component;\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection\n   */\n\n\n  getAll() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Remove a component from an entity.\n   * @param cType A component class, eg MyComponent\n   */\n\n\n  remove(cType) {\n    this._world.remove(this._id, cType);\n\n    return this;\n  }\n  /**\n   * Remove a tag from an entity\n   */\n\n\n  removeTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        entitySet.delete(this._id);\n\n        if (entitySet.size === 0) {\n          this._world.entitiesByTags.delete(tag);\n        }\n      }\n    }\n\n    return this;\n  }\n  /** Clears all components from an Entity */\n\n\n  clear() {\n    this._world.clearEntityComponents(this._id);\n\n    return this;\n  }\n  /**\n   * Remove all tags on an entity\n   */\n\n\n  clearTags() {\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      entitySet.delete(this._id);\n\n      if (entitySet.size === 0) {\n        this._world.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n  finishCreation() {\n    this._state.next(\'created\');\n  }\n\n  destroy() {\n    // If no systems are added, the destroy immediately.\n    if (this._world.systems.compNamesBySystemName.size === 0) {\n      this.destroyImmediately();\n      return;\n    }\n\n    if (!this._state.is("created")) {\n      throw new Error("Ecstatic: Unable to destroy if it isn\'t created, or already destroyed");\n    } // Mark as "destroying" so that systems can act on it before actually being destroyed.\n\n\n    this._state.next(\'destroying\');\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get world() {\n    return this._world;\n  }\n\n  destroyImmediately() {\n    // Right now calling before the actual destorying of the entity.\n    // Might want to change this to post destruction in the future, who knows.\n    this.onDestroy(this._world); // Actually destroy entity.\n\n    this._world.destroyEntity(this._id); // should return an error??\n\n\n    this._state.next(\'destroyed\');\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection.\n   * Does the same thing as entityInstance.getAll().\n   */\n\n\n  get components() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Retrieves all the tags that have been added to this entity.\n   */\n\n\n  get tags() {\n    const tags = new Set();\n\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      if (entitySet.has(this._id)) {\n        tags.add(tag);\n      }\n    }\n\n    return tags;\n  }\n  /**\n   * Convert Entity to a DevEntity. Very helpful in for debugging.\n   */\n\n\n  toDevEntity() {\n    return new src_DevEntity(this, this._world);\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevTools.ts\nfunction DevTools_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevTools {\n  constructor(world) {\n    DevTools_defineProperty(this, "world", void 0);\n\n    this.world = world;\n  }\n  /**\n   * display the all systems of the world, and the components required by each system.\n   * Super helpful to use with console.table()\n   * @example\n   * ```\n   * console.table(world.dev.systemComponents);\n   * ```\n   */\n\n\n  get systemComponents() {\n    const compsBySystems = [];\n\n    for (const [system, compNames] of this.world.systems.compNamesBySystemName) {\n      compsBySystems.push({\n        system,\n        components: compNames.join(", ")\n      });\n    }\n\n    return compsBySystems;\n  }\n  /**\n   * Create an array of DevEntites. Can be very helpful for things like inspecting component state,\n   * and which systems will be called on an entity.\n   * @example\n   * ```\n   * console.table(world.dev.entities);\n   *\n   * // Pro tip! try displaying a table of entities with console.table and DevEntity.toTableRow().\n   * console.table(world.dev.entities.map(devEntity => devEntity.toTableRow()));\n   * ```\n   */\n\n\n  get entities() {\n    return [...this.world.entities.values()].map(e => e.toDevEntity());\n  }\n\n}\n\n/* harmony default export */ var src_DevTools = (DevTools);\n// CONCATENATED MODULE: ./src/Systems.ts\nfunction Systems_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/**\n * Arguments that are passed into a System function on each iteration.\n * This is how you acces things like the entity that particular entity to act on,\n * as well as some other helpful params like if the entity is the first or last entity\n * in the group of entities that being iterated over.\n */\n\nclass Systems_Systems {\n  // double check to make sure that maps are ordered.\n  constructor(world) {\n    Systems_defineProperty(this, "world", void 0);\n\n    Systems_defineProperty(this, "systemFuncBySystemName", void 0);\n\n    Systems_defineProperty(this, "compNamesBySystemName", void 0);\n\n    this.world = world;\n    this.systemFuncBySystemName = new Map();\n    this.compNamesBySystemName = new Map();\n  }\n\n  add(cTypes, systemFunc, funcName) {\n    const cNames = cTypes.map(ct => ct.name);\n    let name = systemFunc.name;\n\n    if (systemFunc.name === \'\') {\n      // Super brute force, and might lead to errors in the future, but for now\n      // using the stringified system function if the function doesn\'t already have a name.\n      // This is useful for anonymous functions used as a system function.\n      // Might be good to figure out how to get a hash of the function string.\n      name = systemFunc.toString().slice(0, 30);\n    }\n\n    if (funcName) {\n      name = funcName;\n    }\n\n    this.systemFuncBySystemName.set(name, systemFunc);\n    this.compNamesBySystemName.set(name, cNames);\n    this.world.entitiesByCTypes.set(cNames, new Set());\n    return this;\n  }\n\n  run() {\n    // TODO: Might be cool to add a way to stop the systems loop when in dev.\n    //       Maybe something like world.dev.stop() or pause().\n    for (const [funcName, systemFunc] of this.systemFuncBySystemName.entries()) {\n      let index = 0;\n      const size = this.world.entitiesByCTypes.size;\n      const cNames = this.compNamesBySystemName.get(funcName) || [];\n      const cTypeArrs = this.world.entitiesByCTypes.get(cNames) || new Set();\n      const entitiesInCreatingState = [];\n      const entitiesInDestroyingState = [];\n\n      for (const entity of this.world.entities.values()) {\n        if (entity.state === \'creating\') {\n          entitiesInCreatingState.push(entity);\n        }\n\n        if (entity.state === \'destroying\') {\n          entitiesInDestroyingState.push(entity);\n        }\n      }\n\n      for (const eid of cTypeArrs) {\n        const args = {\n          entity: this.world.entities.get(eid) || new Entity_Entity(this.world),\n          components: this.world.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(),\n          world: this.world,\n          index,\n          size,\n          isFirst: index === 0,\n          isLast: index + 1 === size\n        };\n        systemFunc(args);\n        index += 1;\n      }\n\n      for (const entity of entitiesInCreatingState) {\n        entity.finishCreation();\n      }\n\n      for (const entity of entitiesInDestroyingState) {\n        entity.destroyImmediately();\n      }\n    }\n  }\n\n}\n// CONCATENATED MODULE: ./src/TrackedComponent.ts\n// Waiting for Typescript 4.2 to come out so that Symbols are supporded keys.\nconst TrackedCompSymbolKeys = {\n  isTracked: Symbol.for("ecs.trackedComponent.isTracked"),\n  world: Symbol.for("ecs.trackedComponent.world"),\n  setWorld: Symbol.for("ecs.trackedComponent.setWorld"),\n  onAdd: Symbol.for("ecs.trackedComponent.onAdd"),\n  onUpdate: Symbol.for("ecs.trackedComponent.onUpdate"),\n  onRemove: Symbol.for("ecs.trackedComponent.onRemove")\n}; //@ts-ignore\n\nfunction createClassInstanceProxyHandlers(trackedEventHandlers) {\n  const updatedProps = new Set();\n  return {\n    set(component, property, value) {\n      updatedProps.add(property); //@ts-ignore\n\n      const world = component[TrackedCompSymbolKeys.world];\n      const previousVal = component[property];\n      component[property] = value;\n\n      if (trackedEventHandlers.onUpdate) {\n        trackedEventHandlers.onUpdate({\n          world,\n          component,\n          previousVal,\n          property\n        });\n      }\n\n      return true;\n    }\n\n  };\n}\n\nfunction trackComponent(CompClass, trackedEventHandlers) {\n  return new Proxy(CompClass, {\n    construct(Component, args) {\n      const component = new Component(...args); // const component = new Component(...args) as T & TrackedComponent<Class<T>>;\n      // const component = new Component(...args) as InstanceType<Class<T>>;\n      // For use in identifing a "tracked" class through the proxy.\n      //@ts-ignore\n\n      component[TrackedCompSymbolKeys.isTracked] = true; //@ts-ignore\n\n      component[TrackedCompSymbolKeys.setWorld] = world => {\n        //@ts-ignore\n        component[TrackedCompSymbolKeys.world] = world;\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onAdd] = (world, entity) => {\n        if (trackedEventHandlers.onAdd) {\n          trackedEventHandlers.onAdd({\n            component,\n            world,\n            entity\n          });\n        }\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onRemove] = (world, entity) => {\n        if (trackedEventHandlers.onRemove) {\n          trackedEventHandlers.onRemove({\n            component,\n            world,\n            entity\n          });\n        }\n      };\n\n      return new Proxy(component, createClassInstanceProxyHandlers(trackedEventHandlers));\n    }\n\n  });\n}\n// CONCATENATED MODULE: ./src/World.ts\nfunction World_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nclass World_World {\n  constructor() {\n    World_defineProperty(this, "componentCollections", new Map());\n\n    World_defineProperty(this, "entities", new Map());\n\n    World_defineProperty(this, "entitiesByCTypes", new Map());\n\n    World_defineProperty(this, "entitiesByTags", new Map());\n\n    World_defineProperty(this, "systems", void 0);\n\n    World_defineProperty(this, "dev", void 0);\n\n    World_defineProperty(this, "find", predicate => {\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "findAll", predicate => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "locate", cl => {\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "locateAll", cl => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "grab", cl => {\n      const entity = this.locate(cl);\n\n      if (entity) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n        return {\n          entity,\n          component\n        };\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabBy", (cl, predicate) => {\n      const entities = this.locateAll(cl); // const entities = this.locateAll((cl as unknown) as CT);\n\n      for (const entity of entities) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n\n        if (predicate(component)) {\n          return {\n            component,\n            entity\n          };\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabAll", cl => {\n      const entities = this.locateAll(cl);\n      return entities.map(entity => {\n        return {\n          entity,\n          component: entity.components.get(cl)\n        };\n      });\n    });\n\n    World_defineProperty(this, "get", (eid, cl) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      return cc.get(cl);\n    });\n\n    World_defineProperty(this, "getComponent", (cl, defaultValue) => {\n      const result = this.grab(cl);\n\n      if (!result) {\n        return defaultValue ? defaultValue : null;\n      }\n\n      return result.component;\n    });\n\n    World_defineProperty(this, "getTagged", tag => {\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        const entityId = tagEntityIds.values().next().value;\n        const entity = this.entities.get(entityId);\n\n        if (entity) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "getAllTagged", tag => {\n      let entities = []; // eslint-disable-line\n\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        for (const entityId of tagEntityIds) {\n          const entity = this.entities.get(entityId);\n\n          if (entity) {\n            entities.push(entity);\n          }\n        }\n      }\n\n      return entities;\n    });\n\n    World_defineProperty(this, "add", (eid, component) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      cc.add(component);\n      this.componentCollections.set(eid, cc);\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      } // @ts-ignore\n\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        // @ts-ignore\n        component[TrackedCompSymbolKeys.setWorld](this);\n        const entity = this.entities.get(eid);\n\n        if (!entity) {\n          throw new Error(`world.add: Unable to locate entity. eid: ${eid}`);\n        } // @ts-ignore\n\n\n        component[TrackedCompSymbolKeys.onAdd](this, entity);\n      }\n\n      return this;\n    });\n\n    World_defineProperty(this, "remove", (eid, cType) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(); // need to get component instance...\n\n      const component = cc.get(cType); // @ts-ignore\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        const entity = this.entities.get(eid);\n\n        if (!entity) {\n          throw new Error(`world.remove: Unable to locate entity. eid: ${eid}, cType: ${cType.name}`);\n        } // @ts-ignore\n\n\n        component[TrackedCompSymbolKeys.onRemove](this, entity);\n      } // remove entity from current entitiesByCTypes\n\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.delete(eid);\n        }\n      }\n\n      cc.remove(cType); // Move entityId to new CTypes if needed.\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      return this;\n    });\n\n    this.dev = new src_DevTools(this);\n    this.systems = new Systems_Systems(this);\n  }\n  /**\n   * "finds" a single entity based on a predicate\n   */\n\n\n  /**\n   * Alternative method for adding systems.\n   */\n  addSystem(cTypes, systemFunc, funcName) {\n    this.systems.add(cTypes, systemFunc, funcName);\n    return this;\n  }\n\n  registerEntity(entity) {\n    const cc = new ComponentCollection_ComponentCollection();\n    this.componentCollections.set(entity.id, cc);\n    this.entities.set(entity.id, entity);\n    entity.onCreate(this);\n    return this;\n  }\n  /**\n   * Remove all components that belong to an entity.\n   */\n\n\n  clearEntityComponents(eid) {\n    this.componentCollections.set(eid, new ComponentCollection_ComponentCollection());\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Create an entity that is in the world.\n   * Basically just new Entity(world), but saves an import of Entity.\n   */\n\n\n  createEntity() {\n    const entity = new Entity_Entity(this);\n    return entity; // Register entity here....\n  }\n  /**\n   * Destroys an entity.\n   * Same as entity.destroy().\n   */\n\n\n  destroyEntity(eid) {\n    this.componentCollections.delete(eid);\n    this.entities.delete(eid);\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n    } // remove any tag associations with destroyed entities.\n\n\n    for (const [tag, entitySet] of this.entitiesByTags) {\n      if (entitySet.has(eid)) {\n        entitySet.delete(eid);\n      }\n\n      if (entitySet.size === 0) {\n        this.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n}\n// CONCATENATED MODULE: ./src/index.ts\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY3N0YXRpYy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzP2Q4ZjgiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzPzQwZDYiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzA2ZTQiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3N0cmluZ2lmeS5qcz81OGNmIiwid2VicGFjazovL2Vjc3RhdGljLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz9lYzI2Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL2d1YXJkcy50cz8zYjU3Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL0NvbXBvbmVudENvbGxlY3Rpb24udHM/NTFjNCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZFbnRpdHkudHM/ZDE0MiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9TaW1wbGVGU00udHM/NDY5OSIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9FbnRpdHkudHM/YWM2OCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZUb29scy50cz9lMDFhIiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL1N5c3RlbXMudHM/YTYxMyIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9UcmFja2VkQ29tcG9uZW50LnRzP2JhMjciLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9zcmMvV29ybGQudHM/Y2MwYiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9pbmRleC50cz9mZmI0Il0sIm5hbWVzIjpbImlzQ29tcG9uZW50SW5zdGFuY2UiLCJDbGFzcyIsImNvbXAiLCJDb21wb25lbnRDb2xsZWN0aW9uIiwiTWFwIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInNldCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNsIiwiZnVuYyIsImMiLCJnZXQiLCJ1cGRhdGVkQ29tcG9uZW50IiwiY1R5cGUiLCJkZWxldGUiLCJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwiY3QiLCJoYXMiLCJjTmFtZSIsImNvbXBvbmVudFR5cGVzIiwia2V5cyIsInNpemUiLCJ0b0RldkNvbXBvbmVudHMiLCJvYmoiLCJjb21wTmFtZSIsIkRldkVudGl0eSIsImVudGl0eSIsIndvcmxkIiwiaWQiLCJ0YWdzIiwiY29tcE5hbWVzIiwiT2JqZWN0Iiwic3lzdGVtTmFtZSIsImNOYW1lcyIsInN5c3RlbXMiLCJjb21wTmFtZXNCeVN5c3RlbU5hbWUiLCJpbmNsdWRlcyIsInB1c2giLCJ0b1RhYmxlUm93Iiwiam9pbiIsIlNpbXBsZUZTTSIsImluaXRpYWxTdGF0ZSIsInRyYW5zaXRpb25zIiwiaW5pdGFsIiwiY3VycmVudCIsIm5leHQiLCJkYXRhIiwicmVzZXQiLCJpcyIsImNoZWNrU3RhdGUiLCJFbnRpdHkiLCJfaWQiLCJ1dWlkdjQiLCJfd29ybGQiLCJfZXJyb3IiLCJmc21UcmFuc2l0aW9uIiwibnMiLCJfc3RhdGUiLCJjcmVhdGluZyIsImNyZWF0ZWQiLCJkZXN0cm95aW5nIiwiZGVzdHJveWVkIiwiZXJyb3IiLCJyZWdpc3RlckVudGl0eSIsInN0YXRlIiwicG9zc2libGVTdGF0ZSIsIm9uQ3JlYXRlIiwib25EZXN0cm95Iiwib25Db21wb25lbnRBZGQiLCJhcmdzIiwib25UcmFja2VkQ29tcG9uZW50VXBkYXRlIiwib25Db21wb25lbnRSZW1vdmUiLCJhZGQiLCJhZGRUYWciLCJ0YWciLCJlbnRpdHlTZXQiLCJlbnRpdGllc0J5VGFncyIsIlNldCIsImNjIiwiY29tcG9uZW50Q29sbGVjdGlvbnMiLCJoYXNUYWciLCJnZXRBbGwiLCJyZW1vdmUiLCJyZW1vdmVUYWciLCJjbGVhciIsImNsZWFyRW50aXR5Q29tcG9uZW50cyIsImNsZWFyVGFncyIsImVudHJpZXMiLCJmaW5pc2hDcmVhdGlvbiIsImRlc3Ryb3kiLCJkZXN0cm95SW1tZWRpYXRlbHkiLCJkZXN0cm95RW50aXR5IiwidG9EZXZFbnRpdHkiLCJEZXZUb29scyIsInN5c3RlbUNvbXBvbmVudHMiLCJjb21wc0J5U3lzdGVtcyIsInN5c3RlbSIsImVudGl0aWVzIiwidmFsdWVzIiwibWFwIiwiZSIsIlN5c3RlbXMiLCJzeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lIiwiY1R5cGVzIiwic3lzdGVtRnVuYyIsImZ1bmNOYW1lIiwidG9TdHJpbmciLCJzbGljZSIsImVudGl0aWVzQnlDVHlwZXMiLCJydW4iLCJpbmRleCIsImNUeXBlQXJycyIsImVudGl0aWVzSW5DcmVhdGluZ1N0YXRlIiwiZW50aXRpZXNJbkRlc3Ryb3lpbmdTdGF0ZSIsImVpZCIsImlzRmlyc3QiLCJpc0xhc3QiLCJUcmFja2VkQ29tcFN5bWJvbEtleXMiLCJpc1RyYWNrZWQiLCJTeW1ib2wiLCJmb3IiLCJzZXRXb3JsZCIsIm9uQWRkIiwib25VcGRhdGUiLCJvblJlbW92ZSIsImNyZWF0ZUNsYXNzSW5zdGFuY2VQcm94eUhhbmRsZXJzIiwidHJhY2tlZEV2ZW50SGFuZGxlcnMiLCJ1cGRhdGVkUHJvcHMiLCJwcm9wZXJ0eSIsInZhbHVlIiwicHJldmlvdXNWYWwiLCJ0cmFja0NvbXBvbmVudCIsIkNvbXBDbGFzcyIsIlByb3h5IiwiY29uc3RydWN0IiwiQ29tcG9uZW50IiwiV29ybGQiLCJwcmVkaWNhdGUiLCJyZXN1bHRzIiwibG9jYXRlIiwibG9jYXRlQWxsIiwiZGVmYXVsdFZhbHVlIiwicmVzdWx0IiwiZ3JhYiIsInRhZ0VudGl0eUlkcyIsImVudGl0eUlkIiwiY3RBcnIiLCJoYXNCeU5hbWUiLCJkZXYiLCJhZGRTeXN0ZW0iLCJjcmVhdGVFbnRpdHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7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LE1BQVAsQ0FIeUIsQ0FLekI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBOzs7QUFDRWlFLGVBQWEsQ0FBQ3VCLEdBQUQsRUFBMkI7QUFDdEMsU0FBS25DLG9CQUFMLENBQTBCcEUsTUFBMUIsQ0FBaUN1RyxHQUFqQztBQUNBLFNBQUtqQixRQUFMLENBQWN0RixNQUFkLENBQXFCdUcsR0FBckI7O0FBRUEsU0FBSyxNQUFNdkMsU0FBWCxJQUF3QixLQUFLaUMsZ0JBQUwsQ0FBc0JWLE1BQXRCLEVBQXhCLEVBQXdEO0FBQ3RELFVBQUl2QixTQUFTLENBQUMxRCxHQUFWLENBQWNpRyxHQUFkLENBQUosRUFBd0I7QUFDdEJ2QyxpQkFBUyxDQUFDaEUsTUFBVixDQUFpQnVHLEdBQWpCO0FBQ0Q7QUFDRixLQVJxQyxDQVV0Qzs7O0FBQ0EsU0FBSyxNQUFNLENBQUN4QyxHQUFELEVBQU1DLFNBQU4sQ0FBWCxJQUErQixLQUFLQyxjQUFwQyxFQUFvRDtBQUNsRCxVQUFJRCxTQUFTLENBQUMxRCxHQUFWLENBQWNpRyxHQUFkLENBQUosRUFBd0I7QUFDdEJ2QyxpQkFBUyxDQUFDaEUsTUFBVixDQUFpQnVHLEdBQWpCO0FBQ0Q7O0FBRUQsVUFBSXZDLFNBQVMsQ0FBQ3RELElBQVYsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsYUFBS3VELGNBQUwsQ0FBb0JqRSxNQUFwQixDQUEyQitELEdBQTNCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLElBQVA7QUFDRDs7QUFyWDRCLEM7O0FDVi9CO0FBQ0EiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxudmFyIGdldFJhbmRvbVZhbHVlcztcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuICAgIC8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFycikge1xuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgdmFyIHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7IiwiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwiZXhwb3J0IGZ1bmN0aW9uIGlzQ29tcG9uZW50SW5zdGFuY2U8VD4oXG4gIENsYXNzOiBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gVCxcbiAgY29tcDogYW55XG4pOiBjb21wIGlzIEluc3RhbmNlVHlwZTx0eXBlb2YgQ2xhc3M+IHtcbiAgaWYgKCFjb21wKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENsYXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHsgaXNDb21wb25lbnRJbnN0YW5jZSB9IGZyb20gXCIuL2d1YXJkc1wiO1xuXG50eXBlIENvbXBOYW1lID0gc3RyaW5nO1xudHlwZSBDbGFzc0NvbnN0cnVjdG9yPFQ+ID0geyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVCB9O1xuXG4vLyBDVCBpcyBhIFVuaW9uLCBsaWtlIGB0eXBlID0gRmlyc3RDb21wb25lbnQgfCBTZWNvbmRDb21wb25lbnRgLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4ge1xuICBjb21wb25lbnRzOiBNYXA8Q29tcE5hbWUsIENUPiA9IG5ldyBNYXAoKTtcblxuICAvLyBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudFxuICAvLyBhZGQgPSAoY29tcG9uZW50OiBJbnN0YW5jZVR5cGU8Q1Rba2V5b2YgQ1RdPik6IHZvaWQgPT4ge1xuICBhZGQgPSAoY29tcG9uZW50OiBDVCk6IHZvaWQgPT4ge1xuICAgIHRoaXMuY29tcG9uZW50cy5zZXQoKDxhbnk+Y29tcG9uZW50KS5jb25zdHJ1Y3Rvci5uYW1lLCBjb21wb25lbnQpO1xuICB9O1xuXG4gIHVwZGF0ZSA9IDxUIGV4dGVuZHMgQ1Q+KFxuICAgIGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+LFxuICAgIGZ1bmM6IChjOiBUKSA9PiBUXG4gICk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IGMgPSB0aGlzLmNvbXBvbmVudHMuZ2V0KGNsLm5hbWUpO1xuXG4gICAgaWYgKGlzQ29tcG9uZW50SW5zdGFuY2UoY2wsIGMpKSB7XG4gICAgICBjb25zdCB1cGRhdGVkQ29tcG9uZW50ID0gZnVuYyhjKTtcbiAgICAgIHRoaXMuY29tcG9uZW50cy5zZXQoY2wubmFtZSwgdXBkYXRlZENvbXBvbmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBjVHlwZSBDbGFzcyBvZiBjb21wb25lbnQgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlID0gKGNUeXBlOiBDbGFzc0NvbnN0cnVjdG9yPENUPik6IHZvaWQgPT4ge1xuICAgIHRoaXMuY29tcG9uZW50cy5kZWxldGUoY1R5cGUubmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGNvbXBvbmVudCB0aGF0IG1hdGNoZXMgdGhlIHBhc3NlZCBjbGFzcy5cbiAgICogV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gY29tcG9uZW50XG4gICAqIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGNvbGxlY3Rpb24sIHNvIGlmIHlvdSBkb24ndCBrbm93IGlmIGl0J3Mgc2FmZVxuICAgKiB0byBnZXQgYSBjb21wb25lbnQsIHlvdSBzaG91bGQgdGVzdCB3aXRoIGhhcygpIG9yIGhhc0J5TmFtZSgpIGZpcnN0LlxuICAgKiBZb3UgaGF2ZSBiZWVuIHdhcm5lZC5cbiAgICogQHBhcmFtIGNsIGNvbXBvbmVudCBDbGFzcyByZWZlcmVuY2UuXG4gICAqL1xuICBnZXQgPSA8VCBleHRlbmRzIENUPihjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPik6IFQgPT4ge1xuICAgIGNvbnN0IGNvbXAgPSB0aGlzLmNvbXBvbmVudHMuZ2V0KGNsLm5hbWUpO1xuXG4gICAgaWYgKGlzQ29tcG9uZW50SW5zdGFuY2U8VD4oY2wsIGNvbXApKSB7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ29tcG9uZW50Q29sbGVjdGlvbiBkb2VzIG5vdCBoYXZlIGNvbXBvbmVudCBvZiB0eXBlICR7Y2wubmFtZX1gXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvLyBQb3NzaWJsZSBvdGhlciB3YXkgdG8gd3JpdGUgYSBnZXQgbWV0aG9kIHRoYXQgbWFpbnRhaW5zIHRoZSB0eXBlIG9mIHRoZVxuICAvLyBDb21wb25lbnQgdGhyb3VnaG91dC4gS2VlcGluZyBhcm91bmQgZm9yIG5vdyBhcmUgYSByZWZlcmVuY2UuXG4gIC8vIGdldDxVIGV4dGVuZHMgQ1Q+KGNvbXBDbGFzczogQ2xhc3M8VT4pOiBVIHtcbiAgLy8gICBpZiAoIXRoaXMuY29tcG9uZW50cy5oYXMoY29tcENsYXNzLm5hbWUpKSB7XG4gIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gIC8vICAgICAgIGBDb21wb25lbnRDb2xsZWN0aW9uIGRvZXMgbm90IGhhdmUgY29tcG9uZW50IG9mIHR5cGUgJHtjb21wQ2xhc3MubmFtZX1gXG4gIC8vICAgICApO1xuICAvLyAgIH1cblxuICAvLyAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuZ2V0KGNvbXBDbGFzcy5uYW1lKSEgYXMgdW5rbm93biBhcyBVO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIFRlc3QgdG8gc2VlIGlmIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5zIGEgc3BlY2lmaWMgQ2xhc3Mgb3IgQ2xhc3Nlcy5cbiAgICogQHBhcmFtIGNUeXBlIGNvbXBvbmVudCBDbGFzcywgb3IgYXJyYXkgb2YgY29tcG9uZW50IENsYXNzZXMuXG4gICAqL1xuICBoYXMgPSAoY1R5cGU6IENsYXNzQ29uc3RydWN0b3I8Q1Q+IHwgQ2xhc3NDb25zdHJ1Y3RvcjxDVD5bXSk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNUeXBlKVxuICAgICAgPyBjVHlwZS5ldmVyeSgoY3QpID0+IHRoaXMuY29tcG9uZW50cy5oYXMoY3QubmFtZSkgPT09IHRydWUpXG4gICAgICA6IHRoaXMuY29tcG9uZW50cy5oYXMoY1R5cGUubmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3QgdG8gc2VlIGlmIHRoZSBjb2xsZWN0aW9uIGhhcyBhIGNvbXBvbmVudCBpbnN0YW5jZSBiYXNlZCBvbiBhXG4gICAqIGNsYXNzIG5hbWUuIFNvbWUgYnVpbGQgc3RlcHMvbWluaWZpZXJzIHdpbGwgY2hhbmdlIHRoZSBuYW1lIG9mIENsYXNzZXMsXG4gICAqIHNvIGl0J3MgdXN1YWxseSBiZXN0IHRvIHBhc3MgaW4gYSBNeUNsYXNzLm5hbWUgaW5zdGVhZCBvZiAnTXlDbGFzcycuXG4gICAqIEBwYXJhbSBjTmFtZSBUaGUgbmFtZSBvZiBhIENsYXNzLCBvciBhcnJheSBvZiBDbGFzcyBuYW1lcy5cbiAgICovXG4gIGhhc0J5TmFtZSA9IChjTmFtZTogc3RyaW5nIHwgc3RyaW5nW10pOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjTmFtZSlcbiAgICAgID8gY05hbWUuZXZlcnkoY3QgPT4gdGhpcy5jb21wb25lbnRzLmhhcyhjdCkgPT09IHRydWUpXG4gICAgICA6IHRoaXMuY29tcG9uZW50cy5oYXMoY05hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbXBvbmVudCB0eXBlIG5hbWVzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyB1c2VkIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZ2V0IGNvbXBvbmVudFR5cGVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuY29tcG9uZW50cy5rZXlzKCldO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBudW1iZXIgb2YgY29tcG9uZW50cyB0aGF0IGFyZSBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIGdldCBzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5zaXplO1xuICB9XG5cbiAgdG9EZXZDb21wb25lbnRzKCk6IFJlY29yZDxzdHJpbmcsIENUPiB7XG4gICAgY29uc3Qgb2JqOiBSZWNvcmQ8c3RyaW5nLCBDVD4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtjb21wTmFtZSwgY29tcF0gb2YgdGhpcy5jb21wb25lbnRzKSB7XG4gICAgICBvYmpbY29tcE5hbWVdID0gY29tcDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG4iLCJpbXBvcnQgV29ybGQgZnJvbSBcIi4vV29ybGRcIjtcbmltcG9ydCBFbnRpdHkgZnJvbSBcIi4vRW50aXR5XCI7XG5pbXBvcnQgeyBUYWcgfSBmcm9tIFwiLi9UYWdcIjtcblxuaW50ZXJmYWNlIERldkVudGl0eVRhYmxlUm93IHtcbiAgaWQ6IHN0cmluZztcbiAgY29tcG9uZW50czogc3RyaW5nO1xuICB0YWdzOiBzdHJpbmc7XG4gIHN5c3RlbXM6IHN0cmluZztcbn1cblxuY2xhc3MgRGV2RW50aXR5PENUPiB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgY29tcG9uZW50czogUmVjb3JkPHN0cmluZywgQ1Q+O1xuXG4gIHRhZ3M6IFRhZ1tdO1xuXG4gIHN5c3RlbXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZW50aXR5OiBFbnRpdHk8Q1Q+LCB3b3JsZDogV29ybGQ8Q1Q+KSB7XG4gICAgdGhpcy5pZCA9IGVudGl0eS5pZDtcbiAgICB0aGlzLmNvbXBvbmVudHMgPSBlbnRpdHkuY29tcG9uZW50cy50b0RldkNvbXBvbmVudHMoKSxcbiAgICB0aGlzLnRhZ3MgPSBbLi4uZW50aXR5LnRhZ3NdO1xuXG4gICAgY29uc3QgY29tcE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRzKTtcblxuICAgIGZvciAoY29uc3QgW3N5c3RlbU5hbWUsIGNOYW1lc10gb2Ygd29ybGQuc3lzdGVtcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUpIHtcbiAgICAgIGlmIChjTmFtZXMuZXZlcnkoKGNOYW1lKSA9PiBjb21wTmFtZXMuaW5jbHVkZXMoY05hbWUpKSkge1xuICAgICAgICB0aGlzLnN5c3RlbXMucHVzaChzeXN0ZW1OYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b1RhYmxlUm93KCk6IERldkVudGl0eVRhYmxlUm93IHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBjb21wb25lbnRzOiBPYmplY3Qua2V5cyh0aGlzLmNvbXBvbmVudHMpLmpvaW4oXCIsIFwiKSxcbiAgICAgIHRhZ3M6IHRoaXMudGFncy5qb2luKFwiLCBcIiksXG4gICAgICBzeXN0ZW1zOiB0aGlzLnN5c3RlbXMuam9pbignLCAnKSxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERldkVudGl0eTtcbiIsImV4cG9ydCB0eXBlIFN0YXRlID0gc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sO1xuXG5leHBvcnQgdHlwZSBUcmFuc2l0aW9uczxTIGV4dGVuZHMgU3RhdGUsIEQgPSB1bmRlZmluZWQ+ID0gUmVjb3JkPFxuICBTLFxuICAoZGF0YTogRCwgY3VycmVudDogUykgPT4gU1xuPjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltcGxlRlNNPFMgZXh0ZW5kcyBTdGF0ZSwgRCA9IHVuZGVmaW5lZD4ge1xuICBjdXJyZW50OiBTO1xuXG4gIGluaXRhbDogUztcblxuICB0cmFuc2l0aW9uczogVHJhbnNpdGlvbnM8UywgRD47XG5cbiAgY29uc3RydWN0b3IoaW5pdGlhbFN0YXRlOiBTLCB0cmFuc2l0aW9uczogVHJhbnNpdGlvbnM8UywgRD4pIHtcbiAgICB0aGlzLmluaXRhbCA9IGluaXRpYWxTdGF0ZTtcbiAgICB0aGlzLmN1cnJlbnQgPSBpbml0aWFsU3RhdGU7XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuICB9XG5cbiAgbmV4dChkYXRhOiBEKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbnNbdGhpcy5jdXJyZW50XSkge1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy50cmFuc2l0aW9uc1t0aGlzLmN1cnJlbnRdKGRhdGEsIHRoaXMuY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5pbml0YWw7XG4gIH1cblxuICBpcyhjaGVja1N0YXRlOiBTKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudCA9PT0gY2hlY2tTdGF0ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSBcInV1aWRcIjtcbmltcG9ydCBXb3JsZCwgeyBDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSBcIi4vV29ybGRcIjtcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gXCIuL0NvbXBvbmVudENvbGxlY3Rpb25cIjtcbmltcG9ydCB7IFRhZyB9IGZyb20gXCIuL1RhZ1wiO1xuaW1wb3J0IERldkVudGl0eSBmcm9tIFwiLi9EZXZFbnRpdHlcIjtcblxuaW1wb3J0IFNpbXBsZUZTTSBmcm9tIFwiLi9TaW1wbGVGU01cIjtcblxuZXhwb3J0IHR5cGUgRW50aXR5SWQgPSBzdHJpbmc7XG5cbnR5cGUgRW50aXR5U3RhdGUgPVxuICB8IFwiY3JlYXRpbmdcIlxuICB8IFwiY3JlYXRlZFwiXG4gIHwgXCJkZXN0cm95aW5nXCJcbiAgfCBcImRlc3Ryb3llZFwiXG4gIHwgXCJlcnJvclwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eUNvbXBFdmVudEFyZ3M8Q1Q+IHtcbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgY29tcG9uZW50OiBDVDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50aXR5PENUPiB7XG4gIHByaXZhdGUgX2lkOiBzdHJpbmc7XG4gIHByaXZhdGUgX3dvcmxkOiBXb3JsZDxDVD47XG5cbiAgcHJpdmF0ZSBfZXJyb3I6IEVycm9yIHwgbnVsbDtcblxuICBwcml2YXRlIF9zdGF0ZTogU2ltcGxlRlNNPEVudGl0eVN0YXRlLCBFbnRpdHlTdGF0ZT47XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMuX2lkID0gdXVpZHY0KCk7XG4gICAgdGhpcy5fd29ybGQgPSB3b3JsZDtcblxuICAgIHRoaXMuX2Vycm9yID0gbnVsbDtcblxuICAgIGNvbnN0IGZzbVRyYW5zaXRpb24gPSAoXG4gICAgICBuczogRW50aXR5U3RhdGVcbiAgICApOiBFbnRpdHlTdGF0ZSA9PiB7XG4gICAgICBpZiAobnMgPT09IFwiZXJyb3JcIiB8fCB0aGlzLl9lcnJvcikgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICAgIHJldHVybiBucztcbiAgICB9O1xuXG4gICAgdGhpcy5fc3RhdGUgPSBuZXcgU2ltcGxlRlNNPEVudGl0eVN0YXRlLCBFbnRpdHlTdGF0ZT4oXCJjcmVhdGluZ1wiLCB7XG4gICAgICBjcmVhdGluZzogZnNtVHJhbnNpdGlvbixcbiAgICAgIGNyZWF0ZWQ6IGZzbVRyYW5zaXRpb24sXG4gICAgICBkZXN0cm95aW5nOiBmc21UcmFuc2l0aW9uLFxuICAgICAgZGVzdHJveWVkOiAoKSA9PiBcImRlc3Ryb3llZFwiLFxuICAgICAgZXJyb3I6ICgpID0+IFwiZXJyb3JcIixcbiAgICB9KTtcblxuICAgIC8qXG4gICAgUmVnaXN0ZXJpbmcgd2l0aCB0aGUgV29ybGQuXG4gICAgKi9cbiAgICB0aGlzLl93b3JsZC5yZWdpc3RlckVudGl0eSh0aGlzKTtcblxuICAgIGlmICh0aGlzLl93b3JsZC5zeXN0ZW1zLmNvbXBOYW1lc0J5U3lzdGVtTmFtZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5uZXh0KCdjcmVhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YXRlKCk6IEVudGl0eVN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuY3VycmVudDtcbiAgfVxuXG4gIGNoZWNrU3RhdGUocG9zc2libGVTdGF0ZTogRW50aXR5U3RhdGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaXMocG9zc2libGVTdGF0ZSk7XG4gIH1cblxuICAvKiBMaWZlQ3ljbGUgbWV0aG9kcywgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiAqL1xuXG4gIG9uQ3JlYXRlKHdvcmxkOiBXb3JsZDxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25EZXN0cm95KHdvcmxkOiBXb3JsZDxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25Db21wb25lbnRBZGQoYXJnczogRW50aXR5Q29tcEV2ZW50QXJnczxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25UcmFja2VkQ29tcG9uZW50VXBkYXRlKGFyZ3M6IEVudGl0eUNvbXBFdmVudEFyZ3M8Q1Q+KTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIG9uQ29tcG9uZW50UmVtb3ZlKGFyZ3M6IEVudGl0eUNvbXBFdmVudEFyZ3M8Q1Q+KTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBjb21wb25lbnQgdG8gYW4gRW50aXR5LCBkb2guXG4gICAqL1xuICBhZGQoY29tcG9uZW50OiBDVCk6IHRoaXMge1xuICAgIHRoaXMuX3dvcmxkLmFkZCh0aGlzLl9pZCwgY29tcG9uZW50KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHRhZyB0byBhIGNvbXBvbmVudFxuICAgKi9cbiAgYWRkVGFnKHRhZzogVGFnKTogdGhpcyB7XG4gICAgY29uc3QgZW50aXR5U2V0ID0gdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuaGFzKHRhZylcbiAgICAgID8gdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZylcbiAgICAgIDogbmV3IFNldDxFbnRpdHlJZD4oKTtcblxuICAgIGlmIChlbnRpdHlTZXQpIHtcbiAgICAgIGVudGl0eVNldC5hZGQodGhpcy5faWQpO1xuICAgICAgdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3Muc2V0KHRhZywgZW50aXR5U2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGFuIGVudGl0eSBoYXMgYSBjb21wb25lbnQgcmVsYXRlZCB0byBpdC5cbiAgICovXG4gIGhhcyhjVHlwZTogQ2xhc3NDb25zdHJ1Y3RvcjxDVD4pOiBib29sZWFuIHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLl93b3JsZC5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQodGhpcy5faWQpIHx8XG4gICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIHJldHVybiBjYy5oYXMoY1R5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiBhbiBlbnRpdHkgdGFnZ2VkIHdpdGggYSBnaXZlbiB0YWcuXG4gICAqL1xuICBoYXNUYWcodGFnOiBUYWcpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuaGFzKHRhZykpIHtcbiAgICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuICAgICAgaWYgKGVudGl0eVNldCkge1xuICAgICAgICByZXR1cm4gZW50aXR5U2V0Lmhhcyh0aGlzLl9pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGNvbXBvbmVudCB0aGF0IGJlbG9uZ3MgdG8gYW4gZW50aXR5LlxuICAgKi9cbiAgZ2V0PFQgZXh0ZW5kcyBDVD4oY2w6IENsYXNzQ29uc3RydWN0b3I8VD4pOiBJbnN0YW5jZVR5cGU8dHlwZW9mIGNsPiB7XG4gICAgY29uc3QgY2MgPVxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICBjb25zdCBjb21wb25lbnQgPSBjYy5nZXQ8VD4oY2wpO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGNvbXBvbmVudHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gYW4gZW50aXR5LCB2aWEgYSBDb21wb25lbnRDb2xsZWN0aW9uXG4gICAqL1xuICBnZXRBbGwoKTogQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl93b3JsZC5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQodGhpcy5faWQpIHx8XG4gICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29tcG9uZW50IGZyb20gYW4gZW50aXR5LlxuICAgKiBAcGFyYW0gY1R5cGUgQSBjb21wb25lbnQgY2xhc3MsIGVnIE15Q29tcG9uZW50XG4gICAqL1xuICByZW1vdmUoY1R5cGU6IENsYXNzQ29uc3RydWN0b3I8Q1Q+KTogdGhpcyB7XG4gICAgdGhpcy5fd29ybGQucmVtb3ZlKHRoaXMuX2lkLCBjVHlwZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB0YWcgZnJvbSBhbiBlbnRpdHlcbiAgICovXG4gIHJlbW92ZVRhZyh0YWc6IFRhZyk6IHRoaXMge1xuICAgIGlmICh0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5oYXModGFnKSkge1xuICAgICAgY29uc3QgZW50aXR5U2V0ID0gdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZyk7XG5cbiAgICAgIGlmIChlbnRpdHlTZXQpIHtcbiAgICAgICAgZW50aXR5U2V0LmRlbGV0ZSh0aGlzLl9pZCk7XG5cbiAgICAgICAgaWYgKGVudGl0eVNldC5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ2xlYXJzIGFsbCBjb21wb25lbnRzIGZyb20gYW4gRW50aXR5ICovXG4gIGNsZWFyKCk6IHRoaXMge1xuICAgIHRoaXMuX3dvcmxkLmNsZWFyRW50aXR5Q29tcG9uZW50cyh0aGlzLl9pZCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHRhZ3Mgb24gYW4gZW50aXR5XG4gICAqL1xuICBjbGVhclRhZ3MoKTogdGhpcyB7XG4gICAgZm9yIChjb25zdCBbdGFnLCBlbnRpdHlTZXRdIG9mIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmVudHJpZXMoKSkge1xuICAgICAgZW50aXR5U2V0LmRlbGV0ZSh0aGlzLl9pZCk7XG5cbiAgICAgIGlmIChlbnRpdHlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5kZWxldGUodGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZpbmlzaENyZWF0aW9uKCk6IHZvaWQge1xuICAgIHRoaXMuX3N0YXRlLm5leHQoJ2NyZWF0ZWQnKTtcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gSWYgbm8gc3lzdGVtcyBhcmUgYWRkZWQsIHRoZSBkZXN0cm95IGltbWVkaWF0ZWx5LlxuICAgIGlmICh0aGlzLl93b3JsZC5zeXN0ZW1zLmNvbXBOYW1lc0J5U3lzdGVtTmFtZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lJbW1lZGlhdGVseSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc3RhdGUuaXMoXCJjcmVhdGVkXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRWNzdGF0aWM6IFVuYWJsZSB0byBkZXN0cm95IGlmIGl0IGlzbid0IGNyZWF0ZWQsIG9yIGFscmVhZHkgZGVzdHJveWVkXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gTWFyayBhcyBcImRlc3Ryb3lpbmdcIiBzbyB0aGF0IHN5c3RlbXMgY2FuIGFjdCBvbiBpdCBiZWZvcmUgYWN0dWFsbHkgYmVpbmcgZGVzdHJveWVkLlxuICAgIHRoaXMuX3N0YXRlLm5leHQoJ2Rlc3Ryb3lpbmcnKTtcbiAgfVxuXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuXG4gIGdldCB3b3JsZCgpOiBXb3JsZDxDVD4ge1xuICAgIHJldHVybiB0aGlzLl93b3JsZDtcbiAgfVxuXG4gIGRlc3Ryb3lJbW1lZGlhdGVseSgpOiB2b2lkIHtcbiAgICAvLyBSaWdodCBub3cgY2FsbGluZyBiZWZvcmUgdGhlIGFjdHVhbCBkZXN0b3J5aW5nIG9mIHRoZSBlbnRpdHkuXG4gICAgLy8gTWlnaHQgd2FudCB0byBjaGFuZ2UgdGhpcyB0byBwb3N0IGRlc3RydWN0aW9uIGluIHRoZSBmdXR1cmUsIHdobyBrbm93cy5cbiAgICB0aGlzLm9uRGVzdHJveSh0aGlzLl93b3JsZCk7XG5cbiAgICAvLyBBY3R1YWxseSBkZXN0cm95IGVudGl0eS5cbiAgICB0aGlzLl93b3JsZC5kZXN0cm95RW50aXR5KHRoaXMuX2lkKTsgLy8gc2hvdWxkIHJldHVybiBhbiBlcnJvcj8/XG5cbiAgICB0aGlzLl9zdGF0ZS5uZXh0KCdkZXN0cm95ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGNvbXBvbmVudHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gYW4gZW50aXR5LCB2aWEgYSBDb21wb25lbnRDb2xsZWN0aW9uLlxuICAgKiBEb2VzIHRoZSBzYW1lIHRoaW5nIGFzIGVudGl0eUluc3RhbmNlLmdldEFsbCgpLlxuICAgKi9cbiAgZ2V0IGNvbXBvbmVudHMoKTogQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl93b3JsZC5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQodGhpcy5faWQpIHx8XG4gICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGFsbCB0aGUgdGFncyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGlzIGVudGl0eS5cbiAgICovXG4gIGdldCB0YWdzKCk6IFNldDxUYWc+IHtcbiAgICBjb25zdCB0YWdzID0gbmV3IFNldDxUYWc+KCk7XG4gICAgZm9yIChjb25zdCBbdGFnLCBlbnRpdHlTZXRdIG9mIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGVudGl0eVNldC5oYXModGhpcy5faWQpKSB7XG4gICAgICAgIHRhZ3MuYWRkKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBFbnRpdHkgdG8gYSBEZXZFbnRpdHkuIFZlcnkgaGVscGZ1bCBpbiBmb3IgZGVidWdnaW5nLlxuICAgKi9cbiAgdG9EZXZFbnRpdHkoKTogRGV2RW50aXR5PENUPiB7XG4gICAgcmV0dXJuIG5ldyBEZXZFbnRpdHk8Q1Q+KHRoaXMsIHRoaXMuX3dvcmxkKTtcbiAgfVxufVxuIiwiaW1wb3J0IFdvcmxkIGZyb20gJy4vV29ybGQnO1xuaW1wb3J0IERldkVudGl0eSBmcm9tICcuL0RldkVudGl0eSc7XG5cbmludGVyZmFjZSBEZXZTeXN0ZW1Db21wcyB7XG4gIHN5c3RlbTogc3RyaW5nO1xuICBjb21wb25lbnRzOiBzdHJpbmc7XG59XG5cblxuY2xhc3MgRGV2VG9vbHM8Q1Q+IHtcbiAgd29ybGQ6IFdvcmxkPENUPjtcblxuICBjb25zdHJ1Y3Rvcih3b3JsZDogV29ybGQ8Q1Q+KSB7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICB9XG4gIC8qKlxuICAgKiBkaXNwbGF5IHRoZSBhbGwgc3lzdGVtcyBvZiB0aGUgd29ybGQsIGFuZCB0aGUgY29tcG9uZW50cyByZXF1aXJlZCBieSBlYWNoIHN5c3RlbS5cbiAgICogU3VwZXIgaGVscGZ1bCB0byB1c2Ugd2l0aCBjb25zb2xlLnRhYmxlKClcbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIGNvbnNvbGUudGFibGUod29ybGQuZGV2LnN5c3RlbUNvbXBvbmVudHMpO1xuICAgKiBgYGBcbiAgICovXG4gIGdldCBzeXN0ZW1Db21wb25lbnRzKCk6IERldlN5c3RlbUNvbXBzW10ge1xuICAgIGNvbnN0IGNvbXBzQnlTeXN0ZW1zID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtzeXN0ZW0sIGNvbXBOYW1lc10gb2YgdGhpcy53b3JsZC5zeXN0ZW1zLmNvbXBOYW1lc0J5U3lzdGVtTmFtZSkge1xuICAgICAgY29tcHNCeVN5c3RlbXMucHVzaCh7IHN5c3RlbSwgY29tcG9uZW50czogY29tcE5hbWVzLmpvaW4oXCIsIFwiKSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcHNCeVN5c3RlbXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGFycmF5IG9mIERldkVudGl0ZXMuIENhbiBiZSB2ZXJ5IGhlbHBmdWwgZm9yIHRoaW5ncyBsaWtlIGluc3BlY3RpbmcgY29tcG9uZW50IHN0YXRlLFxuICAgKiBhbmQgd2hpY2ggc3lzdGVtcyB3aWxsIGJlIGNhbGxlZCBvbiBhbiBlbnRpdHkuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zb2xlLnRhYmxlKHdvcmxkLmRldi5lbnRpdGllcyk7XG4gICAqXG4gICAqIC8vIFBybyB0aXAhIHRyeSBkaXNwbGF5aW5nIGEgdGFibGUgb2YgZW50aXRpZXMgd2l0aCBjb25zb2xlLnRhYmxlIGFuZCBEZXZFbnRpdHkudG9UYWJsZVJvdygpLlxuICAgKiBjb25zb2xlLnRhYmxlKHdvcmxkLmRldi5lbnRpdGllcy5tYXAoZGV2RW50aXR5ID0+IGRldkVudGl0eS50b1RhYmxlUm93KCkpKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIGdldCBlbnRpdGllcygpOiBEZXZFbnRpdHk8Q1Q+W10ge1xuICAgIHJldHVybiBbLi4udGhpcy53b3JsZC5lbnRpdGllcy52YWx1ZXMoKV0ubWFwKChlKSA9PiBlLnRvRGV2RW50aXR5KCkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERldlRvb2xzO1xuIiwiaW1wb3J0IEVudGl0eSwgeyBFbnRpdHlJZCB9IGZyb20gXCIuL0VudGl0eVwiO1xuaW1wb3J0IFdvcmxkLCB7IENsYXNzQ29uc3RydWN0b3IgfSBmcm9tIFwiLi9Xb3JsZFwiO1xuaW1wb3J0IENvbXBvbmVudENvbGxlY3Rpb24gZnJvbSBcIi4vQ29tcG9uZW50Q29sbGVjdGlvblwiO1xuXG4vKipcbiAqIEFyZ3VtZW50cyB0aGF0IGFyZSBwYXNzZWQgaW50byBhIFN5c3RlbSBmdW5jdGlvbiBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAqIFRoaXMgaXMgaG93IHlvdSBhY2NlcyB0aGluZ3MgbGlrZSB0aGUgZW50aXR5IHRoYXQgcGFydGljdWxhciBlbnRpdHkgdG8gYWN0IG9uLFxuICogYXMgd2VsbCBhcyBzb21lIG90aGVyIGhlbHBmdWwgcGFyYW1zIGxpa2UgaWYgdGhlIGVudGl0eSBpcyB0aGUgZmlyc3Qgb3IgbGFzdCBlbnRpdHlcbiAqIGluIHRoZSBncm91cCBvZiBlbnRpdGllcyB0aGF0IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3lzdGVtRnVuY0FyZ3M8Q1Q+IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGVudGl0eSBiZWluZyBpdGVyYXRlZC5cbiAgICovXG4gIGVudGl0eTogRW50aXR5PENUPjtcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnRzIHRoYXQgYmVsb25nIHRvIHRoZSBlbnRpdHlcbiAgICovXG4gIGNvbXBvbmVudHM6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+O1xuICAvKipcbiAgICogVGhlIFdvcmxkIGluc3RhbmNlLlxuICAgKiBVc2UgdGhpcyB0byBhY2Nlc3Mgb3RoZXIgZW50aXRpZXMuXG4gICAqL1xuICB3b3JsZDogV29ybGQ8Q1Q+O1xuICBpbmRleDogbnVtYmVyO1xuICBzaXplOiBudW1iZXI7XG4gIC8qKlxuICAgKiBJcyB0aGUgZmlyc3QgZW50aXR5IHRvIGJlIGl0ZXJhdGVkIG9uIHRoaXMgcnVuIG9mIGEgc3lzdGVtLlxuICAgKiBIZWxwZnVsIGZvciBzZXR0aW5nIHVwIHN0YXRlIHRoYXQgaXMgdGhlIHNhbWUgZm9yIGFsbCBlbnRpdGllcyBvbmx5IG9uY2UuXG4gICAqL1xuICBpc0ZpcnN0OiBib29sZWFuO1xuICAvKipcbiAgICogSXMgdGhlIGxhc3QgZW50aXR5IHRvIGJlIGl0ZXJhdGVkIG9uIHRoaXMgcnVuIG9mIGEgc3lzdGVtLlxuICAgKiBDYW4gYmUgaGVscGZ1bCB0byB0ZWFyIGRvd24gYW55dGhpbmcgdGhhdCBzaG91bGQgYmUgZGVhbHQgd2l0aCBhZnRlciBhbGwgdGhlIGVudGl0ZXMgaGF2ZSByYW4uXG4gICAqL1xuICBpc0xhc3Q6IGJvb2xlYW47XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIHN5c3RlbSBpcyBydW4uXG4gKi9cbmV4cG9ydCB0eXBlIFN5c3RlbUZ1bmM8Q1Q+ID0gKFxuICBzeXRlbUZ1bmNBcmdzOiBTeXN0ZW1GdW5jQXJnczxDVD5cbikgPT4gdm9pZDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3lzdGVtczxDVD4ge1xuICB3b3JsZDogV29ybGQ8Q1Q+O1xuXG4gIHN5c3RlbUZ1bmNCeVN5c3RlbU5hbWU6IE1hcDxzdHJpbmcsIFN5c3RlbUZ1bmM8Q1Q+PjsgLy8gZG91YmxlIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG1hcHMgYXJlIG9yZGVyZWQuXG5cbiAgY29tcE5hbWVzQnlTeXN0ZW1OYW1lOiBNYXA8c3RyaW5nLCBzdHJpbmdbXT47XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgICB0aGlzLnN5c3RlbUZ1bmNCeVN5c3RlbU5hbWUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBhZGQoY1R5cGVzOiBDbGFzc0NvbnN0cnVjdG9yPENUPltdLCBzeXN0ZW1GdW5jOiBTeXN0ZW1GdW5jPENUPiwgZnVuY05hbWU/OiBzdHJpbmcpOiB0aGlzIHtcbiAgICBjb25zdCBjTmFtZXMgPSBjVHlwZXMubWFwKChjdCkgPT4gY3QubmFtZSk7XG5cbiAgICBcbiAgICBsZXQgbmFtZSA9IHN5c3RlbUZ1bmMubmFtZTtcbiAgICBpZiAoc3lzdGVtRnVuYy5uYW1lID09PSAnJykge1xuICAgICAgLy8gU3VwZXIgYnJ1dGUgZm9yY2UsIGFuZCBtaWdodCBsZWFkIHRvIGVycm9ycyBpbiB0aGUgZnV0dXJlLCBidXQgZm9yIG5vd1xuICAgICAgLy8gdXNpbmcgdGhlIHN0cmluZ2lmaWVkIHN5c3RlbSBmdW5jdGlvbiBpZiB0aGUgZnVuY3Rpb24gZG9lc24ndCBhbHJlYWR5IGhhdmUgYSBuYW1lLlxuICAgICAgLy8gVGhpcyBpcyB1c2VmdWwgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdXNlZCBhcyBhIHN5c3RlbSBmdW5jdGlvbi5cbiAgICAgIC8vIE1pZ2h0IGJlIGdvb2QgdG8gZmlndXJlIG91dCBob3cgdG8gZ2V0IGEgaGFzaCBvZiB0aGUgZnVuY3Rpb24gc3RyaW5nLlxuICAgICAgbmFtZSA9IHN5c3RlbUZ1bmMudG9TdHJpbmcoKS5zbGljZSgwLCAzMCk7XG4gICAgfVxuXG4gICAgaWYgKGZ1bmNOYW1lKSB7XG4gICAgICBuYW1lID0gZnVuY05hbWU7XG4gICAgfVxuXG4gICAgdGhpcy5zeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lLnNldChuYW1lLCBzeXN0ZW1GdW5jKTtcbiAgICB0aGlzLmNvbXBOYW1lc0J5U3lzdGVtTmFtZS5zZXQobmFtZSwgY05hbWVzKTtcbiAgICB0aGlzLndvcmxkLmVudGl0aWVzQnlDVHlwZXMuc2V0KGNOYW1lcywgbmV3IFNldDxFbnRpdHlJZD4oKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJ1bigpOiB2b2lkIHtcblxuICAgIC8vIFRPRE86IE1pZ2h0IGJlIGNvb2wgdG8gYWRkIGEgd2F5IHRvIHN0b3AgdGhlIHN5c3RlbXMgbG9vcCB3aGVuIGluIGRldi5cbiAgICAvLyAgICAgICBNYXliZSBzb21ldGhpbmcgbGlrZSB3b3JsZC5kZXYuc3RvcCgpIG9yIHBhdXNlKCkuXG4gICAgZm9yIChjb25zdCBbXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHN5c3RlbUZ1bmMsXG4gICAgXSBvZiB0aGlzLnN5c3RlbUZ1bmNCeVN5c3RlbU5hbWUuZW50cmllcygpKSB7XG4gICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMud29ybGQuZW50aXRpZXNCeUNUeXBlcy5zaXplO1xuICAgICAgY29uc3QgY05hbWVzID0gdGhpcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUuZ2V0KGZ1bmNOYW1lKSB8fCBbXTtcbiAgICAgIGNvbnN0IGNUeXBlQXJycyA9IHRoaXMud29ybGQuZW50aXRpZXNCeUNUeXBlcy5nZXQoY05hbWVzKSB8fCBuZXcgU2V0KCk7XG5cbiAgICAgIGNvbnN0IGVudGl0aWVzSW5DcmVhdGluZ1N0YXRlID0gW107XG4gICAgICBjb25zdCBlbnRpdGllc0luRGVzdHJveWluZ1N0YXRlID0gW11cblxuICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy53b3JsZC5lbnRpdGllcy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoZW50aXR5LnN0YXRlID09PSAnY3JlYXRpbmcnKSB7XG4gICAgICAgICAgZW50aXRpZXNJbkNyZWF0aW5nU3RhdGUucHVzaChlbnRpdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudGl0eS5zdGF0ZSA9PT0gJ2Rlc3Ryb3lpbmcnKSB7XG4gICAgICAgICAgZW50aXRpZXNJbkRlc3Ryb3lpbmdTdGF0ZS5wdXNoKGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICBmb3IgKGNvbnN0IGVpZCBvZiBjVHlwZUFycnMpIHtcbiAgICAgICAgY29uc3QgYXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+ID0ge1xuICAgICAgICAgIGVudGl0eTogdGhpcy53b3JsZC5lbnRpdGllcy5nZXQoZWlkKSB8fCBuZXcgRW50aXR5PENUPih0aGlzLndvcmxkKSxcbiAgICAgICAgICBjb21wb25lbnRzOlxuICAgICAgICAgICAgdGhpcy53b3JsZC5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZWlkKSB8fFxuICAgICAgICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCksXG4gICAgICAgICAgd29ybGQ6IHRoaXMud29ybGQsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBpc0ZpcnN0OiBpbmRleCA9PT0gMCxcbiAgICAgICAgICBpc0xhc3Q6IGluZGV4ICsgMSA9PT0gc2l6ZSxcbiAgICAgICAgfTtcblxuICAgICAgICBzeXN0ZW1GdW5jKGFyZ3MpO1xuXG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzSW5DcmVhdGluZ1N0YXRlKSB7XG4gICAgICAgIGVudGl0eS5maW5pc2hDcmVhdGlvbigpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXNJbkRlc3Ryb3lpbmdTdGF0ZSkge1xuICAgICAgICBlbnRpdHkuZGVzdHJveUltbWVkaWF0ZWx5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgV29ybGQsIHsgQ2xhc3NDb25zdHJ1Y3RvciB9IGZyb20gXCIuL1dvcmxkXCI7XG5pbXBvcnQgRW50aXR5IGZyb20gXCIuL0VudGl0eVwiO1xuXG4vLyBXYWl0aW5nIGZvciBUeXBlc2NyaXB0IDQuMiB0byBjb21lIG91dCBzbyB0aGF0IFN5bWJvbHMgYXJlIHN1cHBvcmRlZCBrZXlzLlxuZXhwb3J0IGNvbnN0IFRyYWNrZWRDb21wU3ltYm9sS2V5cyA9IHtcbiAgaXNUcmFja2VkOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQuaXNUcmFja2VkXCIpLFxuICB3b3JsZDogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50LndvcmxkXCIpLFxuICBzZXRXb3JsZDogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50LnNldFdvcmxkXCIpLFxuICBvbkFkZDogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50Lm9uQWRkXCIpLFxuICBvblVwZGF0ZTogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50Lm9uVXBkYXRlXCIpLFxuICBvblJlbW92ZTogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50Lm9uUmVtb3ZlXCIpLFxufSBhcyBjb25zdDtcblxuLy9AdHMtaWdub3JlXG50eXBlIFRyYWNrZWRDb21wb25lbnQ8Q1Q+ID0ge1xuICBuZXcgKC4uLmFyZ3M6IGFueVtdKTogQ1Q7XG5cbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMuaXNUcmFja2VkXTogYm9vbGVhbjtcbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMuc2V0V29ybGRdOiAod29ybGQ6IFdvcmxkPENUPikgPT4gdm9pZDtcbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMud29ybGRdOiBXb3JsZDxDVD47XG4gIC8vQHRzLWlnbm9yZVxuICBbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uQWRkXTogKFxuICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgZW50aXR5OiBFbnRpdHk8Q1Q+XG4gICkgPT4gdm9pZDtcbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMub25SZW1vdmVdOiAoXG4gICAgd29ybGQ6IFdvcmxkPENUPixcbiAgICBlbnRpdHk6IEVudGl0eTxDVD5cbiAgKSA9PiB2b2lkO1xufTtcblxuaW50ZXJmYWNlIEFkZEV2ZW50QXJnczxDVD4ge1xuICBjb21wb25lbnQ6IENUO1xuICBlbnRpdHk6IEVudGl0eTxDVD47XG4gIHdvcmxkOiBXb3JsZDxDVD47XG59XG5cbmludGVyZmFjZSBVcGRhdGVFdmVudEFyZ3M8Q1Q+IHtcbiAgY29tcG9uZW50OiBDVDtcbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgcHJldmlvdXNWYWw6IENUW2tleW9mIENUXTtcbiAgcHJvcGVydHk6IGtleW9mIENUO1xufVxuXG5pbnRlcmZhY2UgUmVtb3ZlRXZlbnRBcmdzPENUPiB7XG4gIGNvbXBvbmVudDogQ1Q7XG4gIGVudGl0eTogRW50aXR5PENUPjtcbiAgd29ybGQ6IFdvcmxkPENUPjtcbn1cblxuaW50ZXJmYWNlIFRyYWNrZWRFdmVudEhhbmRsZXJzPENUPiB7XG4gIG9uQWRkPzogKGFyZ3M6IEFkZEV2ZW50QXJnczxDVD4pID0+IHZvaWQ7XG4gIG9uVXBkYXRlPzogKGFyZ3M6IFVwZGF0ZUV2ZW50QXJnczxDVD4pID0+IHZvaWQ7XG4gIG9uUmVtb3ZlPzogKGFyZ3M6IFJlbW92ZUV2ZW50QXJnczxDVD4pID0+IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzSW5zdGFuY2VQcm94eUhhbmRsZXJzPENUPihcbiAgdHJhY2tlZEV2ZW50SGFuZGxlcnM6IFRyYWNrZWRFdmVudEhhbmRsZXJzPENUPlxuKTogUHJveHlIYW5kbGVyPGFueT4ge1xuICBjb25zdCB1cGRhdGVkUHJvcHMgPSBuZXcgU2V0KCk7XG4gIHJldHVybiB7XG4gICAgc2V0KFxuICAgICAgY29tcG9uZW50OiBDVCxcbiAgICAgIHByb3BlcnR5OiBrZXlvZiBDVCxcbiAgICAgIHZhbHVlOiBDVFtrZXlvZiBDVF1cbiAgICApIHtcbiAgICAgIHVwZGF0ZWRQcm9wcy5hZGQocHJvcGVydHkpO1xuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHdvcmxkID0gY29tcG9uZW50W1xuICAgICAgICBUcmFja2VkQ29tcFN5bWJvbEtleXMud29ybGRcbiAgICAgIF0gYXMgV29ybGQ8Q1Q+O1xuXG4gICAgICBjb25zdCBwcmV2aW91c1ZhbCA9IGNvbXBvbmVudFtwcm9wZXJ0eV07XG5cbiAgICAgIGNvbXBvbmVudFtwcm9wZXJ0eV0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHRyYWNrZWRFdmVudEhhbmRsZXJzLm9uVXBkYXRlKSB7XG4gICAgICAgIHRyYWNrZWRFdmVudEhhbmRsZXJzLm9uVXBkYXRlKHtcbiAgICAgICAgICB3b3JsZCxcbiAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgcHJldmlvdXNWYWwsXG4gICAgICAgICAgcHJvcGVydHksXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tDb21wb25lbnQ8Q1Q+KFxuICBDb21wQ2xhc3M6IENsYXNzQ29uc3RydWN0b3I8Q1Q+LFxuICB0cmFja2VkRXZlbnRIYW5kbGVyczogVHJhY2tlZEV2ZW50SGFuZGxlcnM8Q1Q+XG4pOiBUcmFja2VkQ29tcG9uZW50PENUPiB7XG4gIHJldHVybiBuZXcgUHJveHkoQ29tcENsYXNzLCB7XG4gICAgY29uc3RydWN0KENvbXBvbmVudDogYW55LCBhcmdzOiBhbnkpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoLi4uYXJncykgYXMgQ1QgJiBUcmFja2VkQ29tcG9uZW50PENUPjtcbiAgICAgIC8vIGNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoLi4uYXJncykgYXMgVCAmIFRyYWNrZWRDb21wb25lbnQ8Q2xhc3M8VD4+O1xuICAgICAgLy8gY29uc3QgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudCguLi5hcmdzKSBhcyBJbnN0YW5jZVR5cGU8Q2xhc3M8VD4+O1xuXG4gICAgICAvLyBGb3IgdXNlIGluIGlkZW50aWZpbmcgYSBcInRyYWNrZWRcIiBjbGFzcyB0aHJvdWdoIHRoZSBwcm94eS5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5pc1RyYWNrZWRdID0gdHJ1ZTtcblxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLnNldFdvcmxkXSA9IChcbiAgICAgICAgd29ybGQ6IFdvcmxkPENUPlxuICAgICAgKSA9PiB7XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLndvcmxkXSA9IHdvcmxkO1xuICAgICAgfTtcblxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uQWRkXSA9IChcbiAgICAgICAgd29ybGQ6IFdvcmxkPENUPixcbiAgICAgICAgZW50aXR5OiBFbnRpdHk8Q1Q+XG4gICAgICApID0+IHtcbiAgICAgICAgaWYgKHRyYWNrZWRFdmVudEhhbmRsZXJzLm9uQWRkKSB7XG4gICAgICAgICAgdHJhY2tlZEV2ZW50SGFuZGxlcnMub25BZGQoeyBjb21wb25lbnQsIHdvcmxkLCBlbnRpdHkgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vblJlbW92ZV0gPSAoXG4gICAgICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgICAgIGVudGl0eTogRW50aXR5PENUPlxuICAgICAgKSA9PiB7XG4gICAgICAgIGlmICh0cmFja2VkRXZlbnRIYW5kbGVycy5vblJlbW92ZSkge1xuICAgICAgICAgIHRyYWNrZWRFdmVudEhhbmRsZXJzLm9uUmVtb3ZlKHsgY29tcG9uZW50LCB3b3JsZCwgZW50aXR5IH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb3h5KFxuICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIGNyZWF0ZUNsYXNzSW5zdGFuY2VQcm94eUhhbmRsZXJzKHRyYWNrZWRFdmVudEhhbmRsZXJzKVxuICAgICAgKTtcbiAgICB9LFxuICB9KTtcbn1cbiIsImltcG9ydCBFbnRpdHksIHsgRW50aXR5SWQgfSBmcm9tIFwiLi9FbnRpdHlcIjtcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gXCIuL0NvbXBvbmVudENvbGxlY3Rpb25cIjtcbmltcG9ydCB7IFRhZyB9IGZyb20gXCIuL1RhZ1wiO1xuaW1wb3J0IHsgU3lzdGVtRnVuYyB9IGZyb20gXCIuL1N5c3RlbXNcIjtcbmltcG9ydCBEZXZUb29scyBmcm9tIFwiLi9EZXZUb29sc1wiO1xuaW1wb3J0IFN5c3RlbXMgZnJvbSAnLi9TeXN0ZW1zJztcbmltcG9ydCB7IFRyYWNrZWRDb21wU3ltYm9sS2V5cyB9IGZyb20gJy4vVHJhY2tlZENvbXBvbmVudCc7XG5cbmV4cG9ydCB0eXBlIENsYXNzQ29uc3RydWN0b3I8VD4gPSB7IG5ldyAoLi4uYXJnczogYW55W10pOiBUIH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdvcmxkPENUPiB7XG4gIGNvbXBvbmVudENvbGxlY3Rpb25zOiBNYXA8RW50aXR5SWQsIENvbXBvbmVudENvbGxlY3Rpb248Q1Q+PiA9IG5ldyBNYXAoKTtcblxuICBlbnRpdGllczogTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+PiA9IG5ldyBNYXAoKTtcblxuICBlbnRpdGllc0J5Q1R5cGVzOiBNYXA8c3RyaW5nW10sIFNldDxFbnRpdHlJZD4+ID0gbmV3IE1hcCgpO1xuXG4gIGVudGl0aWVzQnlUYWdzOiBNYXA8VGFnLCBTZXQ8RW50aXR5SWQ+PiA9IG5ldyBNYXAoKTtcblxuICBzeXN0ZW1zOiBTeXN0ZW1zPENUPjtcblxuICBkZXY6IERldlRvb2xzPENUPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRldiA9IG5ldyBEZXZUb29scyh0aGlzKTtcbiAgICB0aGlzLnN5c3RlbXMgPSBuZXcgU3lzdGVtcyh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcImZpbmRzXCIgYSBzaW5nbGUgZW50aXR5IGJhc2VkIG9uIGEgcHJlZGljYXRlXG4gICAqL1xuICBmaW5kID0gKHByZWRpY2F0ZTogKGVudGl0eTogRW50aXR5PENUPikgPT4gYm9vbGVhbik6IEVudGl0eTxDVD4gfCBudWxsID0+IHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogXCJmaW5kc1wiIGFsbCBlbnRpdGllcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSwga2luZGEgbGlrZSBmaWx0ZXIuXG4gICAqL1xuICBmaW5kQWxsID0gKHByZWRpY2F0ZTogKGVudGl0eTogRW50aXR5PENUPikgPT4gYm9vbGVhbik6IEVudGl0eTxDVD5bXSA9PiB7XG4gICAgY29uc3QgcmVzdWx0czogRW50aXR5PENUPltdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGVudGl0eSkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFwibG9jYXRlc1wiIGEgc2luZ2xlIGVudGl0eSBiYXNlZCBvbiBpdHMgQ29tcG9uZW50cy5cbiAgICovXG4gIGxvY2F0ZSA9IChjbDogQ2xhc3NDb25zdHJ1Y3RvcjxDVD4gfCBDbGFzc0NvbnN0cnVjdG9yPENUPltdKTogRW50aXR5PENUPiB8IG51bGwgPT4ge1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHkuY29tcG9uZW50cy5oYXMoY2wpKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvY2F0ZXMgYWxsIGVudGl0aWVzIHRoYXQgY29udGFpbiB0aGUgY29tcG9uZW50cyBuYW1lZFxuICAgKi9cbiAgbG9jYXRlQWxsID0gKGNsOiBDbGFzc0NvbnN0cnVjdG9yPENUPiB8IENsYXNzQ29uc3RydWN0b3I8Q1Q+W10pOiBFbnRpdHk8Q1Q+W10gPT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6IEVudGl0eTxDVD5bXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVudGl0eS5jb21wb25lbnRzLmhhcyhjbCkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdyYWJzIHRoZSBmaXJzdCBlbnRpdHksIGFuZCBpdHMgcmVsYXRlZCBjb21wb25lbnQsIHRoYXQgbWF0Y2hlcyB0aGUgY29tcG9uZW50IHR5cGUuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zdCB7IGVudGl0eSwgY29tcG9uZW50IH0gPSB3b3JsZC5ncmFiKE15Q29tcG9uZW50KTtcbiAgICogYGBgXG4gICAqL1xuICBncmFiID0gPFQgZXh0ZW5kcyBDVD4oXG4gICAgY2w6IENsYXNzQ29uc3RydWN0b3I8VD5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogVCB9IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgZW50aXR5ID0gdGhpcy5sb2NhdGUoY2wpO1xuXG4gICAgaWYgKGVudGl0eSkge1xuICAgICAgY29uc3QgY2MgPVxuICAgICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlbnRpdHkuaWQpIHx8XG4gICAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgICBjb25zdCBjb21wb25lbnQgPSBjYy5nZXQ8VD4oY2wpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbnRpdHksXG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdyYWIgc2luZ2xlIGNvbXBvbmVudCBiYXNlZCBvbiBjb21wb25lbnQgdHlwZSBhbmQgcHJlZGljYXRlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHsgZW50aXR5LCBjb21wb25lbnQgfSA9IHdvcmxkLmdyYWJCeShGaXJzdENvbXBvbmVudCwgKGNvbXApID0+IGNvbXAuaWQgPT0gJ2F3ZXNvbWUnKVxuICAgKiBgYGBcbiAgICovXG4gIGdyYWJCeSA9IDxUIGV4dGVuZHMgQ1Q+KFxuICAgIGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+LFxuICAgIHByZWRpY2F0ZTogKGNvbXA6IFQpID0+IGJvb2xlYW5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogVCB9IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgZW50aXRpZXMgPSB0aGlzLmxvY2F0ZUFsbChjbCk7XG4gICAgLy8gY29uc3QgZW50aXRpZXMgPSB0aGlzLmxvY2F0ZUFsbCgoY2wgYXMgdW5rbm93bikgYXMgQ1QpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGNjID1cbiAgICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZW50aXR5LmlkKSB8fFxuICAgICAgICBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgICAgaWYgKHByZWRpY2F0ZShjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgIGVudGl0eSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR3JhYiBhbGwgdGhlIGNvbXBvbmVudHMgcHJpbWFyaWx5LCBhbmQgdGhlIGVudGl0aWVzIGlmIG5lZWRlZFxuICAgKi9cbiAgZ3JhYkFsbCA9IDxUIGV4dGVuZHMgQ1Q+KFxuICAgIGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+XG4gICk6IHsgZW50aXR5OiBFbnRpdHk8Q1Q+OyBjb21wb25lbnQ6IFQgfVtdID0+IHtcbiAgICBjb25zdCBlbnRpdGllcyA9IHRoaXMubG9jYXRlQWxsKGNsKTtcblxuICAgIHJldHVybiBlbnRpdGllcy5tYXAoKGVudGl0eSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW50aXR5LFxuICAgICAgICBjb21wb25lbnQ6IGVudGl0eS5jb21wb25lbnRzLmdldDxUPihjbCksXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRPRE86IEFkZCBncmFiQWxsQnkgbWV0aG9kXG5cbiAgLyoqXG4gICAqIEdpdmVuIGFuIGVudGl0eSBpZCBhbmQgY29tcG9uZW50VHlwZSwgcmV0dXJucyBjb21wb25lbnRcbiAgICovXG4gIGdldCA9IDxUIGV4dGVuZHMgQ1Q+KGVpZDogRW50aXR5SWQsIGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+KTogVCA9PiB7XG4gICAgY29uc3QgY2MgPVxuICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZWlkKSB8fCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIHJldHVybiBjYy5nZXQ8VD4oY2wpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIGFuZCBnZXQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGEgY29tcG9uZW50LCB3aXRob3V0IGFueSBhc3NvY2lhdGVkIGVudGl0aWVzLlxuICAgKiBIZWxwZnVsIGlzIHlvdSBrbm93IHRoYXQgb25seSBvbmUgaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgZXhpc3RzIGFjcm9zcyBhbGwgZW50aXRpZXMuXG4gICAqIEBwYXJhbSBjbCBDb21wb25lbnQgQ2xhc3MgQ29udHJ1Y3RvclxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEEgZGVmYXVsdCBjb21wb25lbnQgaW5zdGFuY2UgaWYgbm8gY29tcG9uZW50cyBhcmUgZm91bmQuXG4gICAqL1xuICBnZXRDb21wb25lbnQgPSA8VCBleHRlbmRzIENUPihcbiAgICBjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPixcbiAgICBkZWZhdWx0VmFsdWU/OiBUXG4gICk6IFQgfCBudWxsID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdyYWIoY2wpO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgPyBkZWZhdWx0VmFsdWUgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuY29tcG9uZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gZW50aXR5IHRoYXQgaGFzIGJlZW4gdGFnZ2VkIHdpdGggdGhlIGdpdmVuIHRhZywgb3IgcmV0dXJuIG51bGw7XG4gICAqL1xuICBnZXRUYWdnZWQgPSAodGFnOiBUYWcpOiBFbnRpdHk8Q1Q+IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgdGFnRW50aXR5SWRzID0gdGhpcy5lbnRpdGllc0J5VGFncy5nZXQodGFnKTtcblxuICAgIGlmICh0YWdFbnRpdHlJZHMpIHtcbiAgICAgIGNvbnN0IGVudGl0eUlkID0gdGFnRW50aXR5SWRzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZW50aXR5SWQpO1xuXG4gICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHQgYWxsIGVudGl0aWVzIHRoYXQgaGF2ZSBiZWVuIHRhZ2dlZCB3aXRoIHRoZSBnaXZlbiB0YWcuXG4gICAqIEBwYXJhbSB0YWcgQSBzdHJpbmcgb3IgbnVtYmVyLlxuICAgKi9cbiAgZ2V0QWxsVGFnZ2VkID0gKHRhZzogVGFnKTogRW50aXR5PENUPltdID0+IHtcbiAgICBsZXQgZW50aXRpZXM6IEVudGl0eTxDVD5bXSA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjb25zdCB0YWdFbnRpdHlJZHMgPSB0aGlzLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgaWYgKHRhZ0VudGl0eUlkcykge1xuICAgICAgZm9yIChjb25zdCBlbnRpdHlJZCBvZiB0YWdFbnRpdHlJZHMpIHtcbiAgICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZW50aXR5SWQpO1xuICAgICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgICAgZW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudGl0aWVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjb21wb25lbnQgb24gdGhlIGdpdmVuIGVudGl0eVxuICAgKi9cbiAgYWRkID0gPFQgZXh0ZW5kcyBDVD4oZWlkOiBFbnRpdHlJZCwgY29tcG9uZW50OiBUKTogdGhpcyA9PiB7XG4gICAgY29uc3QgY2MgPVxuICAgICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZWlkKSB8fCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIGNjLmFkZChjb21wb25lbnQpO1xuXG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZWlkLCBjYyk7XG5cbiAgICBmb3IgKGNvbnN0IFtjdEFyciwgZW50aXR5U2V0XSBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMpIHtcbiAgICAgIGlmICgoY3RBcnIgYXMgc3RyaW5nW10pLmV2ZXJ5KGNjLmhhc0J5TmFtZSkpIHtcbiAgICAgICAgZW50aXR5U2V0LmFkZChlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5pc1RyYWNrZWRdKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLnNldFdvcmxkXSh0aGlzKTtcblxuICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZWlkKTtcblxuICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3b3JsZC5hZGQ6IFVuYWJsZSB0byBsb2NhdGUgZW50aXR5LiBlaWQ6ICR7ZWlkfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uQWRkXSh0aGlzLCBlbnRpdHkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjb21wb25lbnQgZnJvbSB0aGUgZ2l2ZW4gZW50aXR5LlxuICAgKiBOT1RFOiBUaGlzIHdpbGwgY2hhbmdlIHdoYXQgc3lzdGVtcyB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgZW50aXR5LlxuICAgKi9cbiAgcmVtb3ZlID0gKGVpZDogRW50aXR5SWQsIGNUeXBlOiBDbGFzc0NvbnN0cnVjdG9yPENUPik6IHRoaXMgPT4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHwgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICAvLyBuZWVkIHRvIGdldCBjb21wb25lbnQgaW5zdGFuY2UuLi5cbiAgICBjb25zdCBjb21wb25lbnQgPSBjYy5nZXQoY1R5cGUpO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmlzVHJhY2tlZF0pIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW50aXRpZXMuZ2V0KGVpZCk7XG5cbiAgICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgd29ybGQucmVtb3ZlOiBVbmFibGUgdG8gbG9jYXRlIGVudGl0eS4gZWlkOiAke2VpZH0sIGNUeXBlOiAke2NUeXBlLm5hbWV9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMub25SZW1vdmVdKHRoaXMsIGVudGl0eSk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGVudGl0eSBmcm9tIGN1cnJlbnQgZW50aXRpZXNCeUNUeXBlc1xuICAgIGZvciAoY29uc3QgW2N0QXJyLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcykge1xuICAgICAgaWYgKChjdEFyciBhcyBzdHJpbmdbXSkuZXZlcnkoY2MuaGFzQnlOYW1lKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2MucmVtb3ZlKGNUeXBlKTtcblxuICAgIC8vIE1vdmUgZW50aXR5SWQgdG8gbmV3IENUeXBlcyBpZiBuZWVkZWQuXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5hZGQoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWx0ZXJuYXRpdmUgbWV0aG9kIGZvciBhZGRpbmcgc3lzdGVtcy5cbiAgICovXG4gIGFkZFN5c3RlbShjVHlwZXM6IENsYXNzQ29uc3RydWN0b3I8Q1Q+W10sIHN5c3RlbUZ1bmM6IFN5c3RlbUZ1bmM8Q1Q+LCBmdW5jTmFtZT86IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMuc3lzdGVtcy5hZGQoY1R5cGVzLCBzeXN0ZW1GdW5jLCBmdW5jTmFtZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG5cbiAgcmVnaXN0ZXJFbnRpdHkoZW50aXR5OiBFbnRpdHk8Q1Q+KTogV29ybGQ8Q1Q+IHtcbiAgICBjb25zdCBjYyA9IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZW50aXR5LmlkLCBjYyk7XG4gICAgdGhpcy5lbnRpdGllcy5zZXQoZW50aXR5LmlkLCBlbnRpdHkpO1xuXG4gICAgZW50aXR5Lm9uQ3JlYXRlKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBjb21wb25lbnRzIHRoYXQgYmVsb25nIHRvIGFuIGVudGl0eS5cbiAgICovXG4gIGNsZWFyRW50aXR5Q29tcG9uZW50cyhlaWQ6IEVudGl0eUlkKTogdGhpcyB7XG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZWlkLCBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKSk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eVNldCBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVpZCkpIHtcbiAgICAgICAgZW50aXR5U2V0LmRlbGV0ZShlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlbnRpdHkgdGhhdCBpcyBpbiB0aGUgd29ybGQuXG4gICAqIEJhc2ljYWxseSBqdXN0IG5ldyBFbnRpdHkod29ybGQpLCBidXQgc2F2ZXMgYW4gaW1wb3J0IG9mIEVudGl0eS5cbiAgICovXG4gIGNyZWF0ZUVudGl0eSgpOiBFbnRpdHk8Q1Q+IHtcbiAgICBjb25zdCBlbnRpdHkgPSBuZXcgRW50aXR5KHRoaXMpO1xuXG4gICAgcmV0dXJuIGVudGl0eTtcblxuICAgIC8vIFJlZ2lzdGVyIGVudGl0eSBoZXJlLi4uLlxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGVudGl0eS5cbiAgICogU2FtZSBhcyBlbnRpdHkuZGVzdHJveSgpLlxuICAgKi9cbiAgZGVzdHJveUVudGl0eShlaWQ6IEVudGl0eUlkKTogV29ybGQ8Q1Q+IHtcbiAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmRlbGV0ZShlaWQpO1xuICAgIHRoaXMuZW50aXRpZXMuZGVsZXRlKGVpZCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eVNldCBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVpZCkpIHtcbiAgICAgICAgZW50aXR5U2V0LmRlbGV0ZShlaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbnkgdGFnIGFzc29jaWF0aW9ucyB3aXRoIGRlc3Ryb3llZCBlbnRpdGllcy5cbiAgICBmb3IgKGNvbnN0IFt0YWcsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5VGFncykge1xuICAgICAgaWYgKGVudGl0eVNldC5oYXMoZWlkKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVpZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRpdHlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLmVudGl0aWVzQnlUYWdzLmRlbGV0ZSh0YWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCJpbXBvcnQgV29ybGQgZnJvbSAnLi9Xb3JsZCc7XG5pbXBvcnQgeyB0cmFja0NvbXBvbmVudCB9IGZyb20gJy4vVHJhY2tlZENvbXBvbmVudCc7XG5cbmV4cG9ydCB7XG4gIFdvcmxkLFxuICB0cmFja0NvbXBvbmVudCxcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')}])}));