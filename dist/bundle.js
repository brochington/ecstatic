!function(Q,B){"object"==typeof exports&&"object"==typeof module?module.exports=B():"function"==typeof define&&define.amd?define("ecstatic",[],B):"object"==typeof exports?exports.ecstatic=B():Q.ecstatic=B()}(window,(function(){return function(Q){var B=window.webpackHotUpdateecstatic;window.webpackHotUpdateecstatic=function(Q,n){!function(Q,B){if(!y[Q]||!x[Q])return;for(var n in x[Q]=!1,B)Object.prototype.hasOwnProperty.call(B,n)&&(b[n]=B[n]);0==--G&&0===u&&X()}(Q,n),B&&B(Q,n)};var n,t=!0,e="9ed2490d7a5d6d758ec0",F={},U=[],I=[];function s(Q){var B=r[Q];if(!B)return L;var t=function(t){return B.hot.active?(r[t]?-1===r[t].parents.indexOf(Q)&&r[t].parents.push(Q):(U=[Q],n=t),-1===B.children.indexOf(t)&&B.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+Q),U=[]),L(t)},e=function(Q){return{configurable:!0,enumerable:!0,get:function(){return L[Q]},set:function(B){L[Q]=B}}};for(var F in L)Object.prototype.hasOwnProperty.call(L,F)&&"e"!==F&&"t"!==F&&Object.defineProperty(t,F,e(F));return t.e=function(Q){return"ready"===l&&d("prepare"),u++,L.e(Q).then(B,(function(Q){throw B(),Q}));function B(){u--,"prepare"===l&&(R[Q]||V(Q),0===u&&0===G&&X())}},t.t=function(Q,B){return 1&B&&(Q=t(Q)),L.t(Q,-2&B)},t}function c(B){var t={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:n!==B,active:!0,accept:function(Q,B){if(void 0===Q)t._selfAccepted=!0;else if("function"==typeof Q)t._selfAccepted=Q;else if("object"==typeof Q)for(var n=0;n<Q.length;n++)t._acceptedDependencies[Q[n]]=B||function(){};else t._acceptedDependencies[Q]=B||function(){}},decline:function(Q){if(void 0===Q)t._selfDeclined=!0;else if("object"==typeof Q)for(var B=0;B<Q.length;B++)t._declinedDependencies[Q[B]]=!0;else t._declinedDependencies[Q]=!0},dispose:function(Q){t._disposeHandlers.push(Q)},addDisposeHandler:function(Q){t._disposeHandlers.push(Q)},removeDisposeHandler:function(Q){var B=t._disposeHandlers.indexOf(Q);B>=0&&t._disposeHandlers.splice(B,1)},invalidate:function(){switch(this._selfInvalidated=!0,l){case"idle":(b={})[B]=Q[B],d("ready");break;case"ready":E(B);break;case"prepare":case"check":case"dispose":case"apply":(o=o||[]).push(B)}},check:Z,apply:N,status:function(Q){if(!Q)return l;i.push(Q)},addStatusHandler:function(Q){i.push(Q)},removeStatusHandler:function(Q){var B=i.indexOf(Q);B>=0&&i.splice(B,1)},data:F[B]};return n=void 0,t}var i=[],l="idle";function d(Q){l=Q;for(var B=0;B<i.length;B++)i[B].call(null,Q)}var g,b,C,o,G=0,u=0,R={},x={},y={};function a(Q){return+Q+""===Q?+Q:Q}function Z(Q){if("idle"!==l)throw new Error("check() is only allowed in idle status");return t=Q,d("check"),(B=1e4,B=B||1e4,new Promise((function(Q,n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var t=new XMLHttpRequest,e=L.p+"hot/hot-update.json";t.open("GET",e,!0),t.timeout=B,t.send(null)}catch(Q){return n(Q)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)n(new Error("Manifest request to "+e+" timed out."));else if(404===t.status)Q();else if(200!==t.status&&304!==t.status)n(new Error("Manifest request to "+e+" failed."));else{try{var B=JSON.parse(t.responseText)}catch(Q){return void n(Q)}Q(B)}}}))).then((function(Q){if(!Q)return d(m()?"ready":"idle"),null;x={},R={},y=Q.c,C=Q.h,d("prepare");var B=new Promise((function(Q,B){g={resolve:Q,reject:B}}));b={};return V(0),"prepare"===l&&0===u&&0===G&&X(),B}));var B}function V(Q){var B;y[Q]?(x[Q]=!0,G++,(B=document.createElement("script")).charset="utf-8",B.src=L.p+"hot/hot-update.js",document.head.appendChild(B)):R[Q]=!0}function X(){d("ready");var Q=g;if(g=null,Q)if(t)Promise.resolve().then((function(){return N(t)})).then((function(B){Q.resolve(B)}),(function(B){Q.reject(B)}));else{var B=[];for(var n in b)Object.prototype.hasOwnProperty.call(b,n)&&B.push(a(n));Q.resolve(B)}}function N(B){if("ready"!==l)throw new Error("apply() is only allowed in ready status");return function B(t){var I,s,c,i,l;function g(Q){for(var B=[Q],n={},t=B.map((function(Q){return{chain:[Q],id:Q}}));t.length>0;){var e=t.pop(),F=e.id,U=e.chain;if((i=r[F])&&(!i.hot._selfAccepted||i.hot._selfInvalidated)){if(i.hot._selfDeclined)return{type:"self-declined",chain:U,moduleId:F};if(i.hot._main)return{type:"unaccepted",chain:U,moduleId:F};for(var I=0;I<i.parents.length;I++){var s=i.parents[I],c=r[s];if(c){if(c.hot._declinedDependencies[F])return{type:"declined",chain:U.concat([s]),moduleId:F,parentId:s};-1===B.indexOf(s)&&(c.hot._acceptedDependencies[F]?(n[s]||(n[s]=[]),G(n[s],[F])):(delete n[s],B.push(s),t.push({chain:U.concat([s]),id:s})))}}}}return{type:"accepted",moduleId:Q,outdatedModules:B,outdatedDependencies:n}}function G(Q,B){for(var n=0;n<B.length;n++){var t=B[n];-1===Q.indexOf(t)&&Q.push(t)}}m();var u={},R=[],x={},Z=function(){console.warn("[HMR] unexpected require("+X.moduleId+") to disposed module")};for(var V in b)if(Object.prototype.hasOwnProperty.call(b,V)){var X;l=a(V),X=b[V]?g(l):{type:"disposed",moduleId:V};var N=!1,E=!1,W=!1,p="";switch(X.chain&&(p="\nUpdate propagation: "+X.chain.join(" -> ")),X.type){case"self-declined":t.onDeclined&&t.onDeclined(X),t.ignoreDeclined||(N=new Error("Aborted because of self decline: "+X.moduleId+p));break;case"declined":t.onDeclined&&t.onDeclined(X),t.ignoreDeclined||(N=new Error("Aborted because of declined dependency: "+X.moduleId+" in "+X.parentId+p));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(X),t.ignoreUnaccepted||(N=new Error("Aborted because "+l+" is not accepted"+p));break;case"accepted":t.onAccepted&&t.onAccepted(X),E=!0;break;case"disposed":t.onDisposed&&t.onDisposed(X),W=!0;break;default:throw new Error("Unexception type "+X.type)}if(N)return d("abort"),Promise.reject(N);if(E)for(l in x[l]=b[l],G(R,X.outdatedModules),X.outdatedDependencies)Object.prototype.hasOwnProperty.call(X.outdatedDependencies,l)&&(u[l]||(u[l]=[]),G(u[l],X.outdatedDependencies[l]));W&&(G(R,[X.moduleId]),x[l]=Z)}var A,S=[];for(s=0;s<R.length;s++)l=R[s],r[l]&&r[l].hot._selfAccepted&&x[l]!==Z&&!r[l].hot._selfInvalidated&&S.push({module:l,parents:r[l].parents.slice(),errorHandler:r[l].hot._selfAccepted});d("dispose"),Object.keys(y).forEach((function(Q){!1===y[Q]&&function(Q){delete installedChunks[Q]}(Q)}));var h,D,v=R.slice();for(;v.length>0;)if(l=v.pop(),i=r[l]){var H={},Y=i.hot._disposeHandlers;for(c=0;c<Y.length;c++)(I=Y[c])(H);for(F[l]=H,i.hot.active=!1,delete r[l],delete u[l],c=0;c<i.children.length;c++){var k=r[i.children[c]];k&&((A=k.parents.indexOf(l))>=0&&k.parents.splice(A,1))}}for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=r[l]))for(D=u[l],c=0;c<D.length;c++)h=D[c],(A=i.children.indexOf(h))>=0&&i.children.splice(A,1);d("apply"),void 0!==C&&(e=C,C=void 0);for(l in b=void 0,x)Object.prototype.hasOwnProperty.call(x,l)&&(Q[l]=x[l]);var T=null;for(l in u)if(Object.prototype.hasOwnProperty.call(u,l)&&(i=r[l])){D=u[l];var z=[];for(s=0;s<D.length;s++)if(h=D[s],I=i.hot._acceptedDependencies[h]){if(-1!==z.indexOf(I))continue;z.push(I)}for(s=0;s<z.length;s++){I=z[s];try{I(D)}catch(Q){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:l,dependencyId:D[s],error:Q}),t.ignoreErrored||T||(T=Q)}}}for(s=0;s<S.length;s++){var J=S[s];l=J.module,U=J.parents,n=l;try{L(l)}catch(Q){if("function"==typeof J.errorHandler)try{J.errorHandler(Q)}catch(B){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:l,error:B,originalError:Q}),t.ignoreErrored||T||(T=B),T||(T=Q)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:l,error:Q}),t.ignoreErrored||T||(T=Q)}}if(T)return d("fail"),Promise.reject(T);if(o)return B(t).then((function(Q){return R.forEach((function(B){Q.indexOf(B)<0&&Q.push(B)})),Q}));return d("idle"),new Promise((function(Q){Q(R)}))}(B=B||{})}function m(){if(o)return b||(b={}),o.forEach(E),o=void 0,!0}function E(B){Object.prototype.hasOwnProperty.call(b,B)||(b[B]=Q[B])}var r={};function L(B){if(r[B])return r[B].exports;var n=r[B]={i:B,l:!1,exports:{},hot:c(B),parents:(I=U,U=[],I),children:[]};return Q[B].call(n.exports,n,n.exports,s(B)),n.l=!0,n.exports}return L.m=Q,L.c=r,L.d=function(Q,B,n){L.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:n})},L.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},L.t=function(Q,B){if(1&B&&(Q=L(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var n=Object.create(null);if(L.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var t in Q)L.d(n,t,function(B){return Q[B]}.bind(null,t));return n},L.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return L.d(B,"a",B),B},L.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},L.p="/static/",L.h=function(){return e},s(0)(L.s=0)}([function(Q,B,n){Q.exports=n(1)},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "World", function() { return /* reexport */ World_World; });\n__webpack_require__.d(__webpack_exports__, "trackComponent", function() { return /* reexport */ trackComponent; });\n\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== \'undefined\' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \'undefined\' && typeof msCrypto.getRandomValues === \'function\' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error(\'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js\n/* harmony default export */ var regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js\n\n\nfunction validate(uuid) {\n  return typeof uuid === \'string\' && regex.test(uuid);\n}\n\n/* harmony default export */ var esm_browser_validate = (validate);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var stringify_i = 0; stringify_i < 256; ++stringify_i) {\n  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It\'s been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \'-\' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \'-\' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \'-\' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \'-\' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it\'s likely due to one\n  // of the following:\n  // - One or more input array values don\'t map to a hex octet (leading to\n  // "undefined" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!esm_browser_validate(uuid)) {\n    throw TypeError(\'Stringified UUID is invalid\');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ var esm_browser_stringify = (stringify);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return esm_browser_stringify(rnds);\n}\n\n/* harmony default export */ var esm_browser_v4 = (v4);\n// CONCATENATED MODULE: ./src/guards.ts\nfunction isComponentInstance(Class, comp) {\n  if (!comp) {\n    return false;\n  }\n\n  if (!(comp instanceof Class)) {\n    return false;\n  }\n\n  return true;\n}\n// CONCATENATED MODULE: ./src/ComponentCollection.ts\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n// CT is a Union, like `type = FirstComponent | SecondComponent`.\nclass ComponentCollection_ComponentCollection {\n  constructor() {\n    _defineProperty(this, "components", new Map());\n\n    _defineProperty(this, "add", component => {\n      this.components.set(component.constructor.name, component);\n    });\n\n    _defineProperty(this, "update", (cl, func) => {\n      const c = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, c)) {\n        const updatedComponent = func(c);\n        this.components.set(cl.name, updatedComponent);\n      }\n    });\n\n    _defineProperty(this, "remove", cType => {\n      this.components.delete(cType.name);\n    });\n\n    _defineProperty(this, "get", cl => {\n      const comp = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, comp)) {\n        return comp;\n      } else {\n        throw new Error(`ComponentCollection does not have component of type ${cl.name}`);\n      }\n    });\n\n    _defineProperty(this, "has", cType => {\n      return Array.isArray(cType) ? cType.every(ct => this.components.has(ct.name) === true) : this.components.has(cType.name);\n    });\n\n    _defineProperty(this, "hasByName", cName => {\n      return Array.isArray(cName) ? cName.every(ct => this.components.has(ct) === true) : this.components.has(cName);\n    });\n  }\n\n  /**\n   * Get the component type names that are currently being used in the collection.\n   */\n  get componentTypes() {\n    return [...this.components.keys()];\n  }\n  /**\n   * Get the current number of components that are in the collection.\n   */\n\n\n  get size() {\n    return this.components.size;\n  }\n\n  toDevComponents() {\n    const obj = {};\n\n    for (const [compName, comp] of this.components) {\n      obj[compName] = comp;\n    }\n\n    return obj;\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevEntity.ts\nfunction DevEntity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevEntity {\n  constructor(entity, world) {\n    DevEntity_defineProperty(this, "id", void 0);\n\n    DevEntity_defineProperty(this, "components", void 0);\n\n    DevEntity_defineProperty(this, "tags", void 0);\n\n    DevEntity_defineProperty(this, "systems", []);\n\n    DevEntity_defineProperty(this, "state", void 0);\n\n    this.id = entity.id;\n    this.components = entity.components.toDevComponents(), this.tags = [...entity.tags];\n    this.state = entity.state;\n    const compNames = Object.keys(this.components);\n\n    for (const [systemName, cNames] of world.systems.compNamesBySystemName) {\n      if (cNames.every(cName => compNames.includes(cName))) {\n        this.systems.push(systemName);\n      }\n    }\n  }\n\n  toTableRow() {\n    return {\n      id: this.id,\n      components: Object.keys(this.components).join(", "),\n      tags: this.tags.join(", "),\n      systems: this.systems.join(\', \')\n    };\n  }\n\n}\n\n/* harmony default export */ var src_DevEntity = (DevEntity);\n// CONCATENATED MODULE: ./src/SimpleFSM.ts\nfunction SimpleFSM_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass SimpleFSM {\n  constructor(initialState, transitions) {\n    SimpleFSM_defineProperty(this, "current", void 0);\n\n    SimpleFSM_defineProperty(this, "inital", void 0);\n\n    SimpleFSM_defineProperty(this, "transitions", void 0);\n\n    this.inital = initialState;\n    this.current = initialState;\n    this.transitions = transitions;\n  }\n\n  next(data) {\n    if (this.transitions[this.current]) {\n      this.current = this.transitions[this.current](data, this.current);\n    }\n  }\n\n  reset() {\n    this.current = this.inital;\n  }\n\n  is(checkState) {\n    return this.current === checkState;\n  }\n\n}\n// CONCATENATED MODULE: ./src/Entity.ts\nfunction Entity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nclass Entity_Entity {\n  get id() {\n    return this._id;\n  }\n\n  get world() {\n    return this._world;\n  }\n\n  get state() {\n    return this._state.current;\n  }\n\n  constructor(world) {\n    Entity_defineProperty(this, "_id", void 0);\n\n    Entity_defineProperty(this, "_world", void 0);\n\n    Entity_defineProperty(this, "_error", void 0);\n\n    Entity_defineProperty(this, "_state", void 0);\n\n    this._id = esm_browser_v4();\n    this._world = world;\n    this._error = null;\n\n    const fsmTransition = ns => {\n      if (ns === "error" || this._error) return "error";\n      return ns;\n    };\n\n    this._state = new SimpleFSM("creating", {\n      creating: fsmTransition,\n      created: fsmTransition,\n      destroying: fsmTransition,\n      destroyed: () => "destroyed",\n      error: () => "error"\n    });\n    /*\n    Registering with the World.\n    */\n\n    this._world.registerEntity(this);\n\n    if (this._world.systems.compNamesBySystemName.size === 0) {\n      this._state.next(\'created\');\n    }\n  }\n  /* LifeCycle methods, meant to be overridden */\n\n\n  onCreate(world) {// abstract\n  }\n\n  onDestroy(world) {// abstract\n  }\n\n  onComponentAdd(args) {// abstract\n  }\n\n  onTrackedComponentUpdate(args) {// abstract\n  }\n\n  onComponentRemove(args) {// abstract\n  }\n  /**\n   * Add a component to an Entity, doh.\n   */\n\n\n  add(component) {\n    this._world.add(this._id, component);\n\n    return this;\n  }\n  /**\n   * Add a tag to a component\n   */\n\n\n  addTag(tag) {\n    const entitySet = this._world.entitiesByTags.has(tag) ? this._world.entitiesByTags.get(tag) : new Set();\n\n    if (entitySet) {\n      entitySet.add(this._id);\n\n      this._world.entitiesByTags.set(tag, entitySet);\n    }\n\n    return this;\n  }\n  /**\n   * Determines if an entity has a component related to it.\n   */\n\n\n  has(cType) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    return cc.has(cType);\n  }\n  /**\n   * Check to see if an entity tagged with a given tag.\n   */\n\n\n  hasTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        return entitySet.has(this._id);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get a component that belongs to an entity.\n   */\n\n\n  get(cl) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    const component = cc.get(cl);\n    return component;\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection\n   */\n\n\n  getAll() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Remove a component from an entity.\n   * @param cType A component class, eg MyComponent\n   */\n\n\n  remove(cType) {\n    this._world.remove(this._id, cType);\n\n    return this;\n  }\n  /**\n   * Remove a tag from an entity\n   */\n\n\n  removeTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        entitySet.delete(this._id);\n\n        if (entitySet.size === 0) {\n          this._world.entitiesByTags.delete(tag);\n        }\n      }\n    }\n\n    return this;\n  }\n  /** Clears all components from an Entity */\n\n\n  clear() {\n    this._world.clearEntityComponents(this._id);\n\n    return this;\n  }\n  /**\n   * Remove all tags on an entity\n   */\n\n\n  clearTags() {\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      entitySet.delete(this._id);\n\n      if (entitySet.size === 0) {\n        this._world.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Sets the state of the entity to \'created\'. that\'s it.\n   */\n\n\n  finishCreation() {\n    this._state.next(\'created\');\n  }\n  /**\n   * Destroy an entity. Actual destruction is deferred until after the next pass of systems.\n   * This gives the systems a chance to do any cleanup that might be needed.\n   */\n\n\n  destroy() {\n    // If no systems are added, the destroy immediately.\n    if (this._world.systems.compNamesBySystemName.size === 0) {\n      this.destroyImmediately();\n      return;\n    } // Mark as "destroying" so that systems can act on it before actually being destroyed.\n\n\n    this._state.next(\'destroying\');\n  }\n\n  destroyImmediately() {\n    // Right now calling before the actual destorying of the entity.\n    // Might want to change this to post destruction in the future, who knows.\n    this.onDestroy(this._world); // Actually destroy entity.\n\n    this._world.destroyEntity(this._id); // should return an error??\n\n\n    this._state.next(\'destroyed\');\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection.\n   * Does the same thing as entityInstance.getAll().\n   */\n\n\n  get components() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Retrieves all the tags that have been added to this entity.\n   */\n\n\n  get tags() {\n    const tags = new Set();\n\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      if (entitySet.has(this._id)) {\n        tags.add(tag);\n      }\n    }\n\n    return tags;\n  }\n  /**\n   * Convert Entity to a DevEntity. Very helpful in for debugging.\n   */\n\n\n  toDevEntity() {\n    return new src_DevEntity(this, this._world);\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevTools.ts\nfunction DevTools_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevTools {\n  constructor(world) {\n    DevTools_defineProperty(this, "world", void 0);\n\n    this.world = world;\n  }\n  /**\n   * display the all systems of the world, and the components required by each system.\n   * Super helpful to use with console.table()\n   * @example\n   * ```\n   * console.table(world.dev.systemComponents);\n   * ```\n   */\n\n\n  get systemComponents() {\n    const compsBySystems = [];\n\n    for (const [system, compNames] of this.world.systems.compNamesBySystemName) {\n      compsBySystems.push({\n        system,\n        components: compNames.join(", ")\n      });\n    }\n\n    return compsBySystems;\n  }\n  /**\n   * Create an array of DevEntites. Can be very helpful for things like inspecting component state,\n   * and which systems will be called on an entity.\n   * @example\n   * ```\n   * console.table(world.dev.entities);\n   *\n   * // Pro tip! try displaying a table of entities with console.table and DevEntity.toTableRow().\n   * console.table(world.dev.entities.map(devEntity => devEntity.toTableRow()));\n   * ```\n   */\n\n\n  get entities() {\n    return [...this.world.entities.values()].map(e => e.toDevEntity());\n  }\n\n}\n\n/* harmony default export */ var src_DevTools = (DevTools);\n// CONCATENATED MODULE: ./src/Systems.ts\nfunction Systems_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/**\n * Arguments that are passed into a System function on each iteration.\n * This is how you acces things like the entity that particular entity to act on,\n * as well as some other helpful params like if the entity is the first or last entity\n * in the group of entities that being iterated over.\n */\n\nclass Systems_Systems {\n  // double check to make sure that maps are ordered.\n  constructor(world) {\n    Systems_defineProperty(this, "world", void 0);\n\n    Systems_defineProperty(this, "systemFuncBySystemName", void 0);\n\n    Systems_defineProperty(this, "compNamesBySystemName", void 0);\n\n    this.world = world;\n    this.systemFuncBySystemName = new Map();\n    this.compNamesBySystemName = new Map();\n  }\n\n  add(cTypes, systemFunc, funcName) {\n    const cNames = cTypes.map(ct => ct.name);\n    let name = systemFunc.name;\n\n    if (systemFunc.name === "") {\n      // Super brute force, and might lead to errors in the future, but for now\n      // using the stringified system function if the function doesn\'t already have a name.\n      // This is useful for anonymous functions used as a system function.\n      // Might be good to figure out how to get a hash of the function string.\n      name = systemFunc.toString().slice(0, 30);\n    }\n\n    if (funcName) {\n      name = funcName;\n    }\n\n    this.systemFuncBySystemName.set(name, systemFunc);\n    this.compNamesBySystemName.set(name, cNames);\n    this.world.entitiesByCTypes.set(cNames, new Set());\n    return this;\n  }\n\n  run() {\n    const size = this.world.entitiesByCTypes.size;\n    const entitiesInCreatingState = [];\n    const entitiesInDestroyingState = [];\n\n    for (const entity of this.world.entities.values()) {\n      if (entity.state === "creating") {\n        entitiesInCreatingState.push(entity);\n      }\n\n      if (entity.state === "destroying") {\n        entitiesInDestroyingState.push(entity);\n      }\n    }\n\n    for (const [funcName, systemFunc] of this.systemFuncBySystemName.entries()) {\n      let index = 0;\n      const cNames = this.compNamesBySystemName.get(funcName) || [];\n      const cTypeArrs = this.world.entitiesByCTypes.get(cNames) || new Set();\n\n      for (const eid of cTypeArrs) {\n        const args = {\n          entity: this.world.entities.get(eid) || new Entity_Entity(this.world),\n          components: this.world.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(),\n          world: this.world,\n          index,\n          size,\n          isFirst: index === 0,\n          isLast: index + 1 === size\n        };\n        systemFunc(args);\n        index += 1;\n      }\n    }\n\n    for (const entity of entitiesInCreatingState) {\n      entity.finishCreation();\n    }\n\n    for (const entity of entitiesInDestroyingState) {\n      entity.destroyImmediately();\n    }\n  }\n  /*\n    TODO: Nice to have options here:\n      - systems.activeSystems = new Set(); // if not in set, system doesn\'t run.\n      - systems.deactivateSystem(\'systemName\') // remove system from activeSystems\n      - systems.activateSystem(\'systemName) // adds system back to activeSystems\n      - systems.pause() // pauses running of systems. basically return immediately on run().\n      - systems.resume() // resume running of systems.\n  */\n\n\n}\n// CONCATENATED MODULE: ./src/TrackedComponent.ts\n// Waiting for Typescript 4.2 to come out so that Symbols are supporded keys.\nconst TrackedCompSymbolKeys = {\n  isTracked: Symbol.for("ecs.trackedComponent.isTracked"),\n  world: Symbol.for("ecs.trackedComponent.world"),\n  entityIDs: Symbol.for("ecs.trackedComponent.entityIDs"),\n  getEntities: Symbol.for("ecs.trackedComponent.getEntities"),\n  setWorld: Symbol.for("ecs.trackedComponent.setWorld"),\n  onAdd: Symbol.for("ecs.trackedComponent.onAdd"),\n  onUpdate: Symbol.for("ecs.trackedComponent.onUpdate"),\n  onRemove: Symbol.for("ecs.trackedComponent.onRemove")\n}; //@ts-ignore\n\nfunction createClassInstanceProxyHandlers(trackedEventHandlers) {\n  const updatedProps = new Set();\n  return {\n    set(component, property, value) {\n      updatedProps.add(property); //@ts-ignore\n\n      const world = component[TrackedCompSymbolKeys.world];\n      const previousVal = component[property];\n      component[property] = value; //@ts-ignore\n\n      const entities = component[TrackedCompSymbolKeys.getEntities](world);\n\n      for (const entity of entities.values()) {\n        entity.onTrackedComponentUpdate({\n          world,\n          component\n        });\n      }\n\n      if (trackedEventHandlers.onUpdate) {\n        trackedEventHandlers.onUpdate({\n          entities,\n          world,\n          component,\n          previousVal,\n          property\n        });\n      }\n\n      return true;\n    }\n\n  };\n}\n\nfunction trackComponent(CompClass, trackedEventHandlers) {\n  return new Proxy(CompClass, {\n    construct(Component, args) {\n      const component = new Component(...args); // For use in identifing a "tracked" class through the proxy.\n      //@ts-ignore\n\n      component[TrackedCompSymbolKeys.isTracked] = true; //@ts-ignore\n\n      component[TrackedCompSymbolKeys.setWorld] = world => {\n        //@ts-ignore\n        component[TrackedCompSymbolKeys.world] = world;\n      }; // Holds entities that this component has been added to.\n      // Added and removed in world.add()/world.remove().\n      //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.entityIDs] = new Set(); // Helper function to get the Entities from entityIDs\n      //@ts-ignore\n\n      component[TrackedCompSymbolKeys.getEntities] = world => {\n        const entities = new Map(); //@ts-ignore\n\n        for (const eid of component[TrackedCompSymbolKeys.entityIDs]) {\n          const entity = world.entities.get(eid);\n\n          if (entity) {\n            entities.set(eid, entity);\n          }\n        }\n\n        return entities;\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onAdd] = (world, entity) => {\n        if (trackedEventHandlers.onAdd) {\n          //@ts-ignore\n          const entities = component[TrackedCompSymbolKeys.getEntities](world);\n          trackedEventHandlers.onAdd({\n            component,\n            world,\n            entity,\n            entities\n          });\n        }\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onRemove] = (world, entity) => {\n        if (trackedEventHandlers.onRemove) {\n          //@ts-ignore\n          const entities = component[TrackedCompSymbolKeys.getEntities](world);\n          trackedEventHandlers.onRemove({\n            component,\n            world,\n            entity,\n            entities\n          });\n        }\n      };\n\n      return new Proxy(component, createClassInstanceProxyHandlers(trackedEventHandlers));\n    }\n\n  });\n}\n// CONCATENATED MODULE: ./src/World.ts\nfunction World_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nclass World_World {\n  constructor() {\n    World_defineProperty(this, "componentCollections", new Map());\n\n    World_defineProperty(this, "entities", new Map());\n\n    World_defineProperty(this, "entitiesByCTypes", new Map());\n\n    World_defineProperty(this, "entitiesByTags", new Map());\n\n    World_defineProperty(this, "systems", void 0);\n\n    World_defineProperty(this, "dev", void 0);\n\n    World_defineProperty(this, "find", predicate => {\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "findAll", predicate => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "locate", cl => {\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "locateAll", cl => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "grab", cl => {\n      const entity = this.locate(cl);\n\n      if (entity) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n        return {\n          entity,\n          component\n        };\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabBy", (cl, predicate) => {\n      const entities = this.locateAll(cl); // const entities = this.locateAll((cl as unknown) as CT);\n\n      for (const entity of entities) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n\n        if (predicate(component)) {\n          return {\n            component,\n            entity\n          };\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabAll", cl => {\n      const entities = this.locateAll(cl);\n      return entities.map(entity => {\n        return {\n          entity,\n          component: entity.components.get(cl)\n        };\n      });\n    });\n\n    World_defineProperty(this, "get", (eid, cl) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      return cc.get(cl);\n    });\n\n    World_defineProperty(this, "getComponent", (cl, defaultValue) => {\n      const result = this.grab(cl);\n\n      if (!result) {\n        return defaultValue ? defaultValue : null;\n      }\n\n      return result.component;\n    });\n\n    World_defineProperty(this, "getTagged", tag => {\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        const entityId = tagEntityIds.values().next().value;\n        const entity = this.entities.get(entityId);\n\n        if (entity) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "getAllTagged", tag => {\n      let entities = []; // eslint-disable-line\n\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        for (const entityId of tagEntityIds) {\n          const entity = this.entities.get(entityId);\n\n          if (entity) {\n            entities.push(entity);\n          }\n        }\n      }\n\n      return entities;\n    });\n\n    World_defineProperty(this, "add", (eid, component) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      const entity = this.entities.get(eid);\n\n      if (!entity) {\n        throw new Error(`world.add: Unable to locate entity with id ${eid}`);\n      }\n\n      cc.add(component);\n      this.componentCollections.set(eid, cc);\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      } // @ts-ignore\n\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        // @ts-ignore\n        component[TrackedCompSymbolKeys.setWorld](this); // @ts-ignore\n\n        component[TrackedCompSymbolKeys.entityIDs].add(eid); // @ts-ignore\n\n        component[TrackedCompSymbolKeys.onAdd](this, entity);\n      }\n\n      entity.onComponentAdd({\n        world: this,\n        component\n      });\n      return this;\n    });\n\n    World_defineProperty(this, "remove", (eid, cType) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(); // need to get component instance...\n\n      const component = cc.get(cType); // @ts-ignore\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        const entity = this.entities.get(eid);\n\n        if (!entity) {\n          throw new Error(`world.remove: Unable to locate entity. eid: ${eid}, cType: ${cType.name}`);\n        } // @ts-ignore\n\n\n        component[TrackedCompSymbolKeys.entityIDs].delete(eid); // @ts-ignore\n\n        component[TrackedCompSymbolKeys.onRemove](this, entity);\n      } // remove entity from current entitiesByCTypes\n\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.delete(eid);\n        }\n      }\n\n      cc.remove(cType); // Move entityId to new CTypes if needed.\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      const entity = this.entities.get(eid);\n\n      if (entity) {\n        entity.onComponentRemove({\n          world: this,\n          component\n        });\n      }\n\n      return this;\n    });\n\n    this.dev = new src_DevTools(this);\n    this.systems = new Systems_Systems(this);\n  }\n  /**\n   * "finds" a single entity based on a predicate\n   */\n\n\n  /**\n   * Alternative method for adding systems.\n   */\n  addSystem(cTypes, systemFunc, funcName) {\n    this.systems.add(cTypes, systemFunc, funcName);\n    return this;\n  }\n  /**\n   * Setup an entity to exist in the given world. This is mostly an internal method, but exposed just in case.\n   */\n\n\n  registerEntity(entity) {\n    const cc = new ComponentCollection_ComponentCollection();\n    this.componentCollections.set(entity.id, cc);\n    this.entities.set(entity.id, entity);\n    entity.onCreate(this);\n    return this;\n  }\n  /**\n   * Remove all components that belong to an entity.\n   */\n\n\n  clearEntityComponents(entityId) {\n    this.componentCollections.set(entityId, new ComponentCollection_ComponentCollection());\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(entityId)) {\n        entitySet.delete(entityId);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Create an entity that is in the world.\n   * Basically just new Entity(world), but saves an import of Entity.\n   */\n\n\n  createEntity() {\n    const entity = new Entity_Entity(this);\n    return entity; // Register entity here....\n  }\n  /**\n   * Destroys an entity.\n   * Same as entity.destroy().\n   */\n\n\n  destroyEntity(entityId) {\n    this.componentCollections.delete(entityId);\n    const entity = this.entities.get(entityId);\n\n    if (!entity) {\n      throw new Error(`world.destroyEntity: No entity found. entity id: ${entityId}`);\n    }\n\n    this.entities.delete(entityId);\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(entityId)) {\n        entitySet.delete(entityId);\n      }\n    } // remove any tag associations with destroyed entities.\n\n\n    for (const [tag, entitySet] of this.entitiesByTags) {\n      if (entitySet.has(entityId)) {\n        entitySet.delete(entityId);\n      }\n\n      if (entitySet.size === 0) {\n        this.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n  /*\n  TODO: world.destroy() and world.destroyImmediately() methods.\n  */\n\n\n}\n// CONCATENATED MODULE: ./src/index.ts\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY3N0YXRpYy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzP2Q4ZjgiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzPzQwZDYiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzA2ZTQiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3N0cmluZ2lmeS5qcz81OGNmIiwid2VicGFjazovL2Vjc3RhdGljLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz9lYzI2Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL2d1YXJkcy50cz8zYjU3Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL0NvbXBvbmVudENvbGxlY3Rpb24udHM/NTFjNCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZFbnRpdHkudHM/ZDE0MiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9TaW1wbGVGU00udHM/NDY5OSIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9FbnRpdHkudHM/YWM2OCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZUb29scy50cz9lMDFhIiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL1N5c3RlbXMudHM/YTYxMyIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9UcmFja2VkQ29tcG9uZW50LnRzP2JhMjciLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9zcmMvV29ybGQudHM/Y2MwYiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9pbmRleC50cz9mZmI0Il0sIm5hbWVzIjpbImlzQ29tcG9uZW50SW5zdGFuY2UiLCJDbGFzcyIsImNvbXAiLCJDb21wb25lbnRDb2xsZWN0aW9uIiwiTWFwIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInNldCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNsIiwiZnVuYyIsImMiLCJnZXQiLCJ1cGRhdGVkQ29tcG9uZW50IiwiY1R5cGUiLCJkZWxldGUiLCJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwiY3QiLCJoYXMiLCJjTmFtZSIsImNvbXBvbmVudFR5cGVzIiwia2V5cyIsInNpemUiLCJ0b0RldkNvbXBvbmVudHMiLCJvYmoiLCJjb21wTmFtZSIsIkRldkVudGl0eSIsImVudGl0eSIsIndvcmxkIiwiaWQiLCJ0YWdzIiwic3RhdGUiLCJjb21wTmFtZXMiLCJPYmplY3QiLCJzeXN0ZW1OYW1lIiwiY05hbWVzIiwic3lzdGVtcyIsImNvbXBOYW1lc0J5U3lzdGVtTmFtZSIsImluY2x1ZGVzIiwicHVzaCIsInRvVGFibGVSb3ciLCJqb2luIiwiU2ltcGxlRlNNIiwiaW5pdGlhbFN0YXRlIiwidHJhbnNpdGlvbnMiLCJpbml0YWwiLCJjdXJyZW50IiwibmV4dCIsImRhdGEiLCJyZXNldCIsImlzIiwiY2hlY2tTdGF0ZSIsIkVudGl0eSIsIl9pZCIsIl93b3JsZCIsIl9zdGF0ZSIsInV1aWR2NCIsIl9lcnJvciIsImZzbVRyYW5zaXRpb24iLCJucyIsImNyZWF0aW5nIiwiY3JlYXRlZCIsImRlc3Ryb3lpbmciLCJkZXN0cm95ZWQiLCJlcnJvciIsInJlZ2lzdGVyRW50aXR5Iiwib25DcmVhdGUiLCJvbkRlc3Ryb3kiLCJvbkNvbXBvbmVudEFkZCIsImFyZ3MiLCJvblRyYWNrZWRDb21wb25lbnRVcGRhdGUiLCJvbkNvbXBvbmVudFJlbW92ZSIsImFkZCIsImFkZFRhZyIsInRhZyIsImVudGl0eVNldCIsImVudGl0aWVzQnlUYWdzIiwiU2V0IiwiY2MiLCJjb21wb25lbnRDb2xsZWN0aW9ucyIsImhhc1RhZyIsImdldEFsbCIsInJlbW92ZSIsInJlbW92ZVRhZyIsImNsZWFyIiwiY2xlYXJFbnRpdHlDb21wb25lbnRzIiwiY2xlYXJUYWdzIiwiZW50cmllcyIsImZpbmlzaENyZWF0aW9uIiwiZGVzdHJveSIsImRlc3Ryb3lJbW1lZGlhdGVseSIsImRlc3Ryb3lFbnRpdHkiLCJ0b0RldkVudGl0eSIsIkRldlRvb2xzIiwic3lzdGVtQ29tcG9uZW50cyIsImNvbXBzQnlTeXN0ZW1zIiwic3lzdGVtIiwiZW50aXRpZXMiLCJ2YWx1ZXMiLCJtYXAiLCJlIiwiU3lzdGVtcyIsInN5c3RlbUZ1bmNCeVN5c3RlbU5hbWUiLCJjVHlwZXMiLCJzeXN0ZW1GdW5jIiwiZnVuY05hbWUiLCJ0b1N0cmluZyIsInNsaWNlIiwiZW50aXRpZXNCeUNUeXBlcyIsInJ1biIsImVudGl0aWVzSW5DcmVhdGluZ1N0YXRlIiwiZW50aXRpZXNJbkRlc3Ryb3lpbmdTdGF0ZSIsImluZGV4IiwiY1R5cGVBcnJzIiwiZWlkIiwiaXNGaXJzdCIsImlzTGFzdCIsIlRyYWNrZWRDb21wU3ltYm9sS2V5cyIsImlzVHJhY2tlZCIsIlN5bWJvbCIsImZvciIsImVudGl0eUlEcyIsImdldEVudGl0aWVzIiwic2V0V29ybGQiLCJvbkFkZCIsIm9uVXBkYXRlIiwib25SZW1vdmUiLCJjcmVhdGVDbGFzc0luc3RhbmNlUHJveHlIYW5kbGVycyIsInRyYWNrZWRFdmVudEhhbmRsZXJzIiwidXBkYXRlZFByb3BzIiwicHJvcGVydHkiLCJ2YWx1ZSIsInByZXZpb3VzVmFsIiwidHJhY2tDb21wb25lbnQiLCJDb21wQ2xhc3MiLCJQcm94eSIsImNvbnN0cnVjdCIsIkNvbXBvbmVudCIsIldvcmxkIiwicHJlZGljYXRlIiwicmVzdWx0cyIsImxvY2F0ZSIsImxvY2F0ZUFsbCIsImRlZmF1bHRWYWx1ZSIsInJlc3VsdCIsImdyYWIiLCJ0YWdFbnRpdHlJZHMiLCJlbnRpdHlJZCIsImN0QXJyIiwiaGFzQnlOYW1lIiwiZGV2IiwiYWRkU3lzdGVtIiwiY3JlYXRlRW50aXR5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7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QjtBQUMzQnhFLGlCQUFTLENBQUMvRCxNQUFWLENBQWlCdUksUUFBakI7QUFDRDtBQUNGLEtBZDBDLENBZ0IzQzs7O0FBQ0EsU0FBSyxNQUFNLENBQUN6RSxHQUFELEVBQU1DLFNBQU4sQ0FBWCxJQUErQixLQUFLQyxjQUFwQyxFQUFvRDtBQUNsRCxVQUFJRCxTQUFTLENBQUN6RCxHQUFWLENBQWNpSSxRQUFkLENBQUosRUFBNkI7QUFDM0J4RSxpQkFBUyxDQUFDL0QsTUFBVixDQUFpQnVJLFFBQWpCO0FBQ0Q7O0FBRUQsVUFBSXhFLFNBQVMsQ0FBQ3JELElBQVYsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsYUFBS3NELGNBQUwsQ0FBb0JoRSxNQUFwQixDQUEyQjhELEdBQTNCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLElBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBN1krQixDOztBQ1YvQjtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbnZhciBnZXRSYW5kb21WYWx1ZXM7XG52YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyIsImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG52YXIgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIpIHtcbiAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHZhciB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyIsImV4cG9ydCBmdW5jdGlvbiBpc0NvbXBvbmVudEluc3RhbmNlPFQ+KFxuICBDbGFzczogbmV3ICguLi5hcmdzOiBhbnkpID0+IFQsXG4gIGNvbXA6IGFueVxuKTogY29tcCBpcyBJbnN0YW5jZVR5cGU8dHlwZW9mIENsYXNzPiB7XG4gIGlmICghY29tcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDbGFzcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCB7IGlzQ29tcG9uZW50SW5zdGFuY2UgfSBmcm9tIFwiLi9ndWFyZHNcIjtcblxudHlwZSBDb21wTmFtZSA9IHN0cmluZztcbnR5cGUgQ2xhc3NDb25zdHJ1Y3RvcjxUPiA9IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQgfTtcblxuLy8gQ1QgaXMgYSBVbmlvbiwgbGlrZSBgdHlwZSA9IEZpcnN0Q29tcG9uZW50IHwgU2Vjb25kQ29tcG9uZW50YC5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgY29tcG9uZW50czogTWFwPENvbXBOYW1lLCBDVD4gPSBuZXcgTWFwKCk7XG5cbiAgLy8gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnRcbiAgYWRkID0gKGNvbXBvbmVudDogQ1QpOiB2b2lkID0+IHtcbiAgICB0aGlzLmNvbXBvbmVudHMuc2V0KCg8YW55PmNvbXBvbmVudCkuY29uc3RydWN0b3IubmFtZSwgY29tcG9uZW50KTtcbiAgfTtcblxuICB1cGRhdGUgPSA8VCBleHRlbmRzIENUPihjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPiwgZnVuYzogKGM6IFQpID0+IFQpOiB2b2lkID0+IHtcbiAgICBjb25zdCBjID0gdGhpcy5jb21wb25lbnRzLmdldChjbC5uYW1lKTtcblxuICAgIGlmIChpc0NvbXBvbmVudEluc3RhbmNlKGNsLCBjKSkge1xuICAgICAgY29uc3QgdXBkYXRlZENvbXBvbmVudCA9IGZ1bmMoYyk7XG4gICAgICB0aGlzLmNvbXBvbmVudHMuc2V0KGNsLm5hbWUsIHVwZGF0ZWRDb21wb25lbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gY1R5cGUgQ2xhc3Mgb2YgY29tcG9uZW50IHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZSA9IChjVHlwZTogQ2xhc3NDb25zdHJ1Y3RvcjxDVD4pOiB2b2lkID0+IHtcbiAgICB0aGlzLmNvbXBvbmVudHMuZGVsZXRlKGNUeXBlLm5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBjb21wb25lbnQgdGhhdCBtYXRjaGVzIHRoZSBwYXNzZWQgY2xhc3MuXG4gICAqIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGNvbXBvbmVudFxuICAgKiBkb2Vzbid0IGV4aXN0IGluIHRoZSBjb2xsZWN0aW9uLCBzbyBpZiB5b3UgZG9uJ3Qga25vdyBpZiBpdCdzIHNhZmVcbiAgICogdG8gZ2V0IGEgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHRlc3Qgd2l0aCBoYXMoKSBvciBoYXNCeU5hbWUoKSBmaXJzdC5cbiAgICogWW91IGhhdmUgYmVlbiB3YXJuZWQuXG4gICAqIEBwYXJhbSBjbCBjb21wb25lbnQgQ2xhc3MgcmVmZXJlbmNlLlxuICAgKi9cbiAgZ2V0ID0gPFQgZXh0ZW5kcyBDVD4oY2w6IENsYXNzQ29uc3RydWN0b3I8VD4pOiBUID0+IHtcbiAgICBjb25zdCBjb21wID0gdGhpcy5jb21wb25lbnRzLmdldChjbC5uYW1lKTtcblxuICAgIGlmIChpc0NvbXBvbmVudEluc3RhbmNlPFQ+KGNsLCBjb21wKSkge1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvbXBvbmVudENvbGxlY3Rpb24gZG9lcyBub3QgaGF2ZSBjb21wb25lbnQgb2YgdHlwZSAke2NsLm5hbWV9YFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3QgdG8gc2VlIGlmIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5zIGEgc3BlY2lmaWMgQ2xhc3Mgb3IgQ2xhc3Nlcy5cbiAgICogQHBhcmFtIGNUeXBlIGNvbXBvbmVudCBDbGFzcywgb3IgYXJyYXkgb2YgY29tcG9uZW50IENsYXNzZXMuXG4gICAqL1xuICBoYXMgPSAoY1R5cGU6IENsYXNzQ29uc3RydWN0b3I8Q1Q+IHwgQ2xhc3NDb25zdHJ1Y3RvcjxDVD5bXSk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNUeXBlKVxuICAgICAgPyBjVHlwZS5ldmVyeSgoY3QpID0+IHRoaXMuY29tcG9uZW50cy5oYXMoY3QubmFtZSkgPT09IHRydWUpXG4gICAgICA6IHRoaXMuY29tcG9uZW50cy5oYXMoY1R5cGUubmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3QgdG8gc2VlIGlmIHRoZSBjb2xsZWN0aW9uIGhhcyBhIGNvbXBvbmVudCBpbnN0YW5jZSBiYXNlZCBvbiBhXG4gICAqIGNsYXNzIG5hbWUuIFNvbWUgYnVpbGQgc3RlcHMvbWluaWZpZXJzIHdpbGwgY2hhbmdlIHRoZSBuYW1lIG9mIENsYXNzZXMsXG4gICAqIHNvIGl0J3MgdXN1YWxseSBiZXN0IHRvIHBhc3MgaW4gYSBNeUNsYXNzLm5hbWUgaW5zdGVhZCBvZiAnTXlDbGFzcycuXG4gICAqIEBwYXJhbSBjTmFtZSBUaGUgbmFtZSBvZiBhIENsYXNzLCBvciBhcnJheSBvZiBDbGFzcyBuYW1lcy5cbiAgICovXG4gIGhhc0J5TmFtZSA9IChjTmFtZTogc3RyaW5nIHwgc3RyaW5nW10pOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjTmFtZSlcbiAgICAgID8gY05hbWUuZXZlcnkoKGN0KSA9PiB0aGlzLmNvbXBvbmVudHMuaGFzKGN0KSA9PT0gdHJ1ZSlcbiAgICAgIDogdGhpcy5jb21wb25lbnRzLmhhcyhjTmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcG9uZW50IHR5cGUgbmFtZXMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIHVzZWQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqL1xuICBnZXQgY29tcG9uZW50VHlwZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5jb21wb25lbnRzLmtleXMoKV07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG51bWJlciBvZiBjb21wb25lbnRzIHRoYXQgYXJlIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzLnNpemU7XG4gIH1cblxuICB0b0RldkNvbXBvbmVudHMoKTogUmVjb3JkPHN0cmluZywgQ1Q+IHtcbiAgICBjb25zdCBvYmo6IFJlY29yZDxzdHJpbmcsIENUPiA9IHt9O1xuICAgIGZvciAoY29uc3QgW2NvbXBOYW1lLCBjb21wXSBvZiB0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgIG9ialtjb21wTmFtZV0gPSBjb21wO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cbn1cbiIsImltcG9ydCBXb3JsZCBmcm9tIFwiLi9Xb3JsZFwiO1xuaW1wb3J0IEVudGl0eSBmcm9tIFwiLi9FbnRpdHlcIjtcbmltcG9ydCB7IFRhZyB9IGZyb20gXCIuL1RhZ1wiO1xuaW1wb3J0IHsgRW50aXR5U3RhdGUgfSBmcm9tIFwiZWNzdGF0aWNcIjtcblxuaW50ZXJmYWNlIERldkVudGl0eVRhYmxlUm93IHtcbiAgaWQ6IHN0cmluZztcbiAgY29tcG9uZW50czogc3RyaW5nO1xuICB0YWdzOiBzdHJpbmc7XG4gIHN5c3RlbXM6IHN0cmluZztcbn1cblxuY2xhc3MgRGV2RW50aXR5PENUPiB7XG4gIGlkOiBzdHJpbmc7XG5cbiAgY29tcG9uZW50czogUmVjb3JkPHN0cmluZywgQ1Q+O1xuXG4gIHRhZ3M6IFRhZ1tdO1xuXG4gIHN5c3RlbXM6IHN0cmluZ1tdID0gW107XG5cbiAgc3RhdGU6IEVudGl0eVN0YXRlO1xuXG4gIGNvbnN0cnVjdG9yKGVudGl0eTogRW50aXR5PENUPiwgd29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMuaWQgPSBlbnRpdHkuaWQ7XG4gICAgdGhpcy5jb21wb25lbnRzID0gZW50aXR5LmNvbXBvbmVudHMudG9EZXZDb21wb25lbnRzKCksXG4gICAgdGhpcy50YWdzID0gWy4uLmVudGl0eS50YWdzXTtcbiAgICB0aGlzLnN0YXRlID0gZW50aXR5LnN0YXRlO1xuXG4gICAgY29uc3QgY29tcE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRzKTtcblxuICAgIGZvciAoY29uc3QgW3N5c3RlbU5hbWUsIGNOYW1lc10gb2Ygd29ybGQuc3lzdGVtcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUpIHtcbiAgICAgIGlmIChjTmFtZXMuZXZlcnkoKGNOYW1lKSA9PiBjb21wTmFtZXMuaW5jbHVkZXMoY05hbWUpKSkge1xuICAgICAgICB0aGlzLnN5c3RlbXMucHVzaChzeXN0ZW1OYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b1RhYmxlUm93KCk6IERldkVudGl0eVRhYmxlUm93IHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBjb21wb25lbnRzOiBPYmplY3Qua2V5cyh0aGlzLmNvbXBvbmVudHMpLmpvaW4oXCIsIFwiKSxcbiAgICAgIHRhZ3M6IHRoaXMudGFncy5qb2luKFwiLCBcIiksXG4gICAgICBzeXN0ZW1zOiB0aGlzLnN5c3RlbXMuam9pbignLCAnKSxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERldkVudGl0eTtcbiIsImV4cG9ydCB0eXBlIFN0YXRlID0gc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sO1xuXG5leHBvcnQgdHlwZSBUcmFuc2l0aW9uczxTIGV4dGVuZHMgU3RhdGUsIEQgPSB1bmRlZmluZWQ+ID0gUmVjb3JkPFxuICBTLFxuICAoZGF0YTogRCwgY3VycmVudDogUykgPT4gU1xuPjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltcGxlRlNNPFMgZXh0ZW5kcyBTdGF0ZSwgRCA9IHVuZGVmaW5lZD4ge1xuICBjdXJyZW50OiBTO1xuXG4gIGluaXRhbDogUztcblxuICB0cmFuc2l0aW9uczogVHJhbnNpdGlvbnM8UywgRD47XG5cbiAgY29uc3RydWN0b3IoaW5pdGlhbFN0YXRlOiBTLCB0cmFuc2l0aW9uczogVHJhbnNpdGlvbnM8UywgRD4pIHtcbiAgICB0aGlzLmluaXRhbCA9IGluaXRpYWxTdGF0ZTtcbiAgICB0aGlzLmN1cnJlbnQgPSBpbml0aWFsU3RhdGU7XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuICB9XG5cbiAgbmV4dChkYXRhOiBEKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbnNbdGhpcy5jdXJyZW50XSkge1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy50cmFuc2l0aW9uc1t0aGlzLmN1cnJlbnRdKGRhdGEsIHRoaXMuY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5pbml0YWw7XG4gIH1cblxuICBpcyhjaGVja1N0YXRlOiBTKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudCA9PT0gY2hlY2tTdGF0ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSBcInV1aWRcIjtcbmltcG9ydCBXb3JsZCwgeyBDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSBcIi4vV29ybGRcIjtcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gXCIuL0NvbXBvbmVudENvbGxlY3Rpb25cIjtcbmltcG9ydCB7IFRhZyB9IGZyb20gXCIuL1RhZ1wiO1xuaW1wb3J0IERldkVudGl0eSBmcm9tIFwiLi9EZXZFbnRpdHlcIjtcblxuaW1wb3J0IFNpbXBsZUZTTSBmcm9tIFwiLi9TaW1wbGVGU01cIjtcblxuZXhwb3J0IHR5cGUgRW50aXR5SWQgPSBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIEVudGl0eVN0YXRlID1cbiAgfCBcImNyZWF0aW5nXCJcbiAgfCBcImNyZWF0ZWRcIlxuICB8IFwiZGVzdHJveWluZ1wiXG4gIHwgXCJkZXN0cm95ZWRcIlxuICB8IFwiZXJyb3JcIjtcblxuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlDb21wRXZlbnRBcmdzPENUPiB7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG4gIGNvbXBvbmVudDogQ1Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudGl0eTxDVD4ge1xuICBwcml2YXRlIF9pZDogc3RyaW5nO1xuICBwcml2YXRlIF93b3JsZDogV29ybGQ8Q1Q+O1xuXG4gIHByaXZhdGUgX2Vycm9yOiBFcnJvciB8IG51bGw7XG5cbiAgcHJpdmF0ZSBfc3RhdGU6IFNpbXBsZUZTTTxFbnRpdHlTdGF0ZSwgRW50aXR5U3RhdGU+O1xuXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuXG4gIGdldCB3b3JsZCgpOiBXb3JsZDxDVD4ge1xuICAgIHJldHVybiB0aGlzLl93b3JsZDtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpOiBFbnRpdHlTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmN1cnJlbnQ7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih3b3JsZDogV29ybGQ8Q1Q+KSB7XG4gICAgdGhpcy5faWQgPSB1dWlkdjQoKTtcbiAgICB0aGlzLl93b3JsZCA9IHdvcmxkO1xuXG4gICAgdGhpcy5fZXJyb3IgPSBudWxsO1xuXG4gICAgY29uc3QgZnNtVHJhbnNpdGlvbiA9IChcbiAgICAgIG5zOiBFbnRpdHlTdGF0ZVxuICAgICk6IEVudGl0eVN0YXRlID0+IHtcbiAgICAgIGlmIChucyA9PT0gXCJlcnJvclwiIHx8IHRoaXMuX2Vycm9yKSByZXR1cm4gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIG5zO1xuICAgIH07XG5cbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBTaW1wbGVGU008RW50aXR5U3RhdGUsIEVudGl0eVN0YXRlPihcImNyZWF0aW5nXCIsIHtcbiAgICAgIGNyZWF0aW5nOiBmc21UcmFuc2l0aW9uLFxuICAgICAgY3JlYXRlZDogZnNtVHJhbnNpdGlvbixcbiAgICAgIGRlc3Ryb3lpbmc6IGZzbVRyYW5zaXRpb24sXG4gICAgICBkZXN0cm95ZWQ6ICgpID0+IFwiZGVzdHJveWVkXCIsXG4gICAgICBlcnJvcjogKCkgPT4gXCJlcnJvclwiLFxuICAgIH0pO1xuXG4gICAgLypcbiAgICBSZWdpc3RlcmluZyB3aXRoIHRoZSBXb3JsZC5cbiAgICAqL1xuICAgIHRoaXMuX3dvcmxkLnJlZ2lzdGVyRW50aXR5KHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX3dvcmxkLnN5c3RlbXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuX3N0YXRlLm5leHQoJ2NyZWF0ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKiBMaWZlQ3ljbGUgbWV0aG9kcywgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiAqL1xuXG4gIG9uQ3JlYXRlKHdvcmxkOiBXb3JsZDxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25EZXN0cm95KHdvcmxkOiBXb3JsZDxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25Db21wb25lbnRBZGQoYXJnczogRW50aXR5Q29tcEV2ZW50QXJnczxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25UcmFja2VkQ29tcG9uZW50VXBkYXRlKGFyZ3M6IEVudGl0eUNvbXBFdmVudEFyZ3M8Q1Q+KTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIG9uQ29tcG9uZW50UmVtb3ZlKGFyZ3M6IEVudGl0eUNvbXBFdmVudEFyZ3M8Q1Q+KTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBjb21wb25lbnQgdG8gYW4gRW50aXR5LCBkb2guXG4gICAqL1xuICBhZGQ8VCBleHRlbmRzIENUPihjb21wb25lbnQ6IFQpOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5hZGQodGhpcy5faWQsIGNvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0YWcgdG8gYSBjb21wb25lbnRcbiAgICovXG4gIGFkZFRhZyh0YWc6IFRhZyk6IHRoaXMge1xuICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmhhcyh0YWcpXG4gICAgICA/IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpXG4gICAgICA6IG5ldyBTZXQ8RW50aXR5SWQ+KCk7XG5cbiAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICBlbnRpdHlTZXQuYWRkKHRoaXMuX2lkKTtcbiAgICAgIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLnNldCh0YWcsIGVudGl0eVNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhbiBlbnRpdHkgaGFzIGEgY29tcG9uZW50IHJlbGF0ZWQgdG8gaXQuXG4gICAqL1xuICBoYXM8VCBleHRlbmRzIENUPihjVHlwZTogQ2xhc3NDb25zdHJ1Y3RvcjxUPik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHxcbiAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgcmV0dXJuIGNjLmhhcyhjVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIGFuIGVudGl0eSB0YWdnZWQgd2l0aCBhIGdpdmVuIHRhZy5cbiAgICovXG4gIGhhc1RhZyh0YWc6IFRhZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5oYXModGFnKSkge1xuICAgICAgY29uc3QgZW50aXR5U2V0ID0gdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZyk7XG4gICAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICAgIHJldHVybiBlbnRpdHlTZXQuaGFzKHRoaXMuX2lkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgY29tcG9uZW50IHRoYXQgYmVsb25ncyB0byBhbiBlbnRpdHkuXG4gICAqL1xuICBnZXQ8VCBleHRlbmRzIENUPihjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPik6IFQge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHxcbiAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvblxuICAgKi9cbiAgZ2V0QWxsKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNvbXBvbmVudCBmcm9tIGFuIGVudGl0eS5cbiAgICogQHBhcmFtIGNUeXBlIEEgY29tcG9uZW50IGNsYXNzLCBlZyBNeUNvbXBvbmVudFxuICAgKi9cbiAgcmVtb3ZlKGNUeXBlOiBDbGFzc0NvbnN0cnVjdG9yPENUPik6IHRoaXMge1xuICAgIHRoaXMuX3dvcmxkLnJlbW92ZSh0aGlzLl9pZCwgY1R5cGUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdGFnIGZyb20gYW4gZW50aXR5XG4gICAqL1xuICByZW1vdmVUYWcodGFnOiBUYWcpOiB0aGlzIHtcbiAgICBpZiAodGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuaGFzKHRhZykpIHtcbiAgICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICAgIGlmIChlbnRpdHlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENsZWFycyBhbGwgY29tcG9uZW50cyBmcm9tIGFuIEVudGl0eSAqL1xuICBjbGVhcigpOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5jbGVhckVudGl0eUNvbXBvbmVudHModGhpcy5faWQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0YWdzIG9uIGFuIGVudGl0eVxuICAgKi9cbiAgY2xlYXJUYWdzKCk6IHRoaXMge1xuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5lbnRyaWVzKCkpIHtcbiAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICBpZiAoZW50aXR5U2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGVudGl0eSB0byAnY3JlYXRlZCcuIHRoYXQncyBpdC5cbiAgICovXG4gIGZpbmlzaENyZWF0aW9uKCk6IHZvaWQge1xuICAgIHRoaXMuX3N0YXRlLm5leHQoJ2NyZWF0ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IGFuIGVudGl0eS4gQWN0dWFsIGRlc3RydWN0aW9uIGlzIGRlZmVycmVkIHVudGlsIGFmdGVyIHRoZSBuZXh0IHBhc3Mgb2Ygc3lzdGVtcy5cbiAgICogVGhpcyBnaXZlcyB0aGUgc3lzdGVtcyBhIGNoYW5jZSB0byBkbyBhbnkgY2xlYW51cCB0aGF0IG1pZ2h0IGJlIG5lZWRlZC5cbiAgICovXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gSWYgbm8gc3lzdGVtcyBhcmUgYWRkZWQsIHRoZSBkZXN0cm95IGltbWVkaWF0ZWx5LlxuICAgIGlmICh0aGlzLl93b3JsZC5zeXN0ZW1zLmNvbXBOYW1lc0J5U3lzdGVtTmFtZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lJbW1lZGlhdGVseSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1hcmsgYXMgXCJkZXN0cm95aW5nXCIgc28gdGhhdCBzeXN0ZW1zIGNhbiBhY3Qgb24gaXQgYmVmb3JlIGFjdHVhbGx5IGJlaW5nIGRlc3Ryb3llZC5cbiAgICB0aGlzLl9zdGF0ZS5uZXh0KCdkZXN0cm95aW5nJyk7XG4gIH1cblxuICBkZXN0cm95SW1tZWRpYXRlbHkoKTogdm9pZCB7XG4gICAgLy8gUmlnaHQgbm93IGNhbGxpbmcgYmVmb3JlIHRoZSBhY3R1YWwgZGVzdG9yeWluZyBvZiB0aGUgZW50aXR5LlxuICAgIC8vIE1pZ2h0IHdhbnQgdG8gY2hhbmdlIHRoaXMgdG8gcG9zdCBkZXN0cnVjdGlvbiBpbiB0aGUgZnV0dXJlLCB3aG8ga25vd3MuXG4gICAgdGhpcy5vbkRlc3Ryb3kodGhpcy5fd29ybGQpO1xuXG4gICAgLy8gQWN0dWFsbHkgZGVzdHJveSBlbnRpdHkuXG4gICAgdGhpcy5fd29ybGQuZGVzdHJveUVudGl0eSh0aGlzLl9pZCk7IC8vIHNob3VsZCByZXR1cm4gYW4gZXJyb3I/P1xuXG4gICAgdGhpcy5fc3RhdGUubmV4dCgnZGVzdHJveWVkJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvbi5cbiAgICogRG9lcyB0aGUgc2FtZSB0aGluZyBhcyBlbnRpdHlJbnN0YW5jZS5nZXRBbGwoKS5cbiAgICovXG4gIGdldCBjb21wb25lbnRzKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgdGhlIHRhZ3MgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhpcyBlbnRpdHkuXG4gICAqL1xuICBnZXQgdGFncygpOiBTZXQ8VGFnPiB7XG4gICAgY29uc3QgdGFncyA9IG5ldyBTZXQ8VGFnPigpO1xuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKHRoaXMuX2lkKSkge1xuICAgICAgICB0YWdzLmFkZCh0YWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YWdzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgRW50aXR5IHRvIGEgRGV2RW50aXR5LiBWZXJ5IGhlbHBmdWwgaW4gZm9yIGRlYnVnZ2luZy5cbiAgICovXG4gIHRvRGV2RW50aXR5KCk6IERldkVudGl0eTxDVD4ge1xuICAgIHJldHVybiBuZXcgRGV2RW50aXR5PENUPih0aGlzLCB0aGlzLl93b3JsZCk7XG4gIH1cbn1cbiIsImltcG9ydCBXb3JsZCBmcm9tICcuL1dvcmxkJztcbmltcG9ydCBEZXZFbnRpdHkgZnJvbSAnLi9EZXZFbnRpdHknO1xuXG5pbnRlcmZhY2UgRGV2U3lzdGVtQ29tcHMge1xuICBzeXN0ZW06IHN0cmluZztcbiAgY29tcG9uZW50czogc3RyaW5nO1xufVxuXG5cbmNsYXNzIERldlRvb2xzPENUPiB7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgfVxuICAvKipcbiAgICogZGlzcGxheSB0aGUgYWxsIHN5c3RlbXMgb2YgdGhlIHdvcmxkLCBhbmQgdGhlIGNvbXBvbmVudHMgcmVxdWlyZWQgYnkgZWFjaCBzeXN0ZW0uXG4gICAqIFN1cGVyIGhlbHBmdWwgdG8gdXNlIHdpdGggY29uc29sZS50YWJsZSgpXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zb2xlLnRhYmxlKHdvcmxkLmRldi5zeXN0ZW1Db21wb25lbnRzKTtcbiAgICogYGBgXG4gICAqL1xuICBnZXQgc3lzdGVtQ29tcG9uZW50cygpOiBEZXZTeXN0ZW1Db21wc1tdIHtcbiAgICBjb25zdCBjb21wc0J5U3lzdGVtcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBbc3lzdGVtLCBjb21wTmFtZXNdIG9mIHRoaXMud29ybGQuc3lzdGVtcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUpIHtcbiAgICAgIGNvbXBzQnlTeXN0ZW1zLnB1c2goeyBzeXN0ZW0sIGNvbXBvbmVudHM6IGNvbXBOYW1lcy5qb2luKFwiLCBcIikgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBzQnlTeXN0ZW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhcnJheSBvZiBEZXZFbnRpdGVzLiBDYW4gYmUgdmVyeSBoZWxwZnVsIGZvciB0aGluZ3MgbGlrZSBpbnNwZWN0aW5nIGNvbXBvbmVudCBzdGF0ZSxcbiAgICogYW5kIHdoaWNoIHN5c3RlbXMgd2lsbCBiZSBjYWxsZWQgb24gYW4gZW50aXR5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMpO1xuICAgKlxuICAgKiAvLyBQcm8gdGlwISB0cnkgZGlzcGxheWluZyBhIHRhYmxlIG9mIGVudGl0aWVzIHdpdGggY29uc29sZS50YWJsZSBhbmQgRGV2RW50aXR5LnRvVGFibGVSb3coKS5cbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMubWFwKGRldkVudGl0eSA9PiBkZXZFbnRpdHkudG9UYWJsZVJvdygpKSk7XG4gICAqIGBgYFxuICAgKi9cblxuICBnZXQgZW50aXRpZXMoKTogRGV2RW50aXR5PENUPltdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMud29ybGQuZW50aXRpZXMudmFsdWVzKCldLm1hcCgoZSkgPT4gZS50b0RldkVudGl0eSgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZXZUb29scztcbiIsImltcG9ydCBFbnRpdHksIHsgRW50aXR5SWQgfSBmcm9tIFwiLi9FbnRpdHlcIjtcbmltcG9ydCBXb3JsZCwgeyBDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSBcIi4vV29ybGRcIjtcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gXCIuL0NvbXBvbmVudENvbGxlY3Rpb25cIjtcblxuLyoqXG4gKiBBcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIGludG8gYSBTeXN0ZW0gZnVuY3Rpb24gb24gZWFjaCBpdGVyYXRpb24uXG4gKiBUaGlzIGlzIGhvdyB5b3UgYWNjZXMgdGhpbmdzIGxpa2UgdGhlIGVudGl0eSB0aGF0IHBhcnRpY3VsYXIgZW50aXR5IHRvIGFjdCBvbixcbiAqIGFzIHdlbGwgYXMgc29tZSBvdGhlciBoZWxwZnVsIHBhcmFtcyBsaWtlIGlmIHRoZSBlbnRpdHkgaXMgdGhlIGZpcnN0IG9yIGxhc3QgZW50aXR5XG4gKiBpbiB0aGUgZ3JvdXAgb2YgZW50aXRpZXMgdGhhdCBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5c3RlbUZ1bmNBcmdzPENUPiB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBlbnRpdHkgYmVpbmcgaXRlcmF0ZWQuXG4gICAqL1xuICBlbnRpdHk6IEVudGl0eTxDVD47XG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB0aGF0IGJlbG9uZyB0byB0aGUgZW50aXR5XG4gICAqL1xuICBjb21wb25lbnRzOiBDb21wb25lbnRDb2xsZWN0aW9uPENUPjtcbiAgLyoqXG4gICAqIFRoZSBXb3JsZCBpbnN0YW5jZS5cbiAgICogVXNlIHRoaXMgdG8gYWNjZXNzIG90aGVyIGVudGl0aWVzLlxuICAgKi9cbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICAvKipcbiAgICogSXMgdGhlIGZpcnN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogSGVscGZ1bCBmb3Igc2V0dGluZyB1cCBzdGF0ZSB0aGF0IGlzIHRoZSBzYW1lIGZvciBhbGwgZW50aXRpZXMgb25seSBvbmNlLlxuICAgKi9cbiAgaXNGaXJzdDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIElzIHRoZSBsYXN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogQ2FuIGJlIGhlbHBmdWwgdG8gdGVhciBkb3duIGFueXRoaW5nIHRoYXQgc2hvdWxkIGJlIGRlYWx0IHdpdGggYWZ0ZXIgYWxsIHRoZSBlbnRpdGVzIGhhdmUgcmFuLlxuICAgKi9cbiAgaXNMYXN0OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBzeXN0ZW0gaXMgcnVuLlxuICovXG5leHBvcnQgdHlwZSBTeXN0ZW1GdW5jPENUPiA9IChzeXRlbUZ1bmNBcmdzOiBTeXN0ZW1GdW5jQXJnczxDVD4pID0+IHZvaWQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbXM8Q1Q+IHtcbiAgd29ybGQ6IFdvcmxkPENUPjtcblxuICBzeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lOiBNYXA8c3RyaW5nLCBTeXN0ZW1GdW5jPENUPj47IC8vIGRvdWJsZSBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBtYXBzIGFyZSBvcmRlcmVkLlxuXG4gIGNvbXBOYW1lc0J5U3lzdGVtTmFtZTogTWFwPHN0cmluZywgc3RyaW5nW10+O1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZDxDVD4pIHtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5zeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgYWRkKFxuICAgIGNUeXBlczogQ2xhc3NDb25zdHJ1Y3RvcjxDVD5bXSxcbiAgICBzeXN0ZW1GdW5jOiBTeXN0ZW1GdW5jPENUPixcbiAgICBmdW5jTmFtZT86IHN0cmluZ1xuICApOiB0aGlzIHtcbiAgICBjb25zdCBjTmFtZXMgPSBjVHlwZXMubWFwKChjdCkgPT4gY3QubmFtZSk7XG5cbiAgICBsZXQgbmFtZSA9IHN5c3RlbUZ1bmMubmFtZTtcbiAgICBpZiAoc3lzdGVtRnVuYy5uYW1lID09PSBcIlwiKSB7XG4gICAgICAvLyBTdXBlciBicnV0ZSBmb3JjZSwgYW5kIG1pZ2h0IGxlYWQgdG8gZXJyb3JzIGluIHRoZSBmdXR1cmUsIGJ1dCBmb3Igbm93XG4gICAgICAvLyB1c2luZyB0aGUgc3RyaW5naWZpZWQgc3lzdGVtIGZ1bmN0aW9uIGlmIHRoZSBmdW5jdGlvbiBkb2Vzbid0IGFscmVhZHkgaGF2ZSBhIG5hbWUuXG4gICAgICAvLyBUaGlzIGlzIHVzZWZ1bCBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB1c2VkIGFzIGEgc3lzdGVtIGZ1bmN0aW9uLlxuICAgICAgLy8gTWlnaHQgYmUgZ29vZCB0byBmaWd1cmUgb3V0IGhvdyB0byBnZXQgYSBoYXNoIG9mIHRoZSBmdW5jdGlvbiBzdHJpbmcuXG4gICAgICBuYW1lID0gc3lzdGVtRnVuYy50b1N0cmluZygpLnNsaWNlKDAsIDMwKTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY05hbWUpIHtcbiAgICAgIG5hbWUgPSBmdW5jTmFtZTtcbiAgICB9XG5cbiAgICB0aGlzLnN5c3RlbUZ1bmNCeVN5c3RlbU5hbWUuc2V0KG5hbWUsIHN5c3RlbUZ1bmMpO1xuICAgIHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lLnNldChuYW1lLCBjTmFtZXMpO1xuICAgIHRoaXMud29ybGQuZW50aXRpZXNCeUNUeXBlcy5zZXQoY05hbWVzLCBuZXcgU2V0PEVudGl0eUlkPigpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcnVuKCk6IHZvaWQge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLndvcmxkLmVudGl0aWVzQnlDVHlwZXMuc2l6ZTtcbiAgICBcbiAgICBjb25zdCBlbnRpdGllc0luQ3JlYXRpbmdTdGF0ZSA9IFtdO1xuICAgIGNvbnN0IGVudGl0aWVzSW5EZXN0cm95aW5nU3RhdGUgPSBbXTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMud29ybGQuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHkuc3RhdGUgPT09IFwiY3JlYXRpbmdcIikge1xuICAgICAgICBlbnRpdGllc0luQ3JlYXRpbmdTdGF0ZS5wdXNoKGVudGl0eSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRpdHkuc3RhdGUgPT09IFwiZGVzdHJveWluZ1wiKSB7XG4gICAgICAgIGVudGl0aWVzSW5EZXN0cm95aW5nU3RhdGUucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgW1xuICAgICAgZnVuY05hbWUsXG4gICAgICBzeXN0ZW1GdW5jLFxuICAgIF0gb2YgdGhpcy5zeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lLmVudHJpZXMoKSkge1xuICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgIGNvbnN0IGNOYW1lcyA9IHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lLmdldChmdW5jTmFtZSkgfHwgW107XG4gICAgICBjb25zdCBjVHlwZUFycnMgPSB0aGlzLndvcmxkLmVudGl0aWVzQnlDVHlwZXMuZ2V0KGNOYW1lcykgfHwgbmV3IFNldCgpO1xuXG4gICAgICBmb3IgKGNvbnN0IGVpZCBvZiBjVHlwZUFycnMpIHtcbiAgICAgICAgY29uc3QgYXJnczogU3lzdGVtRnVuY0FyZ3M8Q1Q+ID0ge1xuICAgICAgICAgIGVudGl0eTogdGhpcy53b3JsZC5lbnRpdGllcy5nZXQoZWlkKSB8fCBuZXcgRW50aXR5PENUPih0aGlzLndvcmxkKSxcbiAgICAgICAgICBjb21wb25lbnRzOlxuICAgICAgICAgICAgdGhpcy53b3JsZC5jb21wb25lbnRDb2xsZWN0aW9ucy5nZXQoZWlkKSB8fFxuICAgICAgICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCksXG4gICAgICAgICAgd29ybGQ6IHRoaXMud29ybGQsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBpc0ZpcnN0OiBpbmRleCA9PT0gMCxcbiAgICAgICAgICBpc0xhc3Q6IGluZGV4ICsgMSA9PT0gc2l6ZSxcbiAgICAgICAgfTtcblxuICAgICAgICBzeXN0ZW1GdW5jKGFyZ3MpO1xuXG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllc0luQ3JlYXRpbmdTdGF0ZSkge1xuICAgICAgZW50aXR5LmZpbmlzaENyZWF0aW9uKCk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXNJbkRlc3Ryb3lpbmdTdGF0ZSkge1xuICAgICAgZW50aXR5LmRlc3Ryb3lJbW1lZGlhdGVseSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgVE9ETzogTmljZSB0byBoYXZlIG9wdGlvbnMgaGVyZTpcbiAgICAgIC0gc3lzdGVtcy5hY3RpdmVTeXN0ZW1zID0gbmV3IFNldCgpOyAvLyBpZiBub3QgaW4gc2V0LCBzeXN0ZW0gZG9lc24ndCBydW4uXG4gICAgICAtIHN5c3RlbXMuZGVhY3RpdmF0ZVN5c3RlbSgnc3lzdGVtTmFtZScpIC8vIHJlbW92ZSBzeXN0ZW0gZnJvbSBhY3RpdmVTeXN0ZW1zXG4gICAgICAtIHN5c3RlbXMuYWN0aXZhdGVTeXN0ZW0oJ3N5c3RlbU5hbWUpIC8vIGFkZHMgc3lzdGVtIGJhY2sgdG8gYWN0aXZlU3lzdGVtc1xuICAgICAgLSBzeXN0ZW1zLnBhdXNlKCkgLy8gcGF1c2VzIHJ1bm5pbmcgb2Ygc3lzdGVtcy4gYmFzaWNhbGx5IHJldHVybiBpbW1lZGlhdGVseSBvbiBydW4oKS5cbiAgICAgIC0gc3lzdGVtcy5yZXN1bWUoKSAvLyByZXN1bWUgcnVubmluZyBvZiBzeXN0ZW1zLlxuICAqL1xufVxuIiwiaW1wb3J0IFdvcmxkLCB7IENsYXNzQ29uc3RydWN0b3IgfSBmcm9tIFwiLi9Xb3JsZFwiO1xuaW1wb3J0IEVudGl0eSwgeyBFbnRpdHlJZCB9IGZyb20gXCIuL0VudGl0eVwiO1xuXG4vLyBXYWl0aW5nIGZvciBUeXBlc2NyaXB0IDQuMiB0byBjb21lIG91dCBzbyB0aGF0IFN5bWJvbHMgYXJlIHN1cHBvcmRlZCBrZXlzLlxuZXhwb3J0IGNvbnN0IFRyYWNrZWRDb21wU3ltYm9sS2V5cyA9IHtcbiAgaXNUcmFja2VkOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQuaXNUcmFja2VkXCIpLFxuICB3b3JsZDogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50LndvcmxkXCIpLFxuICBlbnRpdHlJRHM6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5lbnRpdHlJRHNcIiksXG4gIGdldEVudGl0aWVzOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQuZ2V0RW50aXRpZXNcIiksXG4gIHNldFdvcmxkOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQuc2V0V29ybGRcIiksXG4gIG9uQWRkOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQub25BZGRcIiksXG4gIG9uVXBkYXRlOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQub25VcGRhdGVcIiksXG4gIG9uUmVtb3ZlOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQub25SZW1vdmVcIiksXG59IGFzIGNvbnN0O1xuXG4vL0B0cy1pZ25vcmVcbnR5cGUgVHJhY2tlZENvbXBvbmVudDxDVD4gPSB7XG4gIG5ldyAoLi4uYXJnczogYW55W10pOiBDVDtcblxuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy5pc1RyYWNrZWRdOiBib29sZWFuO1xuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy5zZXRXb3JsZF06ICh3b3JsZDogV29ybGQ8Q1Q+KSA9PiB2b2lkO1xuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy53b3JsZF06IFdvcmxkPENUPjtcbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMuZW50aXR5SURzXTogU2V0PEVudGl0eUlkPjtcbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMuZ2V0RW50aXRpZXNdOiAoKSA9PiBNYXA8RW50aXR5SWQsIEVudGl0eTxDVD4+O1xuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vbkFkZF06IChcbiAgICB3b3JsZDogV29ybGQ8Q1Q+LFxuICAgIGVudGl0eTogRW50aXR5PENUPlxuICApID0+IHZvaWQ7XG4gIC8vQHRzLWlnbm9yZVxuICBbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uUmVtb3ZlXTogKFxuICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgZW50aXR5OiBFbnRpdHk8Q1Q+XG4gICkgPT4gdm9pZDtcbn07XG5cbmludGVyZmFjZSBBZGRFdmVudEFyZ3M8Q1Q+IHtcbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgY29tcG9uZW50OiBDVDtcbiAgZW50aXR5OiBFbnRpdHk8Q1Q+O1xuICBlbnRpdGllczogTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+Pjtcbn1cblxuaW50ZXJmYWNlIFVwZGF0ZUV2ZW50QXJnczxDVD4ge1xuICBlbnRpdGllczogTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+PjtcbiAgY29tcG9uZW50OiBDVDtcbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgcHJldmlvdXNWYWw6IENUW2tleW9mIENUXTtcbiAgcHJvcGVydHk6IGtleW9mIENUO1xufVxuXG5pbnRlcmZhY2UgUmVtb3ZlRXZlbnRBcmdzPENUPiB7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG4gIGNvbXBvbmVudDogQ1Q7XG4gIGVudGl0eTogRW50aXR5PENUPjtcbiAgZW50aXRpZXM6IE1hcDxFbnRpdHlJZCwgRW50aXR5PENUPj47XG59XG5cbmludGVyZmFjZSBUcmFja2VkRXZlbnRIYW5kbGVyczxDVD4ge1xuICBvbkFkZD86IChhcmdzOiBBZGRFdmVudEFyZ3M8Q1Q+KSA9PiB2b2lkO1xuICBvblVwZGF0ZT86IChhcmdzOiBVcGRhdGVFdmVudEFyZ3M8Q1Q+KSA9PiB2b2lkO1xuICBvblJlbW92ZT86IChhcmdzOiBSZW1vdmVFdmVudEFyZ3M8Q1Q+KSA9PiB2b2lkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0luc3RhbmNlUHJveHlIYW5kbGVyczxDVD4oXG4gIHRyYWNrZWRFdmVudEhhbmRsZXJzOiBUcmFja2VkRXZlbnRIYW5kbGVyczxDVD5cbik6IFByb3h5SGFuZGxlcjxhbnk+IHtcbiAgY29uc3QgdXBkYXRlZFByb3BzID0gbmV3IFNldCgpO1xuICByZXR1cm4ge1xuICAgIHNldChcbiAgICAgIGNvbXBvbmVudDogQ1QsXG4gICAgICBwcm9wZXJ0eToga2V5b2YgQ1QsXG4gICAgICB2YWx1ZTogQ1Rba2V5b2YgQ1RdXG4gICAgKSB7XG4gICAgICB1cGRhdGVkUHJvcHMuYWRkKHByb3BlcnR5KTtcblxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb25zdCB3b3JsZCA9IGNvbXBvbmVudFtcbiAgICAgICAgVHJhY2tlZENvbXBTeW1ib2xLZXlzLndvcmxkXG4gICAgICBdIGFzIFdvcmxkPENUPjtcblxuICAgICAgY29uc3QgcHJldmlvdXNWYWwgPSBjb21wb25lbnRbcHJvcGVydHldO1xuXG4gICAgICBjb21wb25lbnRbcHJvcGVydHldID0gdmFsdWU7XG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29uc3QgZW50aXRpZXMgPSBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmdldEVudGl0aWVzXSh3b3JsZCkgYXMgTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+PjtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgICAgZW50aXR5Lm9uVHJhY2tlZENvbXBvbmVudFVwZGF0ZSh7IHdvcmxkLCBjb21wb25lbnQgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFja2VkRXZlbnRIYW5kbGVycy5vblVwZGF0ZSkge1xuICAgICAgICB0cmFja2VkRXZlbnRIYW5kbGVycy5vblVwZGF0ZSh7XG4gICAgICAgICAgZW50aXRpZXMsXG4gICAgICAgICAgd29ybGQsXG4gICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgIHByZXZpb3VzVmFsLFxuICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrQ29tcG9uZW50PENUPihcbiAgQ29tcENsYXNzOiBDbGFzc0NvbnN0cnVjdG9yPENUPixcbiAgdHJhY2tlZEV2ZW50SGFuZGxlcnM6IFRyYWNrZWRFdmVudEhhbmRsZXJzPENUPlxuKTogVHJhY2tlZENvbXBvbmVudDxDVD4ge1xuICByZXR1cm4gbmV3IFByb3h5KENvbXBDbGFzcywge1xuICAgIGNvbnN0cnVjdChDb21wb25lbnQ6IGFueSwgYXJnczogYW55KSB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KC4uLmFyZ3MpIGFzIENUICYgVHJhY2tlZENvbXBvbmVudDxDVD47XG5cbiAgICAgIC8vIEZvciB1c2UgaW4gaWRlbnRpZmluZyBhIFwidHJhY2tlZFwiIGNsYXNzIHRocm91Z2ggdGhlIHByb3h5LlxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmlzVHJhY2tlZF0gPSB0cnVlO1xuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMuc2V0V29ybGRdID0gKFxuICAgICAgICB3b3JsZDogV29ybGQ8Q1Q+XG4gICAgICApID0+IHtcbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMud29ybGRdID0gd29ybGQ7XG4gICAgICB9O1xuXG4gICAgICAvLyBIb2xkcyBlbnRpdGllcyB0aGF0IHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIGFkZGVkIHRvLlxuICAgICAgLy8gQWRkZWQgYW5kIHJlbW92ZWQgaW4gd29ybGQuYWRkKCkvd29ybGQucmVtb3ZlKCkuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMuZW50aXR5SURzXSA9IG5ldyBTZXQoKTtcblxuXG4gICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBFbnRpdGllcyBmcm9tIGVudGl0eUlEc1xuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmdldEVudGl0aWVzXSA9ICh3b3JsZDogV29ybGQ8Q1Q+KTogTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+PiA9PiB7XG4gICAgICAgIGNvbnN0IGVudGl0aWVzID0gbmV3IE1hcDxFbnRpdHlJZCwgRW50aXR5PENUPj4oKTtcblxuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgZm9yIChjb25zdCBlaWQgb2YgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5lbnRpdHlJRHNdKSB7XG4gICAgICAgICAgY29uc3QgZW50aXR5ID0gd29ybGQuZW50aXRpZXMuZ2V0KGVpZCk7XG4gICAgICAgICAgaWYgKGVudGl0eSkge1xuICAgICAgICAgICAgZW50aXRpZXMuc2V0KGVpZCwgZW50aXR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW50aXRpZXM7XG4gICAgICB9XG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vbkFkZF0gPSAoXG4gICAgICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgICAgIGVudGl0eTogRW50aXR5PENUPlxuICAgICAgKSA9PiB7XG4gICAgICAgIGlmICh0cmFja2VkRXZlbnRIYW5kbGVycy5vbkFkZCkge1xuICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0IGVudGl0aWVzID0gY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5nZXRFbnRpdGllc10od29ybGQpIGFzIE1hcDxFbnRpdHlJZCwgRW50aXR5PENUPj47XG5cbiAgICAgICAgICB0cmFja2VkRXZlbnRIYW5kbGVycy5vbkFkZCh7IGNvbXBvbmVudCwgd29ybGQsIGVudGl0eSwgZW50aXRpZXMgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vblJlbW92ZV0gPSAoXG4gICAgICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgICAgIGVudGl0eTogRW50aXR5PENUPlxuICAgICAgKSA9PiB7XG4gICAgICAgIGlmICh0cmFja2VkRXZlbnRIYW5kbGVycy5vblJlbW92ZSkge1xuICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0IGVudGl0aWVzID0gY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5nZXRFbnRpdGllc10od29ybGQpIGFzIE1hcDxFbnRpdHlJZCwgRW50aXR5PENUPj47XG5cbiAgICAgICAgICB0cmFja2VkRXZlbnRIYW5kbGVycy5vblJlbW92ZSh7IGNvbXBvbmVudCwgd29ybGQsIGVudGl0eSwgZW50aXRpZXMgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgUHJveHkoXG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgY3JlYXRlQ2xhc3NJbnN0YW5jZVByb3h5SGFuZGxlcnModHJhY2tlZEV2ZW50SGFuZGxlcnMpXG4gICAgICApO1xuICAgIH0sXG4gIH0pO1xufVxuIiwiaW1wb3J0IEVudGl0eSwgeyBFbnRpdHlJZCB9IGZyb20gXCIuL0VudGl0eVwiO1xuaW1wb3J0IENvbXBvbmVudENvbGxlY3Rpb24gZnJvbSBcIi4vQ29tcG9uZW50Q29sbGVjdGlvblwiO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSBcIi4vVGFnXCI7XG5pbXBvcnQgeyBTeXN0ZW1GdW5jIH0gZnJvbSBcIi4vU3lzdGVtc1wiO1xuaW1wb3J0IERldlRvb2xzIGZyb20gXCIuL0RldlRvb2xzXCI7XG5pbXBvcnQgU3lzdGVtcyBmcm9tICcuL1N5c3RlbXMnO1xuaW1wb3J0IHsgVHJhY2tlZENvbXBTeW1ib2xLZXlzIH0gZnJvbSAnLi9UcmFja2VkQ29tcG9uZW50JztcblxuZXhwb3J0IHR5cGUgQ2xhc3NDb25zdHJ1Y3RvcjxUPiA9IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQgfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV29ybGQ8Q1Q+IHtcbiAgY29tcG9uZW50Q29sbGVjdGlvbnM6IE1hcDxFbnRpdHlJZCwgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4+ID0gbmV3IE1hcCgpO1xuXG4gIGVudGl0aWVzOiBNYXA8RW50aXR5SWQsIEVudGl0eTxDVD4+ID0gbmV3IE1hcCgpO1xuXG4gIGVudGl0aWVzQnlDVHlwZXM6IE1hcDxzdHJpbmdbXSwgU2V0PEVudGl0eUlkPj4gPSBuZXcgTWFwKCk7XG5cbiAgZW50aXRpZXNCeVRhZ3M6IE1hcDxUYWcsIFNldDxFbnRpdHlJZD4+ID0gbmV3IE1hcCgpO1xuXG4gIHN5c3RlbXM6IFN5c3RlbXM8Q1Q+O1xuXG4gIGRldjogRGV2VG9vbHM8Q1Q+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGV2ID0gbmV3IERldlRvb2xzKHRoaXMpO1xuICAgIHRoaXMuc3lzdGVtcyA9IG5ldyBTeXN0ZW1zKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiZmluZHNcIiBhIHNpbmdsZSBlbnRpdHkgYmFzZWQgb24gYSBwcmVkaWNhdGVcbiAgICovXG4gIGZpbmQgPSAocHJlZGljYXRlOiAoZW50aXR5OiBFbnRpdHk8Q1Q+KSA9PiBib29sZWFuKTogRW50aXR5PENUPiB8IG51bGwgPT4ge1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoZW50aXR5KSkge1xuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBcImZpbmRzXCIgYWxsIGVudGl0aWVzIGJhc2VkIG9uIGEgcHJlZGljYXRlLCBraW5kYSBsaWtlIGZpbHRlci5cbiAgICovXG4gIGZpbmRBbGwgPSAocHJlZGljYXRlOiAoZW50aXR5OiBFbnRpdHk8Q1Q+KSA9PiBib29sZWFuKTogRW50aXR5PENUPltdID0+IHtcbiAgICBjb25zdCByZXN1bHRzOiBFbnRpdHk8Q1Q+W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoZW50aXR5KSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvKipcbiAgICogXCJsb2NhdGVzXCIgYSBzaW5nbGUgZW50aXR5IGJhc2VkIG9uIGl0cyBDb21wb25lbnRzLlxuICAgKi9cbiAgbG9jYXRlID0gKGNsOiBDbGFzc0NvbnN0cnVjdG9yPENUPiB8IENsYXNzQ29uc3RydWN0b3I8Q1Q+W10pOiBFbnRpdHk8Q1Q+IHwgbnVsbCA9PiB7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVudGl0eS5jb21wb25lbnRzLmhhcyhjbCkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogTG9jYXRlcyBhbGwgZW50aXRpZXMgdGhhdCBjb250YWluIHRoZSBjb21wb25lbnRzIG5hbWVkXG4gICAqL1xuICBsb2NhdGVBbGwgPSAoY2w6IENsYXNzQ29uc3RydWN0b3I8Q1Q+IHwgQ2xhc3NDb25zdHJ1Y3RvcjxDVD5bXSk6IEVudGl0eTxDVD5bXSA9PiB7XG4gICAgY29uc3QgcmVzdWx0czogRW50aXR5PENUPltdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZW50aXR5LmNvbXBvbmVudHMuaGFzKGNsKSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvKipcbiAgICogR3JhYnMgdGhlIGZpcnN0IGVudGl0eSwgYW5kIGl0cyByZWxhdGVkIGNvbXBvbmVudCwgdGhhdCBtYXRjaGVzIHRoZSBjb21wb25lbnQgdHlwZS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIGNvbnN0IHsgZW50aXR5LCBjb21wb25lbnQgfSA9IHdvcmxkLmdyYWIoTXlDb21wb25lbnQpO1xuICAgKiBgYGBcbiAgICovXG4gIGdyYWIgPSA8VCBleHRlbmRzIENUPihcbiAgICBjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPlxuICApOiB7IGVudGl0eTogRW50aXR5PENUPjsgY29tcG9uZW50OiBUIH0gfCBudWxsID0+IHtcbiAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmxvY2F0ZShjbCk7XG5cbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBjb25zdCBjYyA9XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVudGl0eS5pZCkgfHxcbiAgICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNjLmdldDxUPihjbCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudGl0eSxcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR3JhYiBzaW5nbGUgY29tcG9uZW50IGJhc2VkIG9uIGNvbXBvbmVudCB0eXBlIGFuZCBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgeyBlbnRpdHksIGNvbXBvbmVudCB9ID0gd29ybGQuZ3JhYkJ5KEZpcnN0Q29tcG9uZW50LCAoY29tcCkgPT4gY29tcC5pZCA9PSAnYXdlc29tZScpXG4gICAqIGBgYFxuICAgKi9cbiAgZ3JhYkJ5ID0gPFQgZXh0ZW5kcyBDVD4oXG4gICAgY2w6IENsYXNzQ29uc3RydWN0b3I8VD4sXG4gICAgcHJlZGljYXRlOiAoY29tcDogVCkgPT4gYm9vbGVhblxuICApOiB7IGVudGl0eTogRW50aXR5PENUPjsgY29tcG9uZW50OiBUIH0gfCBudWxsID0+IHtcbiAgICBjb25zdCBlbnRpdGllcyA9IHRoaXMubG9jYXRlQWxsKGNsKTtcbiAgICAvLyBjb25zdCBlbnRpdGllcyA9IHRoaXMubG9jYXRlQWxsKChjbCBhcyB1bmtub3duKSBhcyBDVCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgY2MgPVxuICAgICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlbnRpdHkuaWQpIHx8XG4gICAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgICBjb25zdCBjb21wb25lbnQgPSBjYy5nZXQ8VD4oY2wpO1xuXG4gICAgICBpZiAocHJlZGljYXRlKGNvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgZW50aXR5LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHcmFiIGFsbCB0aGUgY29tcG9uZW50cyBwcmltYXJpbHksIGFuZCB0aGUgZW50aXRpZXMgaWYgbmVlZGVkXG4gICAqL1xuICBncmFiQWxsID0gPFQgZXh0ZW5kcyBDVD4oXG4gICAgY2w6IENsYXNzQ29uc3RydWN0b3I8VD5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogVCB9W10gPT4ge1xuICAgIGNvbnN0IGVudGl0aWVzID0gdGhpcy5sb2NhdGVBbGwoY2wpO1xuXG4gICAgcmV0dXJuIGVudGl0aWVzLm1hcCgoZW50aXR5KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbnRpdHksXG4gICAgICAgIGNvbXBvbmVudDogZW50aXR5LmNvbXBvbmVudHMuZ2V0PFQ+KGNsKSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETzogQWRkIGdyYWJBbGxCeSBtZXRob2RcblxuICAvKipcbiAgICogR2l2ZW4gYW4gZW50aXR5IGlkIGFuZCBjb21wb25lbnRUeXBlLCByZXR1cm5zIGNvbXBvbmVudFxuICAgKi9cbiAgZ2V0ID0gPFQgZXh0ZW5kcyBDVD4oZWlkOiBFbnRpdHlJZCwgY2w6IENsYXNzQ29uc3RydWN0b3I8VD4pOiBUID0+IHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgcmV0dXJuIGNjLmdldDxUPihjbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgYW5kIGdldCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQsIHdpdGhvdXQgYW55IGFzc29jaWF0ZWQgZW50aXRpZXMuXG4gICAqIEhlbHBmdWwgaXMgeW91IGtub3cgdGhhdCBvbmx5IG9uZSBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBleGlzdHMgYWNyb3NzIGFsbCBlbnRpdGllcy5cbiAgICogQHBhcmFtIGNsIENvbXBvbmVudCBDbGFzcyBDb250cnVjdG9yXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQSBkZWZhdWx0IGNvbXBvbmVudCBpbnN0YW5jZSBpZiBubyBjb21wb25lbnRzIGFyZSBmb3VuZC5cbiAgICovXG4gIGdldENvbXBvbmVudCA9IDxUIGV4dGVuZHMgQ1Q+KFxuICAgIGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+LFxuICAgIGRlZmF1bHRWYWx1ZT86IFRcbiAgKTogVCB8IG51bGwgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ3JhYihjbCk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSA/IGRlZmF1bHRWYWx1ZSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5jb21wb25lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBlbnRpdHkgdGhhdCBoYXMgYmVlbiB0YWdnZWQgd2l0aCB0aGUgZ2l2ZW4gdGFnLCBvciByZXR1cm4gbnVsbDtcbiAgICovXG4gIGdldFRhZ2dlZCA9ICh0YWc6IFRhZyk6IEVudGl0eTxDVD4gfCBudWxsID0+IHtcbiAgICBjb25zdCB0YWdFbnRpdHlJZHMgPSB0aGlzLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgaWYgKHRhZ0VudGl0eUlkcykge1xuICAgICAgY29uc3QgZW50aXR5SWQgPSB0YWdFbnRpdHlJZHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG5cbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0dCBhbGwgZW50aXRpZXMgdGhhdCBoYXZlIGJlZW4gdGFnZ2VkIHdpdGggdGhlIGdpdmVuIHRhZy5cbiAgICogQHBhcmFtIHRhZyBBIHN0cmluZyBvciBudW1iZXIuXG4gICAqL1xuICBnZXRBbGxUYWdnZWQgPSAodGFnOiBUYWcpOiBFbnRpdHk8Q1Q+W10gPT4ge1xuICAgIGxldCBlbnRpdGllczogRW50aXR5PENUPltdID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNvbnN0IHRhZ0VudGl0eUlkcyA9IHRoaXMuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZyk7XG5cbiAgICBpZiAodGFnRW50aXR5SWRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIHRhZ0VudGl0eUlkcykge1xuICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG4gICAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW50aXRpZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNvbXBvbmVudCBvbiB0aGUgZ2l2ZW4gZW50aXR5XG4gICAqL1xuICBhZGQgPSA8VCBleHRlbmRzIENUPihlaWQ6IEVudGl0eUlkLCBjb21wb25lbnQ6IFQpOiB0aGlzID0+IHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZWlkKTtcblxuICAgIGlmICghZW50aXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHdvcmxkLmFkZDogVW5hYmxlIHRvIGxvY2F0ZSBlbnRpdHkgd2l0aCBpZCAke2VpZH1gKTtcbiAgICB9XG5cbiAgICBjYy5hZGQoY29tcG9uZW50KTtcblxuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVpZCwgY2MpO1xuXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5hZGQoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMuaXNUcmFja2VkXSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5zZXRXb3JsZF0odGhpcyk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmVudGl0eUlEc10uYWRkKGVpZCk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uQWRkXSh0aGlzLCBlbnRpdHkpO1xuICAgIH1cblxuICAgIGVudGl0eS5vbkNvbXBvbmVudEFkZCh7IHdvcmxkOiB0aGlzLCBjb21wb25lbnQgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29tcG9uZW50IGZyb20gdGhlIGdpdmVuIGVudGl0eS5cbiAgICogTk9URTogVGhpcyB3aWxsIGNoYW5nZSB3aGF0IHN5c3RlbXMgd2lsbCBiZSBjYWxsZWQgb24gdGhlIGVudGl0eS5cbiAgICovXG4gIHJlbW92ZSA9IChlaWQ6IEVudGl0eUlkLCBjVHlwZTogQ2xhc3NDb25zdHJ1Y3RvcjxDVD4pOiB0aGlzID0+IHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgLy8gbmVlZCB0byBnZXQgY29tcG9uZW50IGluc3RhbmNlLi4uXG4gICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0KGNUeXBlKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5pc1RyYWNrZWRdKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlaWQpO1xuXG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdvcmxkLnJlbW92ZTogVW5hYmxlIHRvIGxvY2F0ZSBlbnRpdHkuIGVpZDogJHtlaWR9LCBjVHlwZTogJHtjVHlwZS5uYW1lfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmVudGl0eUlEc10uZGVsZXRlKGVpZCk7XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMub25SZW1vdmVdKHRoaXMsIGVudGl0eSk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGVudGl0eSBmcm9tIGN1cnJlbnQgZW50aXRpZXNCeUNUeXBlc1xuICAgIGZvciAoY29uc3QgW2N0QXJyLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcykge1xuICAgICAgaWYgKChjdEFyciBhcyBzdHJpbmdbXSkuZXZlcnkoY2MuaGFzQnlOYW1lKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2MucmVtb3ZlKGNUeXBlKTtcblxuICAgIC8vIE1vdmUgZW50aXR5SWQgdG8gbmV3IENUeXBlcyBpZiBuZWVkZWQuXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5hZGQoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlaWQpO1xuICAgIGlmIChlbnRpdHkpIHtcbiAgICAgIGVudGl0eS5vbkNvbXBvbmVudFJlbW92ZSh7IHdvcmxkOiB0aGlzLCBjb21wb25lbnQgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsdGVybmF0aXZlIG1ldGhvZCBmb3IgYWRkaW5nIHN5c3RlbXMuXG4gICAqL1xuICBhZGRTeXN0ZW0oY1R5cGVzOiBDbGFzc0NvbnN0cnVjdG9yPENUPltdLCBzeXN0ZW1GdW5jOiBTeXN0ZW1GdW5jPENUPiwgZnVuY05hbWU/OiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnN5c3RlbXMuYWRkKGNUeXBlcywgc3lzdGVtRnVuYywgZnVuY05hbWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTZXR1cCBhbiBlbnRpdHkgdG8gZXhpc3QgaW4gdGhlIGdpdmVuIHdvcmxkLiBUaGlzIGlzIG1vc3RseSBhbiBpbnRlcm5hbCBtZXRob2QsIGJ1dCBleHBvc2VkIGp1c3QgaW4gY2FzZS5cbiAgICovXG4gIHJlZ2lzdGVyRW50aXR5KGVudGl0eTogRW50aXR5PENUPik6IFdvcmxkPENUPiB7XG4gICAgY29uc3QgY2MgPSBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVudGl0eS5pZCwgY2MpO1xuICAgIHRoaXMuZW50aXRpZXMuc2V0KGVudGl0eS5pZCwgZW50aXR5KTtcblxuICAgIGVudGl0eS5vbkNyZWF0ZSh0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgY29tcG9uZW50cyB0aGF0IGJlbG9uZyB0byBhbiBlbnRpdHkuXG4gICAqL1xuICBjbGVhckVudGl0eUNvbXBvbmVudHMoZW50aXR5SWQ6IEVudGl0eUlkKTogdGhpcyB7XG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZW50aXR5SWQsIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpKTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5U2V0IG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVudGl0eVNldC5oYXMoZW50aXR5SWQpKSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUoZW50aXR5SWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlbnRpdHkgdGhhdCBpcyBpbiB0aGUgd29ybGQuXG4gICAqIEJhc2ljYWxseSBqdXN0IG5ldyBFbnRpdHkod29ybGQpLCBidXQgc2F2ZXMgYW4gaW1wb3J0IG9mIEVudGl0eS5cbiAgICovXG4gIGNyZWF0ZUVudGl0eSgpOiBFbnRpdHk8Q1Q+IHtcbiAgICBjb25zdCBlbnRpdHkgPSBuZXcgRW50aXR5KHRoaXMpO1xuXG4gICAgcmV0dXJuIGVudGl0eTtcblxuICAgIC8vIFJlZ2lzdGVyIGVudGl0eSBoZXJlLi4uLlxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGVudGl0eS5cbiAgICogU2FtZSBhcyBlbnRpdHkuZGVzdHJveSgpLlxuICAgKi9cbiAgZGVzdHJveUVudGl0eShlbnRpdHlJZDogRW50aXR5SWQpOiBXb3JsZDxDVD4ge1xuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZGVsZXRlKGVudGl0eUlkKTtcbiAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG5cbiAgICBpZiAoIWVudGl0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB3b3JsZC5kZXN0cm95RW50aXR5OiBObyBlbnRpdHkgZm91bmQuIGVudGl0eSBpZDogJHtlbnRpdHlJZH1gKTtcbiAgICB9XG5cbiAgICB0aGlzLmVudGl0aWVzLmRlbGV0ZShlbnRpdHlJZCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eVNldCBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVudGl0eUlkKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVudGl0eUlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYW55IHRhZyBhc3NvY2lhdGlvbnMgd2l0aCBkZXN0cm95ZWQgZW50aXRpZXMuXG4gICAgZm9yIChjb25zdCBbdGFnLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeVRhZ3MpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVudGl0eUlkKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVudGl0eUlkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVudGl0eVNldC5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKlxuICBUT0RPOiB3b3JsZC5kZXN0cm95KCkgYW5kIHdvcmxkLmRlc3Ryb3lJbW1lZGlhdGVseSgpIG1ldGhvZHMuXG4gICovXG59XG4iLCJpbXBvcnQgV29ybGQgZnJvbSAnLi9Xb3JsZCc7XG5pbXBvcnQgeyB0cmFja0NvbXBvbmVudCB9IGZyb20gJy4vVHJhY2tlZENvbXBvbmVudCc7XG5cbmV4cG9ydCB7XG4gIFdvcmxkLFxuICB0cmFja0NvbXBvbmVudCxcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')}])}));