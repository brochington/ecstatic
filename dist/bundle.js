!function(Q,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("ecstatic",[],n):"object"==typeof exports?exports.ecstatic=n():Q.ecstatic=n()}(window,(function(){return function(Q){var n=window.webpackHotUpdateecstatic;window.webpackHotUpdateecstatic=function(Q,B){!function(Q,n){if(!R[Q]||!y[Q])return;for(var B in y[Q]=!1,n)Object.prototype.hasOwnProperty.call(n,B)&&(b[B]=n[B]);0==--o&&0===u&&X()}(Q,B),n&&n(Q,B)};var B,t=!0,e="d93b3ffc9ba4eb12ad7a",F={},U=[],I=[];function s(Q){var n=r[Q];if(!n)return L;var t=function(t){return n.hot.active?(r[t]?-1===r[t].parents.indexOf(Q)&&r[t].parents.push(Q):(U=[Q],B=t),-1===n.children.indexOf(t)&&n.children.push(t)):(console.warn("[HMR] unexpected require("+t+") from disposed module "+Q),U=[]),L(t)},e=function(Q){return{configurable:!0,enumerable:!0,get:function(){return L[Q]},set:function(n){L[Q]=n}}};for(var F in L)Object.prototype.hasOwnProperty.call(L,F)&&"e"!==F&&"t"!==F&&Object.defineProperty(t,F,e(F));return t.e=function(Q){return"ready"===c&&d("prepare"),u++,L.e(Q).then(n,(function(Q){throw n(),Q}));function n(){u--,"prepare"===c&&(x[Q]||Z(Q),0===u&&0===o&&X())}},t.t=function(Q,n){return 1&n&&(Q=t(Q)),L.t(Q,-2&n)},t}function i(n){var t={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:B!==n,active:!0,accept:function(Q,n){if(void 0===Q)t._selfAccepted=!0;else if("function"==typeof Q)t._selfAccepted=Q;else if("object"==typeof Q)for(var B=0;B<Q.length;B++)t._acceptedDependencies[Q[B]]=n||function(){};else t._acceptedDependencies[Q]=n||function(){}},decline:function(Q){if(void 0===Q)t._selfDeclined=!0;else if("object"==typeof Q)for(var n=0;n<Q.length;n++)t._declinedDependencies[Q[n]]=!0;else t._declinedDependencies[Q]=!0},dispose:function(Q){t._disposeHandlers.push(Q)},addDisposeHandler:function(Q){t._disposeHandlers.push(Q)},removeDisposeHandler:function(Q){var n=t._disposeHandlers.indexOf(Q);n>=0&&t._disposeHandlers.splice(n,1)},invalidate:function(){switch(this._selfInvalidated=!0,c){case"idle":(b={})[n]=Q[n],d("ready");break;case"ready":E(n);break;case"prepare":case"check":case"dispose":case"apply":(G=G||[]).push(n)}},check:V,apply:N,status:function(Q){if(!Q)return c;l.push(Q)},addStatusHandler:function(Q){l.push(Q)},removeStatusHandler:function(Q){var n=l.indexOf(Q);n>=0&&l.splice(n,1)},data:F[n]};return B=void 0,t}var l=[],c="idle";function d(Q){c=Q;for(var n=0;n<l.length;n++)l[n].call(null,Q)}var g,b,C,G,o=0,u=0,x={},y={},R={};function a(Q){return+Q+""===Q?+Q:Q}function V(Q){if("idle"!==c)throw new Error("check() is only allowed in idle status");return t=Q,d("check"),(n=1e4,n=n||1e4,new Promise((function(Q,B){if("undefined"==typeof XMLHttpRequest)return B(new Error("No browser support"));try{var t=new XMLHttpRequest,e=L.p+"hot/hot-update.json";t.open("GET",e,!0),t.timeout=n,t.send(null)}catch(Q){return B(Q)}t.onreadystatechange=function(){if(4===t.readyState)if(0===t.status)B(new Error("Manifest request to "+e+" timed out."));else if(404===t.status)Q();else if(200!==t.status&&304!==t.status)B(new Error("Manifest request to "+e+" failed."));else{try{var n=JSON.parse(t.responseText)}catch(Q){return void B(Q)}Q(n)}}}))).then((function(Q){if(!Q)return d(m()?"ready":"idle"),null;y={},x={},R=Q.c,C=Q.h,d("prepare");var n=new Promise((function(Q,n){g={resolve:Q,reject:n}}));b={};return Z(0),"prepare"===c&&0===u&&0===o&&X(),n}));var n}function Z(Q){var n;R[Q]?(y[Q]=!0,o++,(n=document.createElement("script")).charset="utf-8",n.src=L.p+"hot/hot-update.js",document.head.appendChild(n)):x[Q]=!0}function X(){d("ready");var Q=g;if(g=null,Q)if(t)Promise.resolve().then((function(){return N(t)})).then((function(n){Q.resolve(n)}),(function(n){Q.reject(n)}));else{var n=[];for(var B in b)Object.prototype.hasOwnProperty.call(b,B)&&n.push(a(B));Q.resolve(n)}}function N(n){if("ready"!==c)throw new Error("apply() is only allowed in ready status");return function n(t){var I,s,i,l,c;function g(Q){for(var n=[Q],B={},t=n.map((function(Q){return{chain:[Q],id:Q}}));t.length>0;){var e=t.pop(),F=e.id,U=e.chain;if((l=r[F])&&(!l.hot._selfAccepted||l.hot._selfInvalidated)){if(l.hot._selfDeclined)return{type:"self-declined",chain:U,moduleId:F};if(l.hot._main)return{type:"unaccepted",chain:U,moduleId:F};for(var I=0;I<l.parents.length;I++){var s=l.parents[I],i=r[s];if(i){if(i.hot._declinedDependencies[F])return{type:"declined",chain:U.concat([s]),moduleId:F,parentId:s};-1===n.indexOf(s)&&(i.hot._acceptedDependencies[F]?(B[s]||(B[s]=[]),o(B[s],[F])):(delete B[s],n.push(s),t.push({chain:U.concat([s]),id:s})))}}}}return{type:"accepted",moduleId:Q,outdatedModules:n,outdatedDependencies:B}}function o(Q,n){for(var B=0;B<n.length;B++){var t=n[B];-1===Q.indexOf(t)&&Q.push(t)}}m();var u={},x=[],y={},V=function(){console.warn("[HMR] unexpected require("+X.moduleId+") to disposed module")};for(var Z in b)if(Object.prototype.hasOwnProperty.call(b,Z)){var X;c=a(Z),X=b[Z]?g(c):{type:"disposed",moduleId:Z};var N=!1,E=!1,W=!1,p="";switch(X.chain&&(p="\nUpdate propagation: "+X.chain.join(" -> ")),X.type){case"self-declined":t.onDeclined&&t.onDeclined(X),t.ignoreDeclined||(N=new Error("Aborted because of self decline: "+X.moduleId+p));break;case"declined":t.onDeclined&&t.onDeclined(X),t.ignoreDeclined||(N=new Error("Aborted because of declined dependency: "+X.moduleId+" in "+X.parentId+p));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(X),t.ignoreUnaccepted||(N=new Error("Aborted because "+c+" is not accepted"+p));break;case"accepted":t.onAccepted&&t.onAccepted(X),E=!0;break;case"disposed":t.onDisposed&&t.onDisposed(X),W=!0;break;default:throw new Error("Unexception type "+X.type)}if(N)return d("abort"),Promise.reject(N);if(E)for(c in y[c]=b[c],o(x,X.outdatedModules),X.outdatedDependencies)Object.prototype.hasOwnProperty.call(X.outdatedDependencies,c)&&(u[c]||(u[c]=[]),o(u[c],X.outdatedDependencies[c]));W&&(o(x,[X.moduleId]),y[c]=V)}var A,S=[];for(s=0;s<x.length;s++)c=x[s],r[c]&&r[c].hot._selfAccepted&&y[c]!==V&&!r[c].hot._selfInvalidated&&S.push({module:c,parents:r[c].parents.slice(),errorHandler:r[c].hot._selfAccepted});d("dispose"),Object.keys(R).forEach((function(Q){!1===R[Q]&&function(Q){delete installedChunks[Q]}(Q)}));var h,D,v=x.slice();for(;v.length>0;)if(c=v.pop(),l=r[c]){var H={},Y=l.hot._disposeHandlers;for(i=0;i<Y.length;i++)(I=Y[i])(H);for(F[c]=H,l.hot.active=!1,delete r[c],delete u[c],i=0;i<l.children.length;i++){var J=r[l.children[i]];J&&((A=J.parents.indexOf(c))>=0&&J.parents.splice(A,1))}}for(c in u)if(Object.prototype.hasOwnProperty.call(u,c)&&(l=r[c]))for(D=u[c],i=0;i<D.length;i++)h=D[i],(A=l.children.indexOf(h))>=0&&l.children.splice(A,1);d("apply"),void 0!==C&&(e=C,C=void 0);for(c in b=void 0,y)Object.prototype.hasOwnProperty.call(y,c)&&(Q[c]=y[c]);var k=null;for(c in u)if(Object.prototype.hasOwnProperty.call(u,c)&&(l=r[c])){D=u[c];var z=[];for(s=0;s<D.length;s++)if(h=D[s],I=l.hot._acceptedDependencies[h]){if(-1!==z.indexOf(I))continue;z.push(I)}for(s=0;s<z.length;s++){I=z[s];try{I(D)}catch(Q){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:c,dependencyId:D[s],error:Q}),t.ignoreErrored||k||(k=Q)}}}for(s=0;s<S.length;s++){var T=S[s];c=T.module,U=T.parents,B=c;try{L(c)}catch(Q){if("function"==typeof T.errorHandler)try{T.errorHandler(Q)}catch(n){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:c,error:n,originalError:Q}),t.ignoreErrored||k||(k=n),k||(k=Q)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:c,error:Q}),t.ignoreErrored||k||(k=Q)}}if(k)return d("fail"),Promise.reject(k);if(G)return n(t).then((function(Q){return x.forEach((function(n){Q.indexOf(n)<0&&Q.push(n)})),Q}));return d("idle"),new Promise((function(Q){Q(x)}))}(n=n||{})}function m(){if(G)return b||(b={}),G.forEach(E),G=void 0,!0}function E(n){Object.prototype.hasOwnProperty.call(b,n)||(b[n]=Q[n])}var r={};function L(n){if(r[n])return r[n].exports;var B=r[n]={i:n,l:!1,exports:{},hot:i(n),parents:(I=U,U=[],I),children:[]};return Q[n].call(B.exports,B,B.exports,s(n)),B.l=!0,B.exports}return L.m=Q,L.c=r,L.d=function(Q,n,B){L.o(Q,n)||Object.defineProperty(Q,n,{enumerable:!0,get:B})},L.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},L.t=function(Q,n){if(1&n&&(Q=L(Q)),8&n)return Q;if(4&n&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var B=Object.create(null);if(L.r(B),Object.defineProperty(B,"default",{enumerable:!0,value:Q}),2&n&&"string"!=typeof Q)for(var t in Q)L.d(B,t,function(n){return Q[n]}.bind(null,t));return B},L.n=function(Q){var n=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return L.d(n,"a",n),n},L.o=function(Q,n){return Object.prototype.hasOwnProperty.call(Q,n)},L.p="/static/",L.h=function(){return e},s(0)(L.s=0)}([function(Q,n,B){Q.exports=B(1)},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "World", function() { return /* reexport */ World_World; });\n__webpack_require__.d(__webpack_exports__, "trackComponent", function() { return /* reexport */ trackComponent; });\n\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== \'undefined\' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \'undefined\' && typeof msCrypto.getRandomValues === \'function\' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error(\'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js\n/* harmony default export */ var regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js\n\n\nfunction validate(uuid) {\n  return typeof uuid === \'string\' && regex.test(uuid);\n}\n\n/* harmony default export */ var esm_browser_validate = (validate);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var stringify_i = 0; stringify_i < 256; ++stringify_i) {\n  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It\'s been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \'-\' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \'-\' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \'-\' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \'-\' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it\'s likely due to one\n  // of the following:\n  // - One or more input array values don\'t map to a hex octet (leading to\n  // "undefined" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!esm_browser_validate(uuid)) {\n    throw TypeError(\'Stringified UUID is invalid\');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ var esm_browser_stringify = (stringify);\n// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return esm_browser_stringify(rnds);\n}\n\n/* harmony default export */ var esm_browser_v4 = (v4);\n// CONCATENATED MODULE: ./src/guards.ts\nfunction isComponentInstance(Class, comp) {\n  if (!comp) {\n    return false;\n  }\n\n  if (!(comp instanceof Class)) {\n    return false;\n  }\n\n  return true;\n}\n// CONCATENATED MODULE: ./src/ComponentCollection.ts\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n// CT is a Union, like `type = FirstComponent | SecondComponent`.\nclass ComponentCollection_ComponentCollection {\n  constructor() {\n    _defineProperty(this, "components", new Map());\n\n    _defineProperty(this, "add", component => {\n      this.components.set(component.constructor.name, component);\n    });\n\n    _defineProperty(this, "update", (cl, func) => {\n      const c = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, c)) {\n        const updatedComponent = func(c);\n        this.components.set(cl.name, updatedComponent);\n      }\n    });\n\n    _defineProperty(this, "remove", cType => {\n      this.components.delete(cType.name);\n    });\n\n    _defineProperty(this, "get", cl => {\n      const comp = this.components.get(cl.name);\n\n      if (isComponentInstance(cl, comp)) {\n        return comp;\n      } else {\n        throw new Error(`ComponentCollection does not have component of type ${cl.name}`);\n      }\n    });\n\n    _defineProperty(this, "has", cType => {\n      return Array.isArray(cType) ? cType.every(ct => this.components.has(ct.name) === true) : this.components.has(cType.name);\n    });\n\n    _defineProperty(this, "hasByName", cName => {\n      return Array.isArray(cName) ? cName.every(ct => this.components.has(ct) === true) : this.components.has(cName);\n    });\n  }\n\n  /**\n   * Get the component type names that are currently being used in the collection.\n   */\n  get componentTypes() {\n    return [...this.components.keys()];\n  }\n  /**\n   * Get the current number of components that are in the collection.\n   */\n\n\n  get size() {\n    return this.components.size;\n  }\n\n  toDevComponents() {\n    const obj = {};\n\n    for (const [compName, comp] of this.components) {\n      obj[compName] = comp;\n    }\n\n    return obj;\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevEntity.ts\nfunction DevEntity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevEntity {\n  constructor(entity, world) {\n    DevEntity_defineProperty(this, "id", void 0);\n\n    DevEntity_defineProperty(this, "components", void 0);\n\n    DevEntity_defineProperty(this, "tags", void 0);\n\n    DevEntity_defineProperty(this, "systems", []);\n\n    this.id = entity.id;\n    this.components = entity.components.toDevComponents(), this.tags = [...entity.tags];\n    const compNames = Object.keys(this.components);\n\n    for (const [systemName, cNames] of world.systems.compNamesBySystemName) {\n      if (cNames.every(cName => compNames.includes(cName))) {\n        this.systems.push(systemName);\n      }\n    }\n  }\n\n  toTableRow() {\n    return {\n      id: this.id,\n      components: Object.keys(this.components).join(", "),\n      tags: this.tags.join(", "),\n      systems: this.systems.join(\', \')\n    };\n  }\n\n}\n\n/* harmony default export */ var src_DevEntity = (DevEntity);\n// CONCATENATED MODULE: ./src/SimpleFSM.ts\nfunction SimpleFSM_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass SimpleFSM {\n  constructor(initialState, transitions) {\n    SimpleFSM_defineProperty(this, "current", void 0);\n\n    SimpleFSM_defineProperty(this, "inital", void 0);\n\n    SimpleFSM_defineProperty(this, "transitions", void 0);\n\n    this.inital = initialState;\n    this.current = initialState;\n    this.transitions = transitions;\n  }\n\n  next(data) {\n    if (this.transitions[this.current]) {\n      this.current = this.transitions[this.current](data, this.current);\n    }\n  }\n\n  reset() {\n    this.current = this.inital;\n  }\n\n  is(checkState) {\n    return this.current === checkState;\n  }\n\n}\n// CONCATENATED MODULE: ./src/Entity.ts\nfunction Entity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nclass Entity_Entity {\n  get id() {\n    return this._id;\n  }\n\n  get world() {\n    return this._world;\n  }\n\n  get state() {\n    return this._state.current;\n  }\n\n  constructor(world) {\n    Entity_defineProperty(this, "_id", void 0);\n\n    Entity_defineProperty(this, "_world", void 0);\n\n    Entity_defineProperty(this, "_error", void 0);\n\n    Entity_defineProperty(this, "_state", void 0);\n\n    this._id = esm_browser_v4();\n    this._world = world;\n    this._error = null;\n\n    const fsmTransition = ns => {\n      if (ns === "error" || this._error) return "error";\n      return ns;\n    };\n\n    this._state = new SimpleFSM("creating", {\n      creating: fsmTransition,\n      created: fsmTransition,\n      destroying: fsmTransition,\n      destroyed: () => "destroyed",\n      error: () => "error"\n    });\n    /*\n    Registering with the World.\n    */\n\n    this._world.registerEntity(this);\n\n    if (this._world.systems.compNamesBySystemName.size === 0) {\n      this._state.next(\'created\');\n    }\n  }\n  /* LifeCycle methods, meant to be overridden */\n\n\n  onCreate(world) {// abstract\n  }\n\n  onDestroy(world) {// abstract\n  }\n\n  onComponentAdd(args) {// abstract\n  }\n\n  onTrackedComponentUpdate(args) {// abstract\n  }\n\n  onComponentRemove(args) {// abstract\n  }\n  /**\n   * Add a component to an Entity, doh.\n   */\n\n\n  add(component) {\n    this._world.add(this._id, component);\n\n    return this;\n  }\n  /**\n   * Add a tag to a component\n   */\n\n\n  addTag(tag) {\n    const entitySet = this._world.entitiesByTags.has(tag) ? this._world.entitiesByTags.get(tag) : new Set();\n\n    if (entitySet) {\n      entitySet.add(this._id);\n\n      this._world.entitiesByTags.set(tag, entitySet);\n    }\n\n    return this;\n  }\n  /**\n   * Determines if an entity has a component related to it.\n   */\n\n\n  has(cType) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    return cc.has(cType);\n  }\n  /**\n   * Check to see if an entity tagged with a given tag.\n   */\n\n\n  hasTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        return entitySet.has(this._id);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get a component that belongs to an entity.\n   */\n\n\n  get(cl) {\n    const cc = this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n    const component = cc.get(cl);\n    return component;\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection\n   */\n\n\n  getAll() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Remove a component from an entity.\n   * @param cType A component class, eg MyComponent\n   */\n\n\n  remove(cType) {\n    this._world.remove(this._id, cType);\n\n    return this;\n  }\n  /**\n   * Remove a tag from an entity\n   */\n\n\n  removeTag(tag) {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n\n      if (entitySet) {\n        entitySet.delete(this._id);\n\n        if (entitySet.size === 0) {\n          this._world.entitiesByTags.delete(tag);\n        }\n      }\n    }\n\n    return this;\n  }\n  /** Clears all components from an Entity */\n\n\n  clear() {\n    this._world.clearEntityComponents(this._id);\n\n    return this;\n  }\n  /**\n   * Remove all tags on an entity\n   */\n\n\n  clearTags() {\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      entitySet.delete(this._id);\n\n      if (entitySet.size === 0) {\n        this._world.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Sets the state of the entity to \'created\'. that\'s it.\n   */\n\n\n  finishCreation() {\n    this._state.next(\'created\');\n  }\n  /**\n   * Destroy an entity. Actual destruction is deferred until after the next pass of systems.\n   * This gives the systems a chance to do any cleanup that might be needed.\n   */\n\n\n  destroy() {\n    // If no systems are added, the destroy immediately.\n    if (this._world.systems.compNamesBySystemName.size === 0) {\n      this.destroyImmediately();\n      return;\n    } // Mark as "destroying" so that systems can act on it before actually being destroyed.\n\n\n    this._state.next(\'destroying\');\n  }\n\n  destroyImmediately() {\n    // Right now calling before the actual destorying of the entity.\n    // Might want to change this to post destruction in the future, who knows.\n    this.onDestroy(this._world); // Actually destroy entity.\n\n    this._world.destroyEntity(this._id); // should return an error??\n\n\n    this._state.next(\'destroyed\');\n  }\n  /**\n   * Get all components that have been added to an entity, via a ComponentCollection.\n   * Does the same thing as entityInstance.getAll().\n   */\n\n\n  get components() {\n    return this._world.componentCollections.get(this._id) || new ComponentCollection_ComponentCollection();\n  }\n  /**\n   * Retrieves all the tags that have been added to this entity.\n   */\n\n\n  get tags() {\n    const tags = new Set();\n\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      if (entitySet.has(this._id)) {\n        tags.add(tag);\n      }\n    }\n\n    return tags;\n  }\n  /**\n   * Convert Entity to a DevEntity. Very helpful in for debugging.\n   */\n\n\n  toDevEntity() {\n    return new src_DevEntity(this, this._world);\n  }\n\n}\n// CONCATENATED MODULE: ./src/DevTools.ts\nfunction DevTools_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass DevTools {\n  constructor(world) {\n    DevTools_defineProperty(this, "world", void 0);\n\n    this.world = world;\n  }\n  /**\n   * display the all systems of the world, and the components required by each system.\n   * Super helpful to use with console.table()\n   * @example\n   * ```\n   * console.table(world.dev.systemComponents);\n   * ```\n   */\n\n\n  get systemComponents() {\n    const compsBySystems = [];\n\n    for (const [system, compNames] of this.world.systems.compNamesBySystemName) {\n      compsBySystems.push({\n        system,\n        components: compNames.join(", ")\n      });\n    }\n\n    return compsBySystems;\n  }\n  /**\n   * Create an array of DevEntites. Can be very helpful for things like inspecting component state,\n   * and which systems will be called on an entity.\n   * @example\n   * ```\n   * console.table(world.dev.entities);\n   *\n   * // Pro tip! try displaying a table of entities with console.table and DevEntity.toTableRow().\n   * console.table(world.dev.entities.map(devEntity => devEntity.toTableRow()));\n   * ```\n   */\n\n\n  get entities() {\n    return [...this.world.entities.values()].map(e => e.toDevEntity());\n  }\n\n}\n\n/* harmony default export */ var src_DevTools = (DevTools);\n// CONCATENATED MODULE: ./src/Systems.ts\nfunction Systems_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/**\n * Arguments that are passed into a System function on each iteration.\n * This is how you acces things like the entity that particular entity to act on,\n * as well as some other helpful params like if the entity is the first or last entity\n * in the group of entities that being iterated over.\n */\n\nclass Systems_Systems {\n  // double check to make sure that maps are ordered.\n  constructor(world) {\n    Systems_defineProperty(this, "world", void 0);\n\n    Systems_defineProperty(this, "systemFuncBySystemName", void 0);\n\n    Systems_defineProperty(this, "compNamesBySystemName", void 0);\n\n    this.world = world;\n    this.systemFuncBySystemName = new Map();\n    this.compNamesBySystemName = new Map();\n  }\n\n  add(cTypes, systemFunc, funcName) {\n    const cNames = cTypes.map(ct => ct.name);\n    let name = systemFunc.name;\n\n    if (systemFunc.name === "") {\n      // Super brute force, and might lead to errors in the future, but for now\n      // using the stringified system function if the function doesn\'t already have a name.\n      // This is useful for anonymous functions used as a system function.\n      // Might be good to figure out how to get a hash of the function string.\n      name = systemFunc.toString().slice(0, 30);\n    }\n\n    if (funcName) {\n      name = funcName;\n    }\n\n    this.systemFuncBySystemName.set(name, systemFunc);\n    this.compNamesBySystemName.set(name, cNames);\n    this.world.entitiesByCTypes.set(cNames, new Set());\n    return this;\n  }\n\n  run() {\n    for (const [funcName, systemFunc] of this.systemFuncBySystemName.entries()) {\n      let index = 0;\n      const size = this.world.entitiesByCTypes.size;\n      const cNames = this.compNamesBySystemName.get(funcName) || [];\n      const cTypeArrs = this.world.entitiesByCTypes.get(cNames) || new Set();\n      const entitiesInCreatingState = [];\n      const entitiesInDestroyingState = [];\n\n      for (const entity of this.world.entities.values()) {\n        if (entity.state === "creating") {\n          entitiesInCreatingState.push(entity);\n        }\n\n        if (entity.state === "destroying") {\n          entitiesInDestroyingState.push(entity);\n        }\n      }\n\n      for (const eid of cTypeArrs) {\n        const args = {\n          entity: this.world.entities.get(eid) || new Entity_Entity(this.world),\n          components: this.world.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(),\n          world: this.world,\n          index,\n          size,\n          isFirst: index === 0,\n          isLast: index + 1 === size\n        };\n        systemFunc(args);\n        index += 1;\n      }\n\n      for (const entity of entitiesInCreatingState) {\n        entity.finishCreation();\n      }\n\n      for (const entity of entitiesInDestroyingState) {\n        entity.destroyImmediately();\n      }\n    }\n  }\n  /*\n    TODO: Nice to have options here:\n      - systems.activeSystems = new Set(); // if not in set, system doesn\'t run.\n      - systems.deactivateSystem(\'systemName\') // remove system from activeSystems\n      - systems.activateSystem(\'systemName) // adds system back to activeSystems\n      - systems.pause() // pauses running of systems. basically return immediately on run().\n      - systems.resume() // resume running of systems.\n  */\n\n\n}\n// CONCATENATED MODULE: ./src/TrackedComponent.ts\n// Waiting for Typescript 4.2 to come out so that Symbols are supporded keys.\nconst TrackedCompSymbolKeys = {\n  isTracked: Symbol.for("ecs.trackedComponent.isTracked"),\n  world: Symbol.for("ecs.trackedComponent.world"),\n  entityIDs: Symbol.for("ecs.trackedComponent.entityIDs"),\n  getEntities: Symbol.for("ecs.trackedComponent.getEntities"),\n  setWorld: Symbol.for("ecs.trackedComponent.setWorld"),\n  onAdd: Symbol.for("ecs.trackedComponent.onAdd"),\n  onUpdate: Symbol.for("ecs.trackedComponent.onUpdate"),\n  onRemove: Symbol.for("ecs.trackedComponent.onRemove")\n}; //@ts-ignore\n\nfunction createClassInstanceProxyHandlers(trackedEventHandlers) {\n  const updatedProps = new Set();\n  return {\n    set(component, property, value) {\n      updatedProps.add(property); //@ts-ignore\n\n      const world = component[TrackedCompSymbolKeys.world];\n      const previousVal = component[property];\n      component[property] = value; //@ts-ignore\n\n      const entities = component[TrackedCompSymbolKeys.getEntities](world);\n\n      for (const entity of entities.values()) {\n        entity.onTrackedComponentUpdate({\n          world,\n          component\n        });\n      }\n\n      if (trackedEventHandlers.onUpdate) {\n        trackedEventHandlers.onUpdate({\n          entities,\n          world,\n          component,\n          previousVal,\n          property\n        });\n      }\n\n      return true;\n    }\n\n  };\n}\n\nfunction trackComponent(CompClass, trackedEventHandlers) {\n  return new Proxy(CompClass, {\n    construct(Component, args) {\n      const component = new Component(...args); // For use in identifing a "tracked" class through the proxy.\n      //@ts-ignore\n\n      component[TrackedCompSymbolKeys.isTracked] = true; //@ts-ignore\n\n      component[TrackedCompSymbolKeys.setWorld] = world => {\n        //@ts-ignore\n        component[TrackedCompSymbolKeys.world] = world;\n      }; // Holds entities that this component has been added to.\n      // Added and removed in world.add()/world.remove().\n      //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.entityIDs] = new Set(); // Helper function to get the Entities from entityIDs\n      //@ts-ignore\n\n      component[TrackedCompSymbolKeys.getEntities] = world => {\n        const entities = new Map(); //@ts-ignore\n\n        for (const eid of component[TrackedCompSymbolKeys.entityIDs]) {\n          const entity = world.entities.get(eid);\n\n          if (entity) {\n            entities.set(eid, entity);\n          }\n        }\n\n        return entities;\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onAdd] = (world, entity) => {\n        if (trackedEventHandlers.onAdd) {\n          //@ts-ignore\n          const entities = component[TrackedCompSymbolKeys.getEntities](world);\n          trackedEventHandlers.onAdd({\n            component,\n            world,\n            entity,\n            entities\n          });\n        }\n      }; //@ts-ignore\n\n\n      component[TrackedCompSymbolKeys.onRemove] = (world, entity) => {\n        if (trackedEventHandlers.onRemove) {\n          //@ts-ignore\n          const entities = component[TrackedCompSymbolKeys.getEntities](world);\n          trackedEventHandlers.onRemove({\n            component,\n            world,\n            entity,\n            entities\n          });\n        }\n      };\n\n      return new Proxy(component, createClassInstanceProxyHandlers(trackedEventHandlers));\n    }\n\n  });\n}\n// CONCATENATED MODULE: ./src/World.ts\nfunction World_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nclass World_World {\n  constructor() {\n    World_defineProperty(this, "componentCollections", new Map());\n\n    World_defineProperty(this, "entities", new Map());\n\n    World_defineProperty(this, "entitiesByCTypes", new Map());\n\n    World_defineProperty(this, "entitiesByTags", new Map());\n\n    World_defineProperty(this, "systems", void 0);\n\n    World_defineProperty(this, "dev", void 0);\n\n    World_defineProperty(this, "find", predicate => {\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "findAll", predicate => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (predicate(entity)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "locate", cl => {\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "locateAll", cl => {\n      const results = [];\n\n      for (const entity of this.entities.values()) {\n        if (entity.components.has(cl)) {\n          results.push(entity);\n        }\n      }\n\n      return results;\n    });\n\n    World_defineProperty(this, "grab", cl => {\n      const entity = this.locate(cl);\n\n      if (entity) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n        return {\n          entity,\n          component\n        };\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabBy", (cl, predicate) => {\n      const entities = this.locateAll(cl); // const entities = this.locateAll((cl as unknown) as CT);\n\n      for (const entity of entities) {\n        const cc = this.componentCollections.get(entity.id) || new ComponentCollection_ComponentCollection();\n        const component = cc.get(cl);\n\n        if (predicate(component)) {\n          return {\n            component,\n            entity\n          };\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "grabAll", cl => {\n      const entities = this.locateAll(cl);\n      return entities.map(entity => {\n        return {\n          entity,\n          component: entity.components.get(cl)\n        };\n      });\n    });\n\n    World_defineProperty(this, "get", (eid, cl) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      return cc.get(cl);\n    });\n\n    World_defineProperty(this, "getComponent", (cl, defaultValue) => {\n      const result = this.grab(cl);\n\n      if (!result) {\n        return defaultValue ? defaultValue : null;\n      }\n\n      return result.component;\n    });\n\n    World_defineProperty(this, "getTagged", tag => {\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        const entityId = tagEntityIds.values().next().value;\n        const entity = this.entities.get(entityId);\n\n        if (entity) {\n          return entity;\n        }\n      }\n\n      return null;\n    });\n\n    World_defineProperty(this, "getAllTagged", tag => {\n      let entities = []; // eslint-disable-line\n\n      const tagEntityIds = this.entitiesByTags.get(tag);\n\n      if (tagEntityIds) {\n        for (const entityId of tagEntityIds) {\n          const entity = this.entities.get(entityId);\n\n          if (entity) {\n            entities.push(entity);\n          }\n        }\n      }\n\n      return entities;\n    });\n\n    World_defineProperty(this, "add", (eid, component) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection();\n      const entity = this.entities.get(eid);\n\n      if (!entity) {\n        throw new Error(`world.add: Unable to locate entity with id ${eid}`);\n      }\n\n      cc.add(component);\n      this.componentCollections.set(eid, cc);\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      } // @ts-ignore\n\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        // @ts-ignore\n        component[TrackedCompSymbolKeys.setWorld](this); // @ts-ignore\n\n        component[TrackedCompSymbolKeys.entityIDs].add(eid); // @ts-ignore\n\n        component[TrackedCompSymbolKeys.onAdd](this, entity);\n      }\n\n      entity.onComponentAdd({\n        world: this,\n        component\n      });\n      return this;\n    });\n\n    World_defineProperty(this, "remove", (eid, cType) => {\n      const cc = this.componentCollections.get(eid) || new ComponentCollection_ComponentCollection(); // need to get component instance...\n\n      const component = cc.get(cType); // @ts-ignore\n\n      if (component[TrackedCompSymbolKeys.isTracked]) {\n        const entity = this.entities.get(eid);\n\n        if (!entity) {\n          throw new Error(`world.remove: Unable to locate entity. eid: ${eid}, cType: ${cType.name}`);\n        } // @ts-ignore\n\n\n        component[TrackedCompSymbolKeys.entityIDs].delete(eid); // @ts-ignore\n\n        component[TrackedCompSymbolKeys.onRemove](this, entity);\n      } // remove entity from current entitiesByCTypes\n\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.delete(eid);\n        }\n      }\n\n      cc.remove(cType); // Move entityId to new CTypes if needed.\n\n      for (const [ctArr, entitySet] of this.entitiesByCTypes) {\n        if (ctArr.every(cc.hasByName)) {\n          entitySet.add(eid);\n        }\n      }\n\n      const entity = this.entities.get(eid);\n\n      if (entity) {\n        entity.onComponentRemove({\n          world: this,\n          component\n        });\n      }\n\n      return this;\n    });\n\n    this.dev = new src_DevTools(this);\n    this.systems = new Systems_Systems(this);\n  }\n  /**\n   * "finds" a single entity based on a predicate\n   */\n\n\n  /**\n   * Alternative method for adding systems.\n   */\n  addSystem(cTypes, systemFunc, funcName) {\n    this.systems.add(cTypes, systemFunc, funcName);\n    return this;\n  }\n  /**\n   * Setup an entity to exist in the given world. This is mostly an internal method, but exposed just in case.\n   */\n\n\n  registerEntity(entity) {\n    const cc = new ComponentCollection_ComponentCollection();\n    this.componentCollections.set(entity.id, cc);\n    this.entities.set(entity.id, entity);\n    entity.onCreate(this);\n    return this;\n  }\n  /**\n   * Remove all components that belong to an entity.\n   */\n\n\n  clearEntityComponents(entityId) {\n    this.componentCollections.set(entityId, new ComponentCollection_ComponentCollection());\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(entityId)) {\n        entitySet.delete(entityId);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Create an entity that is in the world.\n   * Basically just new Entity(world), but saves an import of Entity.\n   */\n\n\n  createEntity() {\n    const entity = new Entity_Entity(this);\n    return entity; // Register entity here....\n  }\n  /**\n   * Destroys an entity.\n   * Same as entity.destroy().\n   */\n\n\n  destroyEntity(entityId) {\n    this.componentCollections.delete(entityId);\n    const entity = this.entities.get(entityId);\n\n    if (!entity) {\n      throw new Error(`world.destroyEntity: No entity found. entity id: ${entityId}`);\n    }\n\n    this.entities.delete(entityId);\n\n    for (const entitySet of this.entitiesByCTypes.values()) {\n      if (entitySet.has(entityId)) {\n        entitySet.delete(entityId);\n      }\n    } // remove any tag associations with destroyed entities.\n\n\n    for (const [tag, entitySet] of this.entitiesByTags) {\n      if (entitySet.has(entityId)) {\n        entitySet.delete(entityId);\n      }\n\n      if (entitySet.size === 0) {\n        this.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n  /*\n  TODO: world.destroy() and world.destroyImmediately() methods.\n  */\n\n\n}\n// CONCATENATED MODULE: ./src/index.ts\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY3N0YXRpYy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzP2Q4ZjgiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzPzQwZDYiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzA2ZTQiLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3N0cmluZ2lmeS5qcz81OGNmIiwid2VicGFjazovL2Vjc3RhdGljLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz9lYzI2Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL2d1YXJkcy50cz8zYjU3Iiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL0NvbXBvbmVudENvbGxlY3Rpb24udHM/NTFjNCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZFbnRpdHkudHM/ZDE0MiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9TaW1wbGVGU00udHM/NDY5OSIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9FbnRpdHkudHM/YWM2OCIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9EZXZUb29scy50cz9lMDFhIiwid2VicGFjazovL2Vjc3RhdGljLy4vc3JjL1N5c3RlbXMudHM/YTYxMyIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9UcmFja2VkQ29tcG9uZW50LnRzP2JhMjciLCJ3ZWJwYWNrOi8vZWNzdGF0aWMvLi9zcmMvV29ybGQudHM/Y2MwYiIsIndlYnBhY2s6Ly9lY3N0YXRpYy8uL3NyYy9pbmRleC50cz9mZmI0Il0sIm5hbWVzIjpbImlzQ29tcG9uZW50SW5zdGFuY2UiLCJDbGFzcyIsImNvbXAiLCJDb21wb25lbnRDb2xsZWN0aW9uIiwiTWFwIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInNldCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNsIiwiZnVuYyIsImMiLCJnZXQiLCJ1cGRhdGVkQ29tcG9uZW50IiwiY1R5cGUiLCJkZWxldGUiLCJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwiY3QiLCJoYXMiLCJjTmFtZSIsImNvbXBvbmVudFR5cGVzIiwia2V5cyIsInNpemUiLCJ0b0RldkNvbXBvbmVudHMiLCJvYmoiLCJjb21wTmFtZSIsIkRldkVudGl0eSIsImVudGl0eSIsIndvcmxkIiwiaWQiLCJ0YWdzIiwiY29tcE5hbWVzIiwiT2JqZWN0Iiwic3lzdGVtTmFtZSIsImNOYW1lcyIsInN5c3RlbXMiLCJjb21wTmFtZXNCeVN5c3RlbU5hbWUiLCJpbmNsdWRlcyIsInB1c2giLCJ0b1RhYmxlUm93Iiwiam9pbiIsIlNpbXBsZUZTTSIsImluaXRpYWxTdGF0ZSIsInRyYW5zaXRpb25zIiwiaW5pdGFsIiwiY3VycmVudCIsIm5leHQiLCJkYXRhIiwicmVzZXQiLCJpcyIsImNoZWNrU3RhdGUiLCJFbnRpdHkiLCJfaWQiLCJfd29ybGQiLCJzdGF0ZSIsIl9zdGF0ZSIsInV1aWR2NCIsIl9lcnJvciIsImZzbVRyYW5zaXRpb24iLCJucyIsImNyZWF0aW5nIiwiY3JlYXRlZCIsImRlc3Ryb3lpbmciLCJkZXN0cm95ZWQiLCJlcnJvciIsInJlZ2lzdGVyRW50aXR5Iiwib25DcmVhdGUiLCJvbkRlc3Ryb3kiLCJvbkNvbXBvbmVudEFkZCIsImFyZ3MiLCJvblRyYWNrZWRDb21wb25lbnRVcGRhdGUiLCJvbkNvbXBvbmVudFJlbW92ZSIsImFkZCIsImFkZFRhZyIsInRhZyIsImVudGl0eVNldCIsImVudGl0aWVzQnlUYWdzIiwiU2V0IiwiY2MiLCJjb21wb25lbnRDb2xsZWN0aW9ucyIsImhhc1RhZyIsImdldEFsbCIsInJlbW92ZSIsInJlbW92ZVRhZyIsImNsZWFyIiwiY2xlYXJFbnRpdHlDb21wb25lbnRzIiwiY2xlYXJUYWdzIiwiZW50cmllcyIsImZpbmlzaENyZWF0aW9uIiwiZGVzdHJveSIsImRlc3Ryb3lJbW1lZGlhdGVseSIsImRlc3Ryb3lFbnRpdHkiLCJ0b0RldkVudGl0eSIsIkRldlRvb2xzIiwic3lzdGVtQ29tcG9uZW50cyIsImNvbXBzQnlTeXN0ZW1zIiwic3lzdGVtIiwiZW50aXRpZXMiLCJ2YWx1ZXMiLCJtYXAiLCJlIiwiU3lzdGVtcyIsInN5c3RlbUZ1bmNCeVN5c3RlbU5hbWUiLCJjVHlwZXMiLCJzeXN0ZW1GdW5jIiwiZnVuY05hbWUiLCJ0b1N0cmluZyIsInNsaWNlIiwiZW50aXRpZXNCeUNUeXBlcyIsInJ1biIsImluZGV4IiwiY1R5cGVBcnJzIiwiZW50aXRpZXNJbkNyZWF0aW5nU3RhdGUiLCJlbnRpdGllc0luRGVzdHJveWluZ1N0YXRlIiwiZWlkIiwiaXNGaXJzdCIsImlzTGFzdCIsIlRyYWNrZWRDb21wU3ltYm9sS2V5cyIsImlzVHJhY2tlZCIsIlN5bWJvbCIsImZvciIsImVudGl0eUlEcyIsImdldEVudGl0aWVzIiwic2V0V29ybGQiLCJvbkFkZCIsIm9uVXBkYXRlIiwib25SZW1vdmUiLCJjcmVhdGVDbGFzc0luc3RhbmNlUHJveHlIYW5kbGVycyIsInRyYWNrZWRFdmVudEhhbmRsZXJzIiwidXBkYXRlZFByb3BzIiwicHJvcGVydHkiLCJ2YWx1ZSIsInByZXZpb3VzVmFsIiwidHJhY2tDb21wb25lbnQiLCJDb21wQ2xhc3MiLCJQcm94eSIsImNvbnN0cnVjdCIsIkNvbXBvbmVudCIsIldvcmxkIiwicHJlZGljYXRlIiwicmVzdWx0cyIsImxvY2F0ZSIsImxvY2F0ZUFsbCIsImRlZmF1bHRWYWx1ZSIsInJlc3VsdCIsImdyYWIiLCJ0YWdFbnRpdHlJZHMiLCJlbnRpdHlJZCIsImN0QXJyIiwiaGFzQnlOYW1lIiwiZGV2IiwiYWRkU3lzdGVtIiwiY3JlYXRlRW50aXR5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7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Q0YsS0FkMEMsQ0FnQjNDOzs7QUFDQSxTQUFLLE1BQU0sQ0FBQ3pFLEdBQUQsRUFBTUMsU0FBTixDQUFYLElBQStCLEtBQUtDLGNBQXBDLEVBQW9EO0FBQ2xELFVBQUlELFNBQVMsQ0FBQ3pELEdBQVYsQ0FBY2lJLFFBQWQsQ0FBSixFQUE2QjtBQUMzQnhFLGlCQUFTLENBQUMvRCxNQUFWLENBQWlCdUksUUFBakI7QUFDRDs7QUFFRCxVQUFJeEUsU0FBUyxDQUFDckQsSUFBVixLQUFtQixDQUF2QixFQUEwQjtBQUN4QixhQUFLc0QsY0FBTCxDQUFvQmhFLE1BQXBCLENBQTJCOEQsR0FBM0I7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUE3WStCLEM7O0FDVi9CO0FBQ0EiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxudmFyIGdldFJhbmRvbVZhbHVlcztcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuICAgIC8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFycikge1xuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgdmFyIHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7IiwiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwiZXhwb3J0IGZ1bmN0aW9uIGlzQ29tcG9uZW50SW5zdGFuY2U8VD4oXG4gIENsYXNzOiBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gVCxcbiAgY29tcDogYW55XG4pOiBjb21wIGlzIEluc3RhbmNlVHlwZTx0eXBlb2YgQ2xhc3M+IHtcbiAgaWYgKCFjb21wKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENsYXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHsgaXNDb21wb25lbnRJbnN0YW5jZSB9IGZyb20gXCIuL2d1YXJkc1wiO1xuXG50eXBlIENvbXBOYW1lID0gc3RyaW5nO1xudHlwZSBDbGFzc0NvbnN0cnVjdG9yPFQ+ID0geyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVCB9O1xuXG4vLyBDVCBpcyBhIFVuaW9uLCBsaWtlIGB0eXBlID0gRmlyc3RDb21wb25lbnQgfCBTZWNvbmRDb21wb25lbnRgLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4ge1xuICBjb21wb25lbnRzOiBNYXA8Q29tcE5hbWUsIENUPiA9IG5ldyBNYXAoKTtcblxuICAvLyBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudFxuICBhZGQgPSAoY29tcG9uZW50OiBDVCk6IHZvaWQgPT4ge1xuICAgIHRoaXMuY29tcG9uZW50cy5zZXQoKDxhbnk+Y29tcG9uZW50KS5jb25zdHJ1Y3Rvci5uYW1lLCBjb21wb25lbnQpO1xuICB9O1xuXG4gIHVwZGF0ZSA9IDxUIGV4dGVuZHMgQ1Q+KGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+LCBmdW5jOiAoYzogVCkgPT4gVCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IGMgPSB0aGlzLmNvbXBvbmVudHMuZ2V0KGNsLm5hbWUpO1xuXG4gICAgaWYgKGlzQ29tcG9uZW50SW5zdGFuY2UoY2wsIGMpKSB7XG4gICAgICBjb25zdCB1cGRhdGVkQ29tcG9uZW50ID0gZnVuYyhjKTtcbiAgICAgIHRoaXMuY29tcG9uZW50cy5zZXQoY2wubmFtZSwgdXBkYXRlZENvbXBvbmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBjVHlwZSBDbGFzcyBvZiBjb21wb25lbnQgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlID0gKGNUeXBlOiBDbGFzc0NvbnN0cnVjdG9yPENUPik6IHZvaWQgPT4ge1xuICAgIHRoaXMuY29tcG9uZW50cy5kZWxldGUoY1R5cGUubmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGNvbXBvbmVudCB0aGF0IG1hdGNoZXMgdGhlIHBhc3NlZCBjbGFzcy5cbiAgICogV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gY29tcG9uZW50XG4gICAqIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGNvbGxlY3Rpb24sIHNvIGlmIHlvdSBkb24ndCBrbm93IGlmIGl0J3Mgc2FmZVxuICAgKiB0byBnZXQgYSBjb21wb25lbnQsIHlvdSBzaG91bGQgdGVzdCB3aXRoIGhhcygpIG9yIGhhc0J5TmFtZSgpIGZpcnN0LlxuICAgKiBZb3UgaGF2ZSBiZWVuIHdhcm5lZC5cbiAgICogQHBhcmFtIGNsIGNvbXBvbmVudCBDbGFzcyByZWZlcmVuY2UuXG4gICAqL1xuICBnZXQgPSA8VCBleHRlbmRzIENUPihjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPik6IFQgPT4ge1xuICAgIGNvbnN0IGNvbXAgPSB0aGlzLmNvbXBvbmVudHMuZ2V0KGNsLm5hbWUpO1xuXG4gICAgaWYgKGlzQ29tcG9uZW50SW5zdGFuY2U8VD4oY2wsIGNvbXApKSB7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ29tcG9uZW50Q29sbGVjdGlvbiBkb2VzIG5vdCBoYXZlIGNvbXBvbmVudCBvZiB0eXBlICR7Y2wubmFtZX1gXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB0byBzZWUgaWYgdGhlIGNvbGxlY3Rpb24gY29udGFpbnMgYSBzcGVjaWZpYyBDbGFzcyBvciBDbGFzc2VzLlxuICAgKiBAcGFyYW0gY1R5cGUgY29tcG9uZW50IENsYXNzLCBvciBhcnJheSBvZiBjb21wb25lbnQgQ2xhc3Nlcy5cbiAgICovXG4gIGhhcyA9IChjVHlwZTogQ2xhc3NDb25zdHJ1Y3RvcjxDVD4gfCBDbGFzc0NvbnN0cnVjdG9yPENUPltdKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY1R5cGUpXG4gICAgICA/IGNUeXBlLmV2ZXJ5KChjdCkgPT4gdGhpcy5jb21wb25lbnRzLmhhcyhjdC5uYW1lKSA9PT0gdHJ1ZSlcbiAgICAgIDogdGhpcy5jb21wb25lbnRzLmhhcyhjVHlwZS5uYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB0byBzZWUgaWYgdGhlIGNvbGxlY3Rpb24gaGFzIGEgY29tcG9uZW50IGluc3RhbmNlIGJhc2VkIG9uIGFcbiAgICogY2xhc3MgbmFtZS4gU29tZSBidWlsZCBzdGVwcy9taW5pZmllcnMgd2lsbCBjaGFuZ2UgdGhlIG5hbWUgb2YgQ2xhc3NlcyxcbiAgICogc28gaXQncyB1c3VhbGx5IGJlc3QgdG8gcGFzcyBpbiBhIE15Q2xhc3MubmFtZSBpbnN0ZWFkIG9mICdNeUNsYXNzJy5cbiAgICogQHBhcmFtIGNOYW1lIFRoZSBuYW1lIG9mIGEgQ2xhc3MsIG9yIGFycmF5IG9mIENsYXNzIG5hbWVzLlxuICAgKi9cbiAgaGFzQnlOYW1lID0gKGNOYW1lOiBzdHJpbmcgfCBzdHJpbmdbXSk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNOYW1lKVxuICAgICAgPyBjTmFtZS5ldmVyeSgoY3QpID0+IHRoaXMuY29tcG9uZW50cy5oYXMoY3QpID09PSB0cnVlKVxuICAgICAgOiB0aGlzLmNvbXBvbmVudHMuaGFzKGNOYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb21wb25lbnQgdHlwZSBuYW1lcyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgdXNlZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIGdldCBjb21wb25lbnRUeXBlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmNvbXBvbmVudHMua2V5cygpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGNvbXBvbmVudHMgdGhhdCBhcmUgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqL1xuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuc2l6ZTtcbiAgfVxuXG4gIHRvRGV2Q29tcG9uZW50cygpOiBSZWNvcmQ8c3RyaW5nLCBDVD4ge1xuICAgIGNvbnN0IG9iajogUmVjb3JkPHN0cmluZywgQ1Q+ID0ge307XG4gICAgZm9yIChjb25zdCBbY29tcE5hbWUsIGNvbXBdIG9mIHRoaXMuY29tcG9uZW50cykge1xuICAgICAgb2JqW2NvbXBOYW1lXSA9IGNvbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxuIiwiaW1wb3J0IFdvcmxkIGZyb20gXCIuL1dvcmxkXCI7XG5pbXBvcnQgRW50aXR5IGZyb20gXCIuL0VudGl0eVwiO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSBcIi4vVGFnXCI7XG5cbmludGVyZmFjZSBEZXZFbnRpdHlUYWJsZVJvdyB7XG4gIGlkOiBzdHJpbmc7XG4gIGNvbXBvbmVudHM6IHN0cmluZztcbiAgdGFnczogc3RyaW5nO1xuICBzeXN0ZW1zOiBzdHJpbmc7XG59XG5cbmNsYXNzIERldkVudGl0eTxDVD4ge1xuICBpZDogc3RyaW5nO1xuXG4gIGNvbXBvbmVudHM6IFJlY29yZDxzdHJpbmcsIENUPjtcblxuICB0YWdzOiBUYWdbXTtcblxuICBzeXN0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGVudGl0eTogRW50aXR5PENUPiwgd29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMuaWQgPSBlbnRpdHkuaWQ7XG4gICAgdGhpcy5jb21wb25lbnRzID0gZW50aXR5LmNvbXBvbmVudHMudG9EZXZDb21wb25lbnRzKCksXG4gICAgdGhpcy50YWdzID0gWy4uLmVudGl0eS50YWdzXTtcblxuICAgIGNvbnN0IGNvbXBOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuY29tcG9uZW50cyk7XG5cbiAgICBmb3IgKGNvbnN0IFtzeXN0ZW1OYW1lLCBjTmFtZXNdIG9mIHdvcmxkLnN5c3RlbXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lKSB7XG4gICAgICBpZiAoY05hbWVzLmV2ZXJ5KChjTmFtZSkgPT4gY29tcE5hbWVzLmluY2x1ZGVzKGNOYW1lKSkpIHtcbiAgICAgICAgdGhpcy5zeXN0ZW1zLnB1c2goc3lzdGVtTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdG9UYWJsZVJvdygpOiBEZXZFbnRpdHlUYWJsZVJvdyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgY29tcG9uZW50czogT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRzKS5qb2luKFwiLCBcIiksXG4gICAgICB0YWdzOiB0aGlzLnRhZ3Muam9pbihcIiwgXCIpLFxuICAgICAgc3lzdGVtczogdGhpcy5zeXN0ZW1zLmpvaW4oJywgJyksXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZXZFbnRpdHk7XG4iLCJleHBvcnQgdHlwZSBTdGF0ZSA9IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbDtcblxuZXhwb3J0IHR5cGUgVHJhbnNpdGlvbnM8UyBleHRlbmRzIFN0YXRlLCBEID0gdW5kZWZpbmVkPiA9IFJlY29yZDxcbiAgUyxcbiAgKGRhdGE6IEQsIGN1cnJlbnQ6IFMpID0+IFNcbj47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpbXBsZUZTTTxTIGV4dGVuZHMgU3RhdGUsIEQgPSB1bmRlZmluZWQ+IHtcbiAgY3VycmVudDogUztcblxuICBpbml0YWw6IFM7XG5cbiAgdHJhbnNpdGlvbnM6IFRyYW5zaXRpb25zPFMsIEQ+O1xuXG4gIGNvbnN0cnVjdG9yKGluaXRpYWxTdGF0ZTogUywgdHJhbnNpdGlvbnM6IFRyYW5zaXRpb25zPFMsIEQ+KSB7XG4gICAgdGhpcy5pbml0YWwgPSBpbml0aWFsU3RhdGU7XG4gICAgdGhpcy5jdXJyZW50ID0gaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcbiAgfVxuXG4gIG5leHQoZGF0YTogRCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25zW3RoaXMuY3VycmVudF0pIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMudHJhbnNpdGlvbnNbdGhpcy5jdXJyZW50XShkYXRhLCB0aGlzLmN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuaW5pdGFsO1xuICB9XG5cbiAgaXMoY2hlY2tTdGF0ZTogUyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQgPT09IGNoZWNrU3RhdGU7XG4gIH1cbn1cbiIsImltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgV29ybGQsIHsgQ2xhc3NDb25zdHJ1Y3RvciB9IGZyb20gXCIuL1dvcmxkXCI7XG5pbXBvcnQgQ29tcG9uZW50Q29sbGVjdGlvbiBmcm9tIFwiLi9Db21wb25lbnRDb2xsZWN0aW9uXCI7XG5pbXBvcnQgeyBUYWcgfSBmcm9tIFwiLi9UYWdcIjtcbmltcG9ydCBEZXZFbnRpdHkgZnJvbSBcIi4vRGV2RW50aXR5XCI7XG5cbmltcG9ydCBTaW1wbGVGU00gZnJvbSBcIi4vU2ltcGxlRlNNXCI7XG5cbmV4cG9ydCB0eXBlIEVudGl0eUlkID0gc3RyaW5nO1xuXG50eXBlIEVudGl0eVN0YXRlID1cbiAgfCBcImNyZWF0aW5nXCJcbiAgfCBcImNyZWF0ZWRcIlxuICB8IFwiZGVzdHJveWluZ1wiXG4gIHwgXCJkZXN0cm95ZWRcIlxuICB8IFwiZXJyb3JcIjtcblxuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlDb21wRXZlbnRBcmdzPENUPiB7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG4gIGNvbXBvbmVudDogQ1Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudGl0eTxDVD4ge1xuICBwcml2YXRlIF9pZDogc3RyaW5nO1xuICBwcml2YXRlIF93b3JsZDogV29ybGQ8Q1Q+O1xuXG4gIHByaXZhdGUgX2Vycm9yOiBFcnJvciB8IG51bGw7XG5cbiAgcHJpdmF0ZSBfc3RhdGU6IFNpbXBsZUZTTTxFbnRpdHlTdGF0ZSwgRW50aXR5U3RhdGU+O1xuXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuXG4gIGdldCB3b3JsZCgpOiBXb3JsZDxDVD4ge1xuICAgIHJldHVybiB0aGlzLl93b3JsZDtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpOiBFbnRpdHlTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmN1cnJlbnQ7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih3b3JsZDogV29ybGQ8Q1Q+KSB7XG4gICAgdGhpcy5faWQgPSB1dWlkdjQoKTtcbiAgICB0aGlzLl93b3JsZCA9IHdvcmxkO1xuXG4gICAgdGhpcy5fZXJyb3IgPSBudWxsO1xuXG4gICAgY29uc3QgZnNtVHJhbnNpdGlvbiA9IChcbiAgICAgIG5zOiBFbnRpdHlTdGF0ZVxuICAgICk6IEVudGl0eVN0YXRlID0+IHtcbiAgICAgIGlmIChucyA9PT0gXCJlcnJvclwiIHx8IHRoaXMuX2Vycm9yKSByZXR1cm4gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIG5zO1xuICAgIH07XG5cbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBTaW1wbGVGU008RW50aXR5U3RhdGUsIEVudGl0eVN0YXRlPihcImNyZWF0aW5nXCIsIHtcbiAgICAgIGNyZWF0aW5nOiBmc21UcmFuc2l0aW9uLFxuICAgICAgY3JlYXRlZDogZnNtVHJhbnNpdGlvbixcbiAgICAgIGRlc3Ryb3lpbmc6IGZzbVRyYW5zaXRpb24sXG4gICAgICBkZXN0cm95ZWQ6ICgpID0+IFwiZGVzdHJveWVkXCIsXG4gICAgICBlcnJvcjogKCkgPT4gXCJlcnJvclwiLFxuICAgIH0pO1xuXG4gICAgLypcbiAgICBSZWdpc3RlcmluZyB3aXRoIHRoZSBXb3JsZC5cbiAgICAqL1xuICAgIHRoaXMuX3dvcmxkLnJlZ2lzdGVyRW50aXR5KHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX3dvcmxkLnN5c3RlbXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuX3N0YXRlLm5leHQoJ2NyZWF0ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKiBMaWZlQ3ljbGUgbWV0aG9kcywgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiAqL1xuXG4gIG9uQ3JlYXRlKHdvcmxkOiBXb3JsZDxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25EZXN0cm95KHdvcmxkOiBXb3JsZDxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25Db21wb25lbnRBZGQoYXJnczogRW50aXR5Q29tcEV2ZW50QXJnczxDVD4pOiB2b2lkIHtcbiAgICAvLyBhYnN0cmFjdFxuICB9XG5cbiAgb25UcmFja2VkQ29tcG9uZW50VXBkYXRlKGFyZ3M6IEVudGl0eUNvbXBFdmVudEFyZ3M8Q1Q+KTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIG9uQ29tcG9uZW50UmVtb3ZlKGFyZ3M6IEVudGl0eUNvbXBFdmVudEFyZ3M8Q1Q+KTogdm9pZCB7XG4gICAgLy8gYWJzdHJhY3RcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBjb21wb25lbnQgdG8gYW4gRW50aXR5LCBkb2guXG4gICAqL1xuICBhZGQ8VCBleHRlbmRzIENUPihjb21wb25lbnQ6IFQpOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5hZGQodGhpcy5faWQsIGNvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0YWcgdG8gYSBjb21wb25lbnRcbiAgICovXG4gIGFkZFRhZyh0YWc6IFRhZyk6IHRoaXMge1xuICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmhhcyh0YWcpXG4gICAgICA/IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpXG4gICAgICA6IG5ldyBTZXQ8RW50aXR5SWQ+KCk7XG5cbiAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICBlbnRpdHlTZXQuYWRkKHRoaXMuX2lkKTtcbiAgICAgIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLnNldCh0YWcsIGVudGl0eVNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhbiBlbnRpdHkgaGFzIGEgY29tcG9uZW50IHJlbGF0ZWQgdG8gaXQuXG4gICAqL1xuICBoYXM8VCBleHRlbmRzIENUPihjVHlwZTogQ2xhc3NDb25zdHJ1Y3RvcjxUPik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHxcbiAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgcmV0dXJuIGNjLmhhcyhjVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIGFuIGVudGl0eSB0YWdnZWQgd2l0aCBhIGdpdmVuIHRhZy5cbiAgICovXG4gIGhhc1RhZyh0YWc6IFRhZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5oYXModGFnKSkge1xuICAgICAgY29uc3QgZW50aXR5U2V0ID0gdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZyk7XG4gICAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICAgIHJldHVybiBlbnRpdHlTZXQuaGFzKHRoaXMuX2lkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgY29tcG9uZW50IHRoYXQgYmVsb25ncyB0byBhbiBlbnRpdHkuXG4gICAqL1xuICBnZXQ8VCBleHRlbmRzIENUPihjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPik6IFQge1xuICAgIGNvbnN0IGNjID1cbiAgICAgIHRoaXMuX3dvcmxkLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldCh0aGlzLl9pZCkgfHxcbiAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0PFQ+KGNsKTtcblxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvblxuICAgKi9cbiAgZ2V0QWxsKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNvbXBvbmVudCBmcm9tIGFuIGVudGl0eS5cbiAgICogQHBhcmFtIGNUeXBlIEEgY29tcG9uZW50IGNsYXNzLCBlZyBNeUNvbXBvbmVudFxuICAgKi9cbiAgcmVtb3ZlKGNUeXBlOiBDbGFzc0NvbnN0cnVjdG9yPENUPik6IHRoaXMge1xuICAgIHRoaXMuX3dvcmxkLnJlbW92ZSh0aGlzLl9pZCwgY1R5cGUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdGFnIGZyb20gYW4gZW50aXR5XG4gICAqL1xuICByZW1vdmVUYWcodGFnOiBUYWcpOiB0aGlzIHtcbiAgICBpZiAodGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuaGFzKHRhZykpIHtcbiAgICAgIGNvbnN0IGVudGl0eVNldCA9IHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgICBpZiAoZW50aXR5U2V0KSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICAgIGlmIChlbnRpdHlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3dvcmxkLmVudGl0aWVzQnlUYWdzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENsZWFycyBhbGwgY29tcG9uZW50cyBmcm9tIGFuIEVudGl0eSAqL1xuICBjbGVhcigpOiB0aGlzIHtcbiAgICB0aGlzLl93b3JsZC5jbGVhckVudGl0eUNvbXBvbmVudHModGhpcy5faWQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0YWdzIG9uIGFuIGVudGl0eVxuICAgKi9cbiAgY2xlYXJUYWdzKCk6IHRoaXMge1xuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5lbnRyaWVzKCkpIHtcbiAgICAgIGVudGl0eVNldC5kZWxldGUodGhpcy5faWQpO1xuXG4gICAgICBpZiAoZW50aXR5U2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fd29ybGQuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGVudGl0eSB0byAnY3JlYXRlZCcuIHRoYXQncyBpdC5cbiAgICovXG4gIGZpbmlzaENyZWF0aW9uKCk6IHZvaWQge1xuICAgIHRoaXMuX3N0YXRlLm5leHQoJ2NyZWF0ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IGFuIGVudGl0eS4gQWN0dWFsIGRlc3RydWN0aW9uIGlzIGRlZmVycmVkIHVudGlsIGFmdGVyIHRoZSBuZXh0IHBhc3Mgb2Ygc3lzdGVtcy5cbiAgICogVGhpcyBnaXZlcyB0aGUgc3lzdGVtcyBhIGNoYW5jZSB0byBkbyBhbnkgY2xlYW51cCB0aGF0IG1pZ2h0IGJlIG5lZWRlZC5cbiAgICovXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gSWYgbm8gc3lzdGVtcyBhcmUgYWRkZWQsIHRoZSBkZXN0cm95IGltbWVkaWF0ZWx5LlxuICAgIGlmICh0aGlzLl93b3JsZC5zeXN0ZW1zLmNvbXBOYW1lc0J5U3lzdGVtTmFtZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lJbW1lZGlhdGVseSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1hcmsgYXMgXCJkZXN0cm95aW5nXCIgc28gdGhhdCBzeXN0ZW1zIGNhbiBhY3Qgb24gaXQgYmVmb3JlIGFjdHVhbGx5IGJlaW5nIGRlc3Ryb3llZC5cbiAgICB0aGlzLl9zdGF0ZS5uZXh0KCdkZXN0cm95aW5nJyk7XG4gIH1cblxuICBkZXN0cm95SW1tZWRpYXRlbHkoKTogdm9pZCB7XG4gICAgLy8gUmlnaHQgbm93IGNhbGxpbmcgYmVmb3JlIHRoZSBhY3R1YWwgZGVzdG9yeWluZyBvZiB0aGUgZW50aXR5LlxuICAgIC8vIE1pZ2h0IHdhbnQgdG8gY2hhbmdlIHRoaXMgdG8gcG9zdCBkZXN0cnVjdGlvbiBpbiB0aGUgZnV0dXJlLCB3aG8ga25vd3MuXG4gICAgdGhpcy5vbkRlc3Ryb3kodGhpcy5fd29ybGQpO1xuXG4gICAgLy8gQWN0dWFsbHkgZGVzdHJveSBlbnRpdHkuXG4gICAgdGhpcy5fd29ybGQuZGVzdHJveUVudGl0eSh0aGlzLl9pZCk7IC8vIHNob3VsZCByZXR1cm4gYW4gZXJyb3I/P1xuXG4gICAgdGhpcy5fc3RhdGUubmV4dCgnZGVzdHJveWVkJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIGFuIGVudGl0eSwgdmlhIGEgQ29tcG9uZW50Q29sbGVjdGlvbi5cbiAgICogRG9lcyB0aGUgc2FtZSB0aGluZyBhcyBlbnRpdHlJbnN0YW5jZS5nZXRBbGwoKS5cbiAgICovXG4gIGdldCBjb21wb25lbnRzKCk6IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fd29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KHRoaXMuX2lkKSB8fFxuICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgdGhlIHRhZ3MgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhpcyBlbnRpdHkuXG4gICAqL1xuICBnZXQgdGFncygpOiBTZXQ8VGFnPiB7XG4gICAgY29uc3QgdGFncyA9IG5ldyBTZXQ8VGFnPigpO1xuICAgIGZvciAoY29uc3QgW3RhZywgZW50aXR5U2V0XSBvZiB0aGlzLl93b3JsZC5lbnRpdGllc0J5VGFncy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKHRoaXMuX2lkKSkge1xuICAgICAgICB0YWdzLmFkZCh0YWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YWdzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgRW50aXR5IHRvIGEgRGV2RW50aXR5LiBWZXJ5IGhlbHBmdWwgaW4gZm9yIGRlYnVnZ2luZy5cbiAgICovXG4gIHRvRGV2RW50aXR5KCk6IERldkVudGl0eTxDVD4ge1xuICAgIHJldHVybiBuZXcgRGV2RW50aXR5PENUPih0aGlzLCB0aGlzLl93b3JsZCk7XG4gIH1cbn1cbiIsImltcG9ydCBXb3JsZCBmcm9tICcuL1dvcmxkJztcbmltcG9ydCBEZXZFbnRpdHkgZnJvbSAnLi9EZXZFbnRpdHknO1xuXG5pbnRlcmZhY2UgRGV2U3lzdGVtQ29tcHMge1xuICBzeXN0ZW06IHN0cmluZztcbiAgY29tcG9uZW50czogc3RyaW5nO1xufVxuXG5cbmNsYXNzIERldlRvb2xzPENUPiB7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkPENUPikge1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgfVxuICAvKipcbiAgICogZGlzcGxheSB0aGUgYWxsIHN5c3RlbXMgb2YgdGhlIHdvcmxkLCBhbmQgdGhlIGNvbXBvbmVudHMgcmVxdWlyZWQgYnkgZWFjaCBzeXN0ZW0uXG4gICAqIFN1cGVyIGhlbHBmdWwgdG8gdXNlIHdpdGggY29uc29sZS50YWJsZSgpXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zb2xlLnRhYmxlKHdvcmxkLmRldi5zeXN0ZW1Db21wb25lbnRzKTtcbiAgICogYGBgXG4gICAqL1xuICBnZXQgc3lzdGVtQ29tcG9uZW50cygpOiBEZXZTeXN0ZW1Db21wc1tdIHtcbiAgICBjb25zdCBjb21wc0J5U3lzdGVtcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBbc3lzdGVtLCBjb21wTmFtZXNdIG9mIHRoaXMud29ybGQuc3lzdGVtcy5jb21wTmFtZXNCeVN5c3RlbU5hbWUpIHtcbiAgICAgIGNvbXBzQnlTeXN0ZW1zLnB1c2goeyBzeXN0ZW0sIGNvbXBvbmVudHM6IGNvbXBOYW1lcy5qb2luKFwiLCBcIikgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBzQnlTeXN0ZW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhcnJheSBvZiBEZXZFbnRpdGVzLiBDYW4gYmUgdmVyeSBoZWxwZnVsIGZvciB0aGluZ3MgbGlrZSBpbnNwZWN0aW5nIGNvbXBvbmVudCBzdGF0ZSxcbiAgICogYW5kIHdoaWNoIHN5c3RlbXMgd2lsbCBiZSBjYWxsZWQgb24gYW4gZW50aXR5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMpO1xuICAgKlxuICAgKiAvLyBQcm8gdGlwISB0cnkgZGlzcGxheWluZyBhIHRhYmxlIG9mIGVudGl0aWVzIHdpdGggY29uc29sZS50YWJsZSBhbmQgRGV2RW50aXR5LnRvVGFibGVSb3coKS5cbiAgICogY29uc29sZS50YWJsZSh3b3JsZC5kZXYuZW50aXRpZXMubWFwKGRldkVudGl0eSA9PiBkZXZFbnRpdHkudG9UYWJsZVJvdygpKSk7XG4gICAqIGBgYFxuICAgKi9cblxuICBnZXQgZW50aXRpZXMoKTogRGV2RW50aXR5PENUPltdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMud29ybGQuZW50aXRpZXMudmFsdWVzKCldLm1hcCgoZSkgPT4gZS50b0RldkVudGl0eSgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZXZUb29scztcbiIsImltcG9ydCBFbnRpdHksIHsgRW50aXR5SWQgfSBmcm9tIFwiLi9FbnRpdHlcIjtcbmltcG9ydCBXb3JsZCwgeyBDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSBcIi4vV29ybGRcIjtcbmltcG9ydCBDb21wb25lbnRDb2xsZWN0aW9uIGZyb20gXCIuL0NvbXBvbmVudENvbGxlY3Rpb25cIjtcblxuLyoqXG4gKiBBcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIGludG8gYSBTeXN0ZW0gZnVuY3Rpb24gb24gZWFjaCBpdGVyYXRpb24uXG4gKiBUaGlzIGlzIGhvdyB5b3UgYWNjZXMgdGhpbmdzIGxpa2UgdGhlIGVudGl0eSB0aGF0IHBhcnRpY3VsYXIgZW50aXR5IHRvIGFjdCBvbixcbiAqIGFzIHdlbGwgYXMgc29tZSBvdGhlciBoZWxwZnVsIHBhcmFtcyBsaWtlIGlmIHRoZSBlbnRpdHkgaXMgdGhlIGZpcnN0IG9yIGxhc3QgZW50aXR5XG4gKiBpbiB0aGUgZ3JvdXAgb2YgZW50aXRpZXMgdGhhdCBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5c3RlbUZ1bmNBcmdzPENUPiB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBlbnRpdHkgYmVpbmcgaXRlcmF0ZWQuXG4gICAqL1xuICBlbnRpdHk6IEVudGl0eTxDVD47XG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB0aGF0IGJlbG9uZyB0byB0aGUgZW50aXR5XG4gICAqL1xuICBjb21wb25lbnRzOiBDb21wb25lbnRDb2xsZWN0aW9uPENUPjtcbiAgLyoqXG4gICAqIFRoZSBXb3JsZCBpbnN0YW5jZS5cbiAgICogVXNlIHRoaXMgdG8gYWNjZXNzIG90aGVyIGVudGl0aWVzLlxuICAgKi9cbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICAvKipcbiAgICogSXMgdGhlIGZpcnN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogSGVscGZ1bCBmb3Igc2V0dGluZyB1cCBzdGF0ZSB0aGF0IGlzIHRoZSBzYW1lIGZvciBhbGwgZW50aXRpZXMgb25seSBvbmNlLlxuICAgKi9cbiAgaXNGaXJzdDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIElzIHRoZSBsYXN0IGVudGl0eSB0byBiZSBpdGVyYXRlZCBvbiB0aGlzIHJ1biBvZiBhIHN5c3RlbS5cbiAgICogQ2FuIGJlIGhlbHBmdWwgdG8gdGVhciBkb3duIGFueXRoaW5nIHRoYXQgc2hvdWxkIGJlIGRlYWx0IHdpdGggYWZ0ZXIgYWxsIHRoZSBlbnRpdGVzIGhhdmUgcmFuLlxuICAgKi9cbiAgaXNMYXN0OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBzeXN0ZW0gaXMgcnVuLlxuICovXG5leHBvcnQgdHlwZSBTeXN0ZW1GdW5jPENUPiA9IChzeXRlbUZ1bmNBcmdzOiBTeXN0ZW1GdW5jQXJnczxDVD4pID0+IHZvaWQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbXM8Q1Q+IHtcbiAgd29ybGQ6IFdvcmxkPENUPjtcblxuICBzeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lOiBNYXA8c3RyaW5nLCBTeXN0ZW1GdW5jPENUPj47IC8vIGRvdWJsZSBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBtYXBzIGFyZSBvcmRlcmVkLlxuXG4gIGNvbXBOYW1lc0J5U3lzdGVtTmFtZTogTWFwPHN0cmluZywgc3RyaW5nW10+O1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZDxDVD4pIHtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5zeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgYWRkKFxuICAgIGNUeXBlczogQ2xhc3NDb25zdHJ1Y3RvcjxDVD5bXSxcbiAgICBzeXN0ZW1GdW5jOiBTeXN0ZW1GdW5jPENUPixcbiAgICBmdW5jTmFtZT86IHN0cmluZ1xuICApOiB0aGlzIHtcbiAgICBjb25zdCBjTmFtZXMgPSBjVHlwZXMubWFwKChjdCkgPT4gY3QubmFtZSk7XG5cbiAgICBsZXQgbmFtZSA9IHN5c3RlbUZ1bmMubmFtZTtcbiAgICBpZiAoc3lzdGVtRnVuYy5uYW1lID09PSBcIlwiKSB7XG4gICAgICAvLyBTdXBlciBicnV0ZSBmb3JjZSwgYW5kIG1pZ2h0IGxlYWQgdG8gZXJyb3JzIGluIHRoZSBmdXR1cmUsIGJ1dCBmb3Igbm93XG4gICAgICAvLyB1c2luZyB0aGUgc3RyaW5naWZpZWQgc3lzdGVtIGZ1bmN0aW9uIGlmIHRoZSBmdW5jdGlvbiBkb2Vzbid0IGFscmVhZHkgaGF2ZSBhIG5hbWUuXG4gICAgICAvLyBUaGlzIGlzIHVzZWZ1bCBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyB1c2VkIGFzIGEgc3lzdGVtIGZ1bmN0aW9uLlxuICAgICAgLy8gTWlnaHQgYmUgZ29vZCB0byBmaWd1cmUgb3V0IGhvdyB0byBnZXQgYSBoYXNoIG9mIHRoZSBmdW5jdGlvbiBzdHJpbmcuXG4gICAgICBuYW1lID0gc3lzdGVtRnVuYy50b1N0cmluZygpLnNsaWNlKDAsIDMwKTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY05hbWUpIHtcbiAgICAgIG5hbWUgPSBmdW5jTmFtZTtcbiAgICB9XG5cbiAgICB0aGlzLnN5c3RlbUZ1bmNCeVN5c3RlbU5hbWUuc2V0KG5hbWUsIHN5c3RlbUZ1bmMpO1xuICAgIHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lLnNldChuYW1lLCBjTmFtZXMpO1xuICAgIHRoaXMud29ybGQuZW50aXRpZXNCeUNUeXBlcy5zZXQoY05hbWVzLCBuZXcgU2V0PEVudGl0eUlkPigpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcnVuKCk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgW1xuICAgICAgZnVuY05hbWUsXG4gICAgICBzeXN0ZW1GdW5jLFxuICAgIF0gb2YgdGhpcy5zeXN0ZW1GdW5jQnlTeXN0ZW1OYW1lLmVudHJpZXMoKSkge1xuICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLndvcmxkLmVudGl0aWVzQnlDVHlwZXMuc2l6ZTtcbiAgICAgIGNvbnN0IGNOYW1lcyA9IHRoaXMuY29tcE5hbWVzQnlTeXN0ZW1OYW1lLmdldChmdW5jTmFtZSkgfHwgW107XG4gICAgICBjb25zdCBjVHlwZUFycnMgPSB0aGlzLndvcmxkLmVudGl0aWVzQnlDVHlwZXMuZ2V0KGNOYW1lcykgfHwgbmV3IFNldCgpO1xuXG4gICAgICBjb25zdCBlbnRpdGllc0luQ3JlYXRpbmdTdGF0ZSA9IFtdO1xuICAgICAgY29uc3QgZW50aXRpZXNJbkRlc3Ryb3lpbmdTdGF0ZSA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLndvcmxkLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChlbnRpdHkuc3RhdGUgPT09IFwiY3JlYXRpbmdcIikge1xuICAgICAgICAgIGVudGl0aWVzSW5DcmVhdGluZ1N0YXRlLnB1c2goZW50aXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRpdHkuc3RhdGUgPT09IFwiZGVzdHJveWluZ1wiKSB7XG4gICAgICAgICAgZW50aXRpZXNJbkRlc3Ryb3lpbmdTdGF0ZS5wdXNoKGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBlaWQgb2YgY1R5cGVBcnJzKSB7XG4gICAgICAgIGNvbnN0IGFyZ3M6IFN5c3RlbUZ1bmNBcmdzPENUPiA9IHtcbiAgICAgICAgICBlbnRpdHk6IHRoaXMud29ybGQuZW50aXRpZXMuZ2V0KGVpZCkgfHwgbmV3IEVudGl0eTxDVD4odGhpcy53b3JsZCksXG4gICAgICAgICAgY29tcG9uZW50czpcbiAgICAgICAgICAgIHRoaXMud29ybGQuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVpZCkgfHxcbiAgICAgICAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpLFxuICAgICAgICAgIHdvcmxkOiB0aGlzLndvcmxkLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgaXNGaXJzdDogaW5kZXggPT09IDAsXG4gICAgICAgICAgaXNMYXN0OiBpbmRleCArIDEgPT09IHNpemUsXG4gICAgICAgIH07XG5cbiAgICAgICAgc3lzdGVtRnVuYyhhcmdzKTtcblxuICAgICAgICBpbmRleCArPSAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllc0luQ3JlYXRpbmdTdGF0ZSkge1xuICAgICAgICBlbnRpdHkuZmluaXNoQ3JlYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzSW5EZXN0cm95aW5nU3RhdGUpIHtcbiAgICAgICAgZW50aXR5LmRlc3Ryb3lJbW1lZGlhdGVseSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgVE9ETzogTmljZSB0byBoYXZlIG9wdGlvbnMgaGVyZTpcbiAgICAgIC0gc3lzdGVtcy5hY3RpdmVTeXN0ZW1zID0gbmV3IFNldCgpOyAvLyBpZiBub3QgaW4gc2V0LCBzeXN0ZW0gZG9lc24ndCBydW4uXG4gICAgICAtIHN5c3RlbXMuZGVhY3RpdmF0ZVN5c3RlbSgnc3lzdGVtTmFtZScpIC8vIHJlbW92ZSBzeXN0ZW0gZnJvbSBhY3RpdmVTeXN0ZW1zXG4gICAgICAtIHN5c3RlbXMuYWN0aXZhdGVTeXN0ZW0oJ3N5c3RlbU5hbWUpIC8vIGFkZHMgc3lzdGVtIGJhY2sgdG8gYWN0aXZlU3lzdGVtc1xuICAgICAgLSBzeXN0ZW1zLnBhdXNlKCkgLy8gcGF1c2VzIHJ1bm5pbmcgb2Ygc3lzdGVtcy4gYmFzaWNhbGx5IHJldHVybiBpbW1lZGlhdGVseSBvbiBydW4oKS5cbiAgICAgIC0gc3lzdGVtcy5yZXN1bWUoKSAvLyByZXN1bWUgcnVubmluZyBvZiBzeXN0ZW1zLlxuICAqL1xufVxuIiwiaW1wb3J0IFdvcmxkLCB7IENsYXNzQ29uc3RydWN0b3IgfSBmcm9tIFwiLi9Xb3JsZFwiO1xuaW1wb3J0IEVudGl0eSwgeyBFbnRpdHlJZCB9IGZyb20gXCIuL0VudGl0eVwiO1xuXG4vLyBXYWl0aW5nIGZvciBUeXBlc2NyaXB0IDQuMiB0byBjb21lIG91dCBzbyB0aGF0IFN5bWJvbHMgYXJlIHN1cHBvcmRlZCBrZXlzLlxuZXhwb3J0IGNvbnN0IFRyYWNrZWRDb21wU3ltYm9sS2V5cyA9IHtcbiAgaXNUcmFja2VkOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQuaXNUcmFja2VkXCIpLFxuICB3b3JsZDogU3ltYm9sLmZvcihcImVjcy50cmFja2VkQ29tcG9uZW50LndvcmxkXCIpLFxuICBlbnRpdHlJRHM6IFN5bWJvbC5mb3IoXCJlY3MudHJhY2tlZENvbXBvbmVudC5lbnRpdHlJRHNcIiksXG4gIGdldEVudGl0aWVzOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQuZ2V0RW50aXRpZXNcIiksXG4gIHNldFdvcmxkOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQuc2V0V29ybGRcIiksXG4gIG9uQWRkOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQub25BZGRcIiksXG4gIG9uVXBkYXRlOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQub25VcGRhdGVcIiksXG4gIG9uUmVtb3ZlOiBTeW1ib2wuZm9yKFwiZWNzLnRyYWNrZWRDb21wb25lbnQub25SZW1vdmVcIiksXG59IGFzIGNvbnN0O1xuXG4vL0B0cy1pZ25vcmVcbnR5cGUgVHJhY2tlZENvbXBvbmVudDxDVD4gPSB7XG4gIG5ldyAoLi4uYXJnczogYW55W10pOiBDVDtcblxuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy5pc1RyYWNrZWRdOiBib29sZWFuO1xuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy5zZXRXb3JsZF06ICh3b3JsZDogV29ybGQ8Q1Q+KSA9PiB2b2lkO1xuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy53b3JsZF06IFdvcmxkPENUPjtcbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMuZW50aXR5SURzXTogU2V0PEVudGl0eUlkPjtcbiAgLy9AdHMtaWdub3JlXG4gIFtUcmFja2VkQ29tcFN5bWJvbEtleXMuZ2V0RW50aXRpZXNdOiAoKSA9PiBNYXA8RW50aXR5SWQsIEVudGl0eTxDVD4+O1xuICAvL0B0cy1pZ25vcmVcbiAgW1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vbkFkZF06IChcbiAgICB3b3JsZDogV29ybGQ8Q1Q+LFxuICAgIGVudGl0eTogRW50aXR5PENUPlxuICApID0+IHZvaWQ7XG4gIC8vQHRzLWlnbm9yZVxuICBbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uUmVtb3ZlXTogKFxuICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgZW50aXR5OiBFbnRpdHk8Q1Q+XG4gICkgPT4gdm9pZDtcbn07XG5cbmludGVyZmFjZSBBZGRFdmVudEFyZ3M8Q1Q+IHtcbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgY29tcG9uZW50OiBDVDtcbiAgZW50aXR5OiBFbnRpdHk8Q1Q+O1xuICBlbnRpdGllczogTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+Pjtcbn1cblxuaW50ZXJmYWNlIFVwZGF0ZUV2ZW50QXJnczxDVD4ge1xuICBlbnRpdGllczogTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+PjtcbiAgY29tcG9uZW50OiBDVDtcbiAgd29ybGQ6IFdvcmxkPENUPjtcbiAgcHJldmlvdXNWYWw6IENUW2tleW9mIENUXTtcbiAgcHJvcGVydHk6IGtleW9mIENUO1xufVxuXG5pbnRlcmZhY2UgUmVtb3ZlRXZlbnRBcmdzPENUPiB7XG4gIHdvcmxkOiBXb3JsZDxDVD47XG4gIGNvbXBvbmVudDogQ1Q7XG4gIGVudGl0eTogRW50aXR5PENUPjtcbiAgZW50aXRpZXM6IE1hcDxFbnRpdHlJZCwgRW50aXR5PENUPj47XG59XG5cbmludGVyZmFjZSBUcmFja2VkRXZlbnRIYW5kbGVyczxDVD4ge1xuICBvbkFkZD86IChhcmdzOiBBZGRFdmVudEFyZ3M8Q1Q+KSA9PiB2b2lkO1xuICBvblVwZGF0ZT86IChhcmdzOiBVcGRhdGVFdmVudEFyZ3M8Q1Q+KSA9PiB2b2lkO1xuICBvblJlbW92ZT86IChhcmdzOiBSZW1vdmVFdmVudEFyZ3M8Q1Q+KSA9PiB2b2lkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0luc3RhbmNlUHJveHlIYW5kbGVyczxDVD4oXG4gIHRyYWNrZWRFdmVudEhhbmRsZXJzOiBUcmFja2VkRXZlbnRIYW5kbGVyczxDVD5cbik6IFByb3h5SGFuZGxlcjxhbnk+IHtcbiAgY29uc3QgdXBkYXRlZFByb3BzID0gbmV3IFNldCgpO1xuICByZXR1cm4ge1xuICAgIHNldChcbiAgICAgIGNvbXBvbmVudDogQ1QsXG4gICAgICBwcm9wZXJ0eToga2V5b2YgQ1QsXG4gICAgICB2YWx1ZTogQ1Rba2V5b2YgQ1RdXG4gICAgKSB7XG4gICAgICB1cGRhdGVkUHJvcHMuYWRkKHByb3BlcnR5KTtcblxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb25zdCB3b3JsZCA9IGNvbXBvbmVudFtcbiAgICAgICAgVHJhY2tlZENvbXBTeW1ib2xLZXlzLndvcmxkXG4gICAgICBdIGFzIFdvcmxkPENUPjtcblxuICAgICAgY29uc3QgcHJldmlvdXNWYWwgPSBjb21wb25lbnRbcHJvcGVydHldO1xuXG4gICAgICBjb21wb25lbnRbcHJvcGVydHldID0gdmFsdWU7XG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29uc3QgZW50aXRpZXMgPSBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmdldEVudGl0aWVzXSh3b3JsZCkgYXMgTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+PjtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgICAgZW50aXR5Lm9uVHJhY2tlZENvbXBvbmVudFVwZGF0ZSh7IHdvcmxkLCBjb21wb25lbnQgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFja2VkRXZlbnRIYW5kbGVycy5vblVwZGF0ZSkge1xuICAgICAgICB0cmFja2VkRXZlbnRIYW5kbGVycy5vblVwZGF0ZSh7XG4gICAgICAgICAgZW50aXRpZXMsXG4gICAgICAgICAgd29ybGQsXG4gICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgIHByZXZpb3VzVmFsLFxuICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrQ29tcG9uZW50PENUPihcbiAgQ29tcENsYXNzOiBDbGFzc0NvbnN0cnVjdG9yPENUPixcbiAgdHJhY2tlZEV2ZW50SGFuZGxlcnM6IFRyYWNrZWRFdmVudEhhbmRsZXJzPENUPlxuKTogVHJhY2tlZENvbXBvbmVudDxDVD4ge1xuICByZXR1cm4gbmV3IFByb3h5KENvbXBDbGFzcywge1xuICAgIGNvbnN0cnVjdChDb21wb25lbnQ6IGFueSwgYXJnczogYW55KSB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KC4uLmFyZ3MpIGFzIENUICYgVHJhY2tlZENvbXBvbmVudDxDVD47XG5cbiAgICAgIC8vIEZvciB1c2UgaW4gaWRlbnRpZmluZyBhIFwidHJhY2tlZFwiIGNsYXNzIHRocm91Z2ggdGhlIHByb3h5LlxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmlzVHJhY2tlZF0gPSB0cnVlO1xuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMuc2V0V29ybGRdID0gKFxuICAgICAgICB3b3JsZDogV29ybGQ8Q1Q+XG4gICAgICApID0+IHtcbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMud29ybGRdID0gd29ybGQ7XG4gICAgICB9O1xuXG4gICAgICAvLyBIb2xkcyBlbnRpdGllcyB0aGF0IHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIGFkZGVkIHRvLlxuICAgICAgLy8gQWRkZWQgYW5kIHJlbW92ZWQgaW4gd29ybGQuYWRkKCkvd29ybGQucmVtb3ZlKCkuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMuZW50aXR5SURzXSA9IG5ldyBTZXQoKTtcblxuXG4gICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBFbnRpdGllcyBmcm9tIGVudGl0eUlEc1xuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmdldEVudGl0aWVzXSA9ICh3b3JsZDogV29ybGQ8Q1Q+KTogTWFwPEVudGl0eUlkLCBFbnRpdHk8Q1Q+PiA9PiB7XG4gICAgICAgIGNvbnN0IGVudGl0aWVzID0gbmV3IE1hcDxFbnRpdHlJZCwgRW50aXR5PENUPj4oKTtcblxuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgZm9yIChjb25zdCBlaWQgb2YgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5lbnRpdHlJRHNdKSB7XG4gICAgICAgICAgY29uc3QgZW50aXR5ID0gd29ybGQuZW50aXRpZXMuZ2V0KGVpZCk7XG4gICAgICAgICAgaWYgKGVudGl0eSkge1xuICAgICAgICAgICAgZW50aXRpZXMuc2V0KGVpZCwgZW50aXR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW50aXRpZXM7XG4gICAgICB9XG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vbkFkZF0gPSAoXG4gICAgICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgICAgIGVudGl0eTogRW50aXR5PENUPlxuICAgICAgKSA9PiB7XG4gICAgICAgIGlmICh0cmFja2VkRXZlbnRIYW5kbGVycy5vbkFkZCkge1xuICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0IGVudGl0aWVzID0gY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5nZXRFbnRpdGllc10od29ybGQpIGFzIE1hcDxFbnRpdHlJZCwgRW50aXR5PENUPj47XG5cbiAgICAgICAgICB0cmFja2VkRXZlbnRIYW5kbGVycy5vbkFkZCh7IGNvbXBvbmVudCwgd29ybGQsIGVudGl0eSwgZW50aXRpZXMgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5vblJlbW92ZV0gPSAoXG4gICAgICAgIHdvcmxkOiBXb3JsZDxDVD4sXG4gICAgICAgIGVudGl0eTogRW50aXR5PENUPlxuICAgICAgKSA9PiB7XG4gICAgICAgIGlmICh0cmFja2VkRXZlbnRIYW5kbGVycy5vblJlbW92ZSkge1xuICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0IGVudGl0aWVzID0gY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5nZXRFbnRpdGllc10od29ybGQpIGFzIE1hcDxFbnRpdHlJZCwgRW50aXR5PENUPj47XG5cbiAgICAgICAgICB0cmFja2VkRXZlbnRIYW5kbGVycy5vblJlbW92ZSh7IGNvbXBvbmVudCwgd29ybGQsIGVudGl0eSwgZW50aXRpZXMgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgUHJveHkoXG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgY3JlYXRlQ2xhc3NJbnN0YW5jZVByb3h5SGFuZGxlcnModHJhY2tlZEV2ZW50SGFuZGxlcnMpXG4gICAgICApO1xuICAgIH0sXG4gIH0pO1xufVxuIiwiaW1wb3J0IEVudGl0eSwgeyBFbnRpdHlJZCB9IGZyb20gXCIuL0VudGl0eVwiO1xuaW1wb3J0IENvbXBvbmVudENvbGxlY3Rpb24gZnJvbSBcIi4vQ29tcG9uZW50Q29sbGVjdGlvblwiO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSBcIi4vVGFnXCI7XG5pbXBvcnQgeyBTeXN0ZW1GdW5jIH0gZnJvbSBcIi4vU3lzdGVtc1wiO1xuaW1wb3J0IERldlRvb2xzIGZyb20gXCIuL0RldlRvb2xzXCI7XG5pbXBvcnQgU3lzdGVtcyBmcm9tICcuL1N5c3RlbXMnO1xuaW1wb3J0IHsgVHJhY2tlZENvbXBTeW1ib2xLZXlzIH0gZnJvbSAnLi9UcmFja2VkQ29tcG9uZW50JztcblxuZXhwb3J0IHR5cGUgQ2xhc3NDb25zdHJ1Y3RvcjxUPiA9IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQgfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV29ybGQ8Q1Q+IHtcbiAgY29tcG9uZW50Q29sbGVjdGlvbnM6IE1hcDxFbnRpdHlJZCwgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4+ID0gbmV3IE1hcCgpO1xuXG4gIGVudGl0aWVzOiBNYXA8RW50aXR5SWQsIEVudGl0eTxDVD4+ID0gbmV3IE1hcCgpO1xuXG4gIGVudGl0aWVzQnlDVHlwZXM6IE1hcDxzdHJpbmdbXSwgU2V0PEVudGl0eUlkPj4gPSBuZXcgTWFwKCk7XG5cbiAgZW50aXRpZXNCeVRhZ3M6IE1hcDxUYWcsIFNldDxFbnRpdHlJZD4+ID0gbmV3IE1hcCgpO1xuXG4gIHN5c3RlbXM6IFN5c3RlbXM8Q1Q+O1xuXG4gIGRldjogRGV2VG9vbHM8Q1Q+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGV2ID0gbmV3IERldlRvb2xzKHRoaXMpO1xuICAgIHRoaXMuc3lzdGVtcyA9IG5ldyBTeXN0ZW1zKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiZmluZHNcIiBhIHNpbmdsZSBlbnRpdHkgYmFzZWQgb24gYSBwcmVkaWNhdGVcbiAgICovXG4gIGZpbmQgPSAocHJlZGljYXRlOiAoZW50aXR5OiBFbnRpdHk8Q1Q+KSA9PiBib29sZWFuKTogRW50aXR5PENUPiB8IG51bGwgPT4ge1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoZW50aXR5KSkge1xuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBcImZpbmRzXCIgYWxsIGVudGl0aWVzIGJhc2VkIG9uIGEgcHJlZGljYXRlLCBraW5kYSBsaWtlIGZpbHRlci5cbiAgICovXG4gIGZpbmRBbGwgPSAocHJlZGljYXRlOiAoZW50aXR5OiBFbnRpdHk8Q1Q+KSA9PiBib29sZWFuKTogRW50aXR5PENUPltdID0+IHtcbiAgICBjb25zdCByZXN1bHRzOiBFbnRpdHk8Q1Q+W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoZW50aXR5KSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvKipcbiAgICogXCJsb2NhdGVzXCIgYSBzaW5nbGUgZW50aXR5IGJhc2VkIG9uIGl0cyBDb21wb25lbnRzLlxuICAgKi9cbiAgbG9jYXRlID0gKGNsOiBDbGFzc0NvbnN0cnVjdG9yPENUPiB8IENsYXNzQ29uc3RydWN0b3I8Q1Q+W10pOiBFbnRpdHk8Q1Q+IHwgbnVsbCA9PiB7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVudGl0eS5jb21wb25lbnRzLmhhcyhjbCkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogTG9jYXRlcyBhbGwgZW50aXRpZXMgdGhhdCBjb250YWluIHRoZSBjb21wb25lbnRzIG5hbWVkXG4gICAqL1xuICBsb2NhdGVBbGwgPSAoY2w6IENsYXNzQ29uc3RydWN0b3I8Q1Q+IHwgQ2xhc3NDb25zdHJ1Y3RvcjxDVD5bXSk6IEVudGl0eTxDVD5bXSA9PiB7XG4gICAgY29uc3QgcmVzdWx0czogRW50aXR5PENUPltdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZW50aXR5LmNvbXBvbmVudHMuaGFzKGNsKSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvKipcbiAgICogR3JhYnMgdGhlIGZpcnN0IGVudGl0eSwgYW5kIGl0cyByZWxhdGVkIGNvbXBvbmVudCwgdGhhdCBtYXRjaGVzIHRoZSBjb21wb25lbnQgdHlwZS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIGNvbnN0IHsgZW50aXR5LCBjb21wb25lbnQgfSA9IHdvcmxkLmdyYWIoTXlDb21wb25lbnQpO1xuICAgKiBgYGBcbiAgICovXG4gIGdyYWIgPSA8VCBleHRlbmRzIENUPihcbiAgICBjbDogQ2xhc3NDb25zdHJ1Y3RvcjxUPlxuICApOiB7IGVudGl0eTogRW50aXR5PENUPjsgY29tcG9uZW50OiBUIH0gfCBudWxsID0+IHtcbiAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmxvY2F0ZShjbCk7XG5cbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBjb25zdCBjYyA9XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZ2V0KGVudGl0eS5pZCkgfHxcbiAgICAgICAgbmV3IENvbXBvbmVudENvbGxlY3Rpb248Q1Q+KCk7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNjLmdldDxUPihjbCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudGl0eSxcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR3JhYiBzaW5nbGUgY29tcG9uZW50IGJhc2VkIG9uIGNvbXBvbmVudCB0eXBlIGFuZCBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgeyBlbnRpdHksIGNvbXBvbmVudCB9ID0gd29ybGQuZ3JhYkJ5KEZpcnN0Q29tcG9uZW50LCAoY29tcCkgPT4gY29tcC5pZCA9PSAnYXdlc29tZScpXG4gICAqIGBgYFxuICAgKi9cbiAgZ3JhYkJ5ID0gPFQgZXh0ZW5kcyBDVD4oXG4gICAgY2w6IENsYXNzQ29uc3RydWN0b3I8VD4sXG4gICAgcHJlZGljYXRlOiAoY29tcDogVCkgPT4gYm9vbGVhblxuICApOiB7IGVudGl0eTogRW50aXR5PENUPjsgY29tcG9uZW50OiBUIH0gfCBudWxsID0+IHtcbiAgICBjb25zdCBlbnRpdGllcyA9IHRoaXMubG9jYXRlQWxsKGNsKTtcbiAgICAvLyBjb25zdCBlbnRpdGllcyA9IHRoaXMubG9jYXRlQWxsKChjbCBhcyB1bmtub3duKSBhcyBDVCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgY2MgPVxuICAgICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlbnRpdHkuaWQpIHx8XG4gICAgICAgIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgICBjb25zdCBjb21wb25lbnQgPSBjYy5nZXQ8VD4oY2wpO1xuXG4gICAgICBpZiAocHJlZGljYXRlKGNvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgZW50aXR5LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHcmFiIGFsbCB0aGUgY29tcG9uZW50cyBwcmltYXJpbHksIGFuZCB0aGUgZW50aXRpZXMgaWYgbmVlZGVkXG4gICAqL1xuICBncmFiQWxsID0gPFQgZXh0ZW5kcyBDVD4oXG4gICAgY2w6IENsYXNzQ29uc3RydWN0b3I8VD5cbiAgKTogeyBlbnRpdHk6IEVudGl0eTxDVD47IGNvbXBvbmVudDogVCB9W10gPT4ge1xuICAgIGNvbnN0IGVudGl0aWVzID0gdGhpcy5sb2NhdGVBbGwoY2wpO1xuXG4gICAgcmV0dXJuIGVudGl0aWVzLm1hcCgoZW50aXR5KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbnRpdHksXG4gICAgICAgIGNvbXBvbmVudDogZW50aXR5LmNvbXBvbmVudHMuZ2V0PFQ+KGNsKSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETzogQWRkIGdyYWJBbGxCeSBtZXRob2RcblxuICAvKipcbiAgICogR2l2ZW4gYW4gZW50aXR5IGlkIGFuZCBjb21wb25lbnRUeXBlLCByZXR1cm5zIGNvbXBvbmVudFxuICAgKi9cbiAgZ2V0ID0gPFQgZXh0ZW5kcyBDVD4oZWlkOiBFbnRpdHlJZCwgY2w6IENsYXNzQ29uc3RydWN0b3I8VD4pOiBUID0+IHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgcmV0dXJuIGNjLmdldDxUPihjbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgYW5kIGdldCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQsIHdpdGhvdXQgYW55IGFzc29jaWF0ZWQgZW50aXRpZXMuXG4gICAqIEhlbHBmdWwgaXMgeW91IGtub3cgdGhhdCBvbmx5IG9uZSBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBleGlzdHMgYWNyb3NzIGFsbCBlbnRpdGllcy5cbiAgICogQHBhcmFtIGNsIENvbXBvbmVudCBDbGFzcyBDb250cnVjdG9yXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQSBkZWZhdWx0IGNvbXBvbmVudCBpbnN0YW5jZSBpZiBubyBjb21wb25lbnRzIGFyZSBmb3VuZC5cbiAgICovXG4gIGdldENvbXBvbmVudCA9IDxUIGV4dGVuZHMgQ1Q+KFxuICAgIGNsOiBDbGFzc0NvbnN0cnVjdG9yPFQ+LFxuICAgIGRlZmF1bHRWYWx1ZT86IFRcbiAgKTogVCB8IG51bGwgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ3JhYihjbCk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSA/IGRlZmF1bHRWYWx1ZSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5jb21wb25lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBlbnRpdHkgdGhhdCBoYXMgYmVlbiB0YWdnZWQgd2l0aCB0aGUgZ2l2ZW4gdGFnLCBvciByZXR1cm4gbnVsbDtcbiAgICovXG4gIGdldFRhZ2dlZCA9ICh0YWc6IFRhZyk6IEVudGl0eTxDVD4gfCBudWxsID0+IHtcbiAgICBjb25zdCB0YWdFbnRpdHlJZHMgPSB0aGlzLmVudGl0aWVzQnlUYWdzLmdldCh0YWcpO1xuXG4gICAgaWYgKHRhZ0VudGl0eUlkcykge1xuICAgICAgY29uc3QgZW50aXR5SWQgPSB0YWdFbnRpdHlJZHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG5cbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0dCBhbGwgZW50aXRpZXMgdGhhdCBoYXZlIGJlZW4gdGFnZ2VkIHdpdGggdGhlIGdpdmVuIHRhZy5cbiAgICogQHBhcmFtIHRhZyBBIHN0cmluZyBvciBudW1iZXIuXG4gICAqL1xuICBnZXRBbGxUYWdnZWQgPSAodGFnOiBUYWcpOiBFbnRpdHk8Q1Q+W10gPT4ge1xuICAgIGxldCBlbnRpdGllczogRW50aXR5PENUPltdID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNvbnN0IHRhZ0VudGl0eUlkcyA9IHRoaXMuZW50aXRpZXNCeVRhZ3MuZ2V0KHRhZyk7XG5cbiAgICBpZiAodGFnRW50aXR5SWRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIHRhZ0VudGl0eUlkcykge1xuICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG4gICAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW50aXRpZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNvbXBvbmVudCBvbiB0aGUgZ2l2ZW4gZW50aXR5XG4gICAqL1xuICBhZGQgPSA8VCBleHRlbmRzIENUPihlaWQ6IEVudGl0eUlkLCBjb21wb25lbnQ6IFQpOiB0aGlzID0+IHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgY29uc3QgZW50aXR5ID0gdGhpcy5lbnRpdGllcy5nZXQoZWlkKTtcblxuICAgIGlmICghZW50aXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHdvcmxkLmFkZDogVW5hYmxlIHRvIGxvY2F0ZSBlbnRpdHkgd2l0aCBpZCAke2VpZH1gKTtcbiAgICB9XG5cbiAgICBjYy5hZGQoY29tcG9uZW50KTtcblxuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVpZCwgY2MpO1xuXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5hZGQoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMuaXNUcmFja2VkXSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5zZXRXb3JsZF0odGhpcyk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmVudGl0eUlEc10uYWRkKGVpZCk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLm9uQWRkXSh0aGlzLCBlbnRpdHkpO1xuICAgIH1cblxuICAgIGVudGl0eS5vbkNvbXBvbmVudEFkZCh7IHdvcmxkOiB0aGlzLCBjb21wb25lbnQgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgY29tcG9uZW50IGZyb20gdGhlIGdpdmVuIGVudGl0eS5cbiAgICogTk9URTogVGhpcyB3aWxsIGNoYW5nZSB3aGF0IHN5c3RlbXMgd2lsbCBiZSBjYWxsZWQgb24gdGhlIGVudGl0eS5cbiAgICovXG4gIHJlbW92ZSA9IChlaWQ6IEVudGl0eUlkLCBjVHlwZTogQ2xhc3NDb25zdHJ1Y3RvcjxDVD4pOiB0aGlzID0+IHtcbiAgICBjb25zdCBjYyA9XG4gICAgICB0aGlzLmNvbXBvbmVudENvbGxlY3Rpb25zLmdldChlaWQpIHx8IG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpO1xuXG4gICAgLy8gbmVlZCB0byBnZXQgY29tcG9uZW50IGluc3RhbmNlLi4uXG4gICAgY29uc3QgY29tcG9uZW50ID0gY2MuZ2V0KGNUeXBlKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoY29tcG9uZW50W1RyYWNrZWRDb21wU3ltYm9sS2V5cy5pc1RyYWNrZWRdKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlaWQpO1xuXG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdvcmxkLnJlbW92ZTogVW5hYmxlIHRvIGxvY2F0ZSBlbnRpdHkuIGVpZDogJHtlaWR9LCBjVHlwZTogJHtjVHlwZS5uYW1lfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb21wb25lbnRbVHJhY2tlZENvbXBTeW1ib2xLZXlzLmVudGl0eUlEc10uZGVsZXRlKGVpZCk7XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbXBvbmVudFtUcmFja2VkQ29tcFN5bWJvbEtleXMub25SZW1vdmVdKHRoaXMsIGVudGl0eSk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGVudGl0eSBmcm9tIGN1cnJlbnQgZW50aXRpZXNCeUNUeXBlc1xuICAgIGZvciAoY29uc3QgW2N0QXJyLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcykge1xuICAgICAgaWYgKChjdEFyciBhcyBzdHJpbmdbXSkuZXZlcnkoY2MuaGFzQnlOYW1lKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2MucmVtb3ZlKGNUeXBlKTtcblxuICAgIC8vIE1vdmUgZW50aXR5SWQgdG8gbmV3IENUeXBlcyBpZiBuZWVkZWQuXG4gICAgZm9yIChjb25zdCBbY3RBcnIsIGVudGl0eVNldF0gb2YgdGhpcy5lbnRpdGllc0J5Q1R5cGVzKSB7XG4gICAgICBpZiAoKGN0QXJyIGFzIHN0cmluZ1tdKS5ldmVyeShjYy5oYXNCeU5hbWUpKSB7XG4gICAgICAgIGVudGl0eVNldC5hZGQoZWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlaWQpO1xuICAgIGlmIChlbnRpdHkpIHtcbiAgICAgIGVudGl0eS5vbkNvbXBvbmVudFJlbW92ZSh7IHdvcmxkOiB0aGlzLCBjb21wb25lbnQgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsdGVybmF0aXZlIG1ldGhvZCBmb3IgYWRkaW5nIHN5c3RlbXMuXG4gICAqL1xuICBhZGRTeXN0ZW0oY1R5cGVzOiBDbGFzc0NvbnN0cnVjdG9yPENUPltdLCBzeXN0ZW1GdW5jOiBTeXN0ZW1GdW5jPENUPiwgZnVuY05hbWU/OiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnN5c3RlbXMuYWRkKGNUeXBlcywgc3lzdGVtRnVuYywgZnVuY05hbWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTZXR1cCBhbiBlbnRpdHkgdG8gZXhpc3QgaW4gdGhlIGdpdmVuIHdvcmxkLiBUaGlzIGlzIG1vc3RseSBhbiBpbnRlcm5hbCBtZXRob2QsIGJ1dCBleHBvc2VkIGp1c3QgaW4gY2FzZS5cbiAgICovXG4gIHJlZ2lzdGVyRW50aXR5KGVudGl0eTogRW50aXR5PENUPik6IFdvcmxkPENUPiB7XG4gICAgY29uc3QgY2MgPSBuZXcgQ29tcG9uZW50Q29sbGVjdGlvbjxDVD4oKTtcblxuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuc2V0KGVudGl0eS5pZCwgY2MpO1xuICAgIHRoaXMuZW50aXRpZXMuc2V0KGVudGl0eS5pZCwgZW50aXR5KTtcblxuICAgIGVudGl0eS5vbkNyZWF0ZSh0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgY29tcG9uZW50cyB0aGF0IGJlbG9uZyB0byBhbiBlbnRpdHkuXG4gICAqL1xuICBjbGVhckVudGl0eUNvbXBvbmVudHMoZW50aXR5SWQ6IEVudGl0eUlkKTogdGhpcyB7XG4gICAgdGhpcy5jb21wb25lbnRDb2xsZWN0aW9ucy5zZXQoZW50aXR5SWQsIG5ldyBDb21wb25lbnRDb2xsZWN0aW9uPENUPigpKTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5U2V0IG9mIHRoaXMuZW50aXRpZXNCeUNUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVudGl0eVNldC5oYXMoZW50aXR5SWQpKSB7XG4gICAgICAgIGVudGl0eVNldC5kZWxldGUoZW50aXR5SWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlbnRpdHkgdGhhdCBpcyBpbiB0aGUgd29ybGQuXG4gICAqIEJhc2ljYWxseSBqdXN0IG5ldyBFbnRpdHkod29ybGQpLCBidXQgc2F2ZXMgYW4gaW1wb3J0IG9mIEVudGl0eS5cbiAgICovXG4gIGNyZWF0ZUVudGl0eSgpOiBFbnRpdHk8Q1Q+IHtcbiAgICBjb25zdCBlbnRpdHkgPSBuZXcgRW50aXR5KHRoaXMpO1xuXG4gICAgcmV0dXJuIGVudGl0eTtcblxuICAgIC8vIFJlZ2lzdGVyIGVudGl0eSBoZXJlLi4uLlxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFuIGVudGl0eS5cbiAgICogU2FtZSBhcyBlbnRpdHkuZGVzdHJveSgpLlxuICAgKi9cbiAgZGVzdHJveUVudGl0eShlbnRpdHlJZDogRW50aXR5SWQpOiBXb3JsZDxDVD4ge1xuICAgIHRoaXMuY29tcG9uZW50Q29sbGVjdGlvbnMuZGVsZXRlKGVudGl0eUlkKTtcbiAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG5cbiAgICBpZiAoIWVudGl0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB3b3JsZC5kZXN0cm95RW50aXR5OiBObyBlbnRpdHkgZm91bmQuIGVudGl0eSBpZDogJHtlbnRpdHlJZH1gKTtcbiAgICB9XG5cbiAgICB0aGlzLmVudGl0aWVzLmRlbGV0ZShlbnRpdHlJZCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eVNldCBvZiB0aGlzLmVudGl0aWVzQnlDVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVudGl0eUlkKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVudGl0eUlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYW55IHRhZyBhc3NvY2lhdGlvbnMgd2l0aCBkZXN0cm95ZWQgZW50aXRpZXMuXG4gICAgZm9yIChjb25zdCBbdGFnLCBlbnRpdHlTZXRdIG9mIHRoaXMuZW50aXRpZXNCeVRhZ3MpIHtcbiAgICAgIGlmIChlbnRpdHlTZXQuaGFzKGVudGl0eUlkKSkge1xuICAgICAgICBlbnRpdHlTZXQuZGVsZXRlKGVudGl0eUlkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVudGl0eVNldC5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW50aXRpZXNCeVRhZ3MuZGVsZXRlKHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKlxuICBUT0RPOiB3b3JsZC5kZXN0cm95KCkgYW5kIHdvcmxkLmRlc3Ryb3lJbW1lZGlhdGVseSgpIG1ldGhvZHMuXG4gICovXG59XG4iLCJpbXBvcnQgV29ybGQgZnJvbSAnLi9Xb3JsZCc7XG5pbXBvcnQgeyB0cmFja0NvbXBvbmVudCB9IGZyb20gJy4vVHJhY2tlZENvbXBvbmVudCc7XG5cbmV4cG9ydCB7XG4gIFdvcmxkLFxuICB0cmFja0NvbXBvbmVudCxcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')}])}));