{
  "version": 3,
  "sources": ["../src/guards.ts", "../src/ComponentCollection.ts", "../src/DevEntity.ts", "../src/SimpleFSM.ts", "../src/BitSet.ts", "../src/Entity.ts", "../src/DevTools.ts", "../src/Systems.ts", "../src/TrackedComponent.ts", "../src/EventManager.ts", "../src/ComponentRegistry.ts", "../src/World.ts"],
  "sourcesContent": ["export function isComponentInstance<T>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, no-unused-vars\n  Class: new (...args: any) => T,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  comp: any\n): comp is InstanceType<typeof Class> {\n  if (!comp) {\n    return false;\n  }\n\n  if (!(comp instanceof Class)) {\n    return false;\n  }\n\n  return true;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { isComponentInstance } from './guards';\n\ntype CompName = string;\n// eslint-disable-next-line no-unused-vars\ntype ClassConstructor<T> = { new (...args: any[]): T };\n\n// CT is a Union, like `type = FirstComponent | SecondComponent`.\nexport default class ComponentCollection<CT> {\n  components: Map<CompName, CT> = new Map();\n\n  // instance of a component\n  add = (component: CT): void => {\n    this.components.set((<any>component).constructor.name, component);\n  };\n\n  // eslint-disable-next-line no-unused-vars\n  update = <T extends CT>(cl: ClassConstructor<T>, func: (c: T) => T): void => {\n    const c = this.components.get(cl.name);\n\n    if (isComponentInstance(cl, c)) {\n      const updatedComponent = func(c);\n      this.components.set(cl.name, updatedComponent);\n    }\n  };\n\n  /**\n   * Remove a component.\n   * @param cType Class of component to remove.\n   */\n  remove = (cType: ClassConstructor<CT>): void => {\n    this.components.delete(cType.name);\n  };\n\n  /**\n   * Get a component that matches the passed class.\n   * Will throw an error if an instance of the given component\n   * doesn't exist in the collection, so if you don't know if it's safe\n   * to get a component, you should test with has() or hasByName() first.\n   * You have been warned.\n   * @param cl component Class reference.\n   */\n  get = <T extends CT>(cl: ClassConstructor<T>): T => {\n    const comp = this.components.get(cl.name);\n\n    if (isComponentInstance<T>(cl, comp)) {\n      return comp;\n    } else {\n      throw new Error(\n        `ComponentCollection does not have component of type ${cl.name}`\n      );\n    }\n  };\n\n  /**\n   * Test to see if the collection contains a specific Class or Classes.\n   * @param cType component Class, or array of component Classes.\n   */\n  has = (cType: ClassConstructor<CT> | ClassConstructor<CT>[]): boolean => {\n    return Array.isArray(cType)\n      ? cType.every(ct => this.components.has(ct.name) === true)\n      : this.components.has(cType.name);\n  };\n\n  /**\n   * Test to see if the collection contains at least one of the given Classes.\n   * @param cTypes array of component Classes.\n   */\n  hasSome = (cTypes: ClassConstructor<CT>[]): boolean => {\n    return cTypes.some(ct => this.components.has(ct.name) === true);\n  };\n\n  /**\n   * Test to see if the collection has a component instance based on a\n   * class name. Some build steps/minifiers will change the name of Classes,\n   * so it's usually best to pass in a MyClass.name instead of 'MyClass'.\n   * @param cName The name of a Class, or array of Class names.\n   */\n  hasByName = (cName: string | string[]): boolean => {\n    return Array.isArray(cName)\n      ? cName.every(ct => this.components.has(ct) === true)\n      : this.components.has(cName);\n  };\n\n  /**\n   * Get the component type names that are currently being used in the collection.\n   */\n  get componentTypes(): string[] {\n    return [...this.components.keys()];\n  }\n\n  /**\n   * Get the current number of components that are in the collection.\n   */\n  get size(): number {\n    return this.components.size;\n  }\n\n  /**\n   * Make ComponentCollection iterable by delegating to the internal Map's iterator.\n   * This allows for...of loops, spreading [...collection], and Array.from(collection).\n   */\n  [Symbol.iterator](): IterableIterator<CT> {\n    return this.components.values();\n  }\n\n  toDevComponents(): Record<string, CT> {\n    const obj: Record<string, CT> = {};\n    for (const [compName, comp] of this.components) {\n      obj[compName] = comp;\n    }\n\n    return obj;\n  }\n}\n", "import { EntityState } from './Entity';\nimport World from './World';\nimport Entity, { EntityId } from './Entity';\nimport { Tag } from './Tag';\n\ninterface DevEntityTableRow {\n  id: EntityId;\n  components: string;\n  tags: string;\n  systems: string;\n}\n\nclass DevEntity<CT> {\n  id: EntityId;\n\n  components: Record<string, CT>;\n\n  tags: Tag[];\n\n  systems: string[] = [];\n\n  state: EntityState;\n\n  constructor(entity: Entity<CT>, world: World<CT>) {\n    this.id = entity.id;\n    this.components = entity.components.toDevComponents();\n    this.tags = [...entity.tags];\n    this.state = entity.state;\n\n    const compNames = Object.keys(this.components);\n\n    for (const [systemName, cNames] of world.systems.compNamesBySystemName) {\n      if (cNames.every(cName => compNames.includes(cName))) {\n        this.systems.push(systemName);\n      }\n    }\n  }\n\n  toTableRow(): DevEntityTableRow {\n    return {\n      id: this.id,\n      components: Object.keys(this.components).join(', '),\n      tags: this.tags.join(', '),\n      systems: this.systems.join(', '),\n    };\n  }\n}\n\nexport default DevEntity;\n", "export type State = string | number | symbol;\n\nexport type Transitions<S extends State, D = undefined> = Record<\n  S,\n  // eslint-disable-next-line no-unused-vars\n  (data: D, current: S) => S\n>;\n\nexport default class SimpleFSM<S extends State, D = undefined> {\n  current: S;\n\n  inital: S;\n\n  transitions: Transitions<S, D>;\n\n  constructor(initialState: S, transitions: Transitions<S, D>) {\n    this.inital = initialState;\n    this.current = initialState;\n    this.transitions = transitions;\n  }\n\n  next(data: D): void {\n    if (this.transitions[this.current]) {\n      this.current = this.transitions[this.current](data, this.current);\n    }\n  }\n\n  reset(): void {\n    this.current = this.inital;\n  }\n\n  is(checkState: S): boolean {\n    return this.current === checkState;\n  }\n}\n", "export class BitSet {\n  mask: Uint32Array;\n  size: number;\n\n  constructor(size: number = 1) {\n    this.size = size;\n    this.mask = new Uint32Array(size);\n  }\n\n  /**\n   * Sets the bit at the given index to 1.\n   * Automatically resizes if the index is out of bounds.\n   */\n  set(index: number): void {\n    const elementIndex = Math.floor(index / 32);\n    const bitIndex = index % 32;\n\n    if (elementIndex >= this.mask.length) {\n      this.resize(elementIndex + 1);\n    }\n\n    this.mask[elementIndex] |= 1 << bitIndex;\n  }\n\n  /**\n   * Sets the bit at the given index to 0.\n   */\n  clear(index: number): void {\n    const elementIndex = Math.floor(index / 32);\n    const bitIndex = index % 32;\n\n    if (elementIndex < this.mask.length) {\n      this.mask[elementIndex] &= ~(1 << bitIndex);\n    }\n  }\n\n  /**\n   * Resizes the underlying array to the new size.\n   */\n  private resize(newSize: number): void {\n    const newMask = new Uint32Array(newSize);\n    newMask.set(this.mask);\n    this.mask = newMask;\n    this.size = newSize;\n  }\n\n  /**\n   * Checks if this BitSet contains all bits set in the other BitSet.\n   * Ideally used to check if an Entity (this) has all components required by a System (other).\n   */\n  contains(other: BitSet): boolean {\n    const len = other.mask.length;\n    // If the system mask is larger than the entity mask, and the extra bits are set, it can't match.\n    // However, we handle resizing on set, so usually entity mask grows larger than system masks.\n\n    for (let i = 0; i < len; i++) {\n      const otherChunk = other.mask[i];\n      // If other has bits set that this doesn't have:\n      if ((this.mask[i] & otherChunk) !== otherChunk) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Generates a unique string key for Map lookups.\n   */\n  toString(): string {\n    return this.mask.join('-');\n  }\n\n  /**\n   * Creates a copy of the BitSet.\n   */\n  clone(): BitSet {\n    const clone = new BitSet(this.size);\n    clone.mask.set(this.mask);\n    return clone;\n  }\n}\n", "import World, { ClassConstructor } from './World';\nimport ComponentCollection from './ComponentCollection';\nimport { Tag } from './Tag';\nimport DevEntity from './DevEntity';\nimport SimpleFSM from './SimpleFSM';\nimport { BitSet } from './BitSet';\n\nexport type EntityId = number;\n\nexport type EntityState =\n  | 'creating'\n  | 'created'\n  | 'destroying'\n  | 'destroyed'\n  | 'error';\n\nexport interface EntityCompEventArgs<CT> {\n  world: World<CT>;\n  component: CT;\n}\n\nexport interface ComponentLifecycleEventArgs<CT> {\n  world: World<CT>;\n  entity: Entity<CT>;\n  component: CT;\n}\n\nexport default class Entity<CT> {\n  private _id: EntityId;\n  private _world: World<CT>;\n  private _componentMask: BitSet;\n  private _error: Error | null;\n  private _state: SimpleFSM<EntityState, EntityState>;\n\n  get id(): EntityId {\n    return this._id;\n  }\n\n  get world(): World<CT> {\n    return this._world;\n  }\n\n  get componentMask(): BitSet {\n    return this._componentMask;\n  }\n\n  get state(): EntityState {\n    return this._state.current;\n  }\n\n  constructor(world: World<CT>, id: EntityId) {\n    this._id = id;\n    this._world = world;\n    this._componentMask = new BitSet();\n\n    this._error = null;\n\n    const fsmTransition = (ns: EntityState): EntityState => {\n      if (ns === 'error' || this._error) return 'error';\n      return ns;\n    };\n\n    this._state = new SimpleFSM<EntityState, EntityState>('creating', {\n      creating: fsmTransition,\n      created: fsmTransition,\n      destroying: fsmTransition,\n      destroyed: () => 'destroyed',\n      error: () => 'error',\n    });\n\n    this._world.registerEntity(this);\n\n    if (this._world.systems.compNamesBySystemName.size === 0) {\n      this._state.next('created');\n    }\n  }\n\n  // ... lifecycle methods ...\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars\n  onCreate(world: World<CT>): void {\n    // abstract\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars\n  onDestroy(world: World<CT>): void {\n    // abstract\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars\n  onComponentAdd(args: EntityCompEventArgs<CT>): void {\n    // abstract\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars\n  onTrackedComponentUpdate(args: EntityCompEventArgs<CT>): void {\n    // abstract\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars\n  onComponentRemove(args: EntityCompEventArgs<CT>): void {\n    // abstract\n  }\n\n  add<T extends CT>(component: T): this {\n    if (!component) {\n      throw new Error(`Entity.add: Component is null or undefined`);\n    }\n    this._world.add(this._id, component);\n    return this;\n  }\n\n  addTag(tag: Tag): this {\n    const entitySet = this._world.entitiesByTags.has(tag)\n      ? this._world.entitiesByTags.get(tag)\n      : new Set<EntityId>();\n\n    if (entitySet) {\n      entitySet.add(this._id);\n      this._world.entitiesByTags.set(tag, entitySet);\n    }\n\n    return this;\n  }\n\n  has<T extends CT>(cType: ClassConstructor<T>): boolean {\n    const cc =\n      this._world.componentCollections[this._id] ||\n      new ComponentCollection<CT>();\n\n    return cc.has(cType);\n  }\n\n  hasSome<T extends CT>(cTypes: ClassConstructor<T>[]): boolean {\n    const cc =\n      this._world.componentCollections[this._id] ||\n      new ComponentCollection<CT>();\n\n    return cc.hasSome(cTypes);\n  }\n\n  hasTag(tag: Tag): boolean {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n      if (entitySet) {\n        return entitySet.has(this._id);\n      }\n    }\n    return false;\n  }\n\n  get<T extends CT>(cl: ClassConstructor<T>): T {\n    const cc =\n      this._world.componentCollections[this._id] ||\n      new ComponentCollection<CT>();\n\n    return cc.get<T>(cl);\n  }\n\n  getAll(): ComponentCollection<CT> {\n    return (\n      this._world.componentCollections[this._id] ||\n      new ComponentCollection<CT>()\n    );\n  }\n\n  remove(cType: ClassConstructor<CT>): this {\n    this._world.remove(this._id, cType);\n    return this;\n  }\n\n  removeTag(tag: Tag): this {\n    if (this._world.entitiesByTags.has(tag)) {\n      const entitySet = this._world.entitiesByTags.get(tag);\n      if (entitySet) {\n        entitySet.delete(this._id);\n        if (entitySet.size === 0) {\n          this._world.entitiesByTags.delete(tag);\n        }\n      }\n    }\n    return this;\n  }\n\n  clear(): this {\n    this._world.clearEntityComponents(this._id);\n    this._componentMask = new BitSet();\n    return this;\n  }\n\n  clearTags(): this {\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      entitySet.delete(this._id);\n      if (entitySet.size === 0) {\n        this._world.entitiesByTags.delete(tag);\n      }\n    }\n    return this;\n  }\n\n  finishCreation(): void {\n    this._state.next('created');\n  }\n\n  destroy(): void {\n    if (this._world.systems.compNamesBySystemName.size === 0) {\n      this.destroyImmediately();\n      return;\n    }\n    this._state.next('destroying');\n    this._world.entitiesToDestroy.add(this);\n  }\n\n  destroyImmediately(): void {\n    this.onDestroy(this._world);\n    this._world.destroyEntity(this._id);\n    this._state.next('destroyed');\n  }\n\n  get components(): ComponentCollection<CT> {\n    return (\n      this._world.componentCollections[this._id] ||\n      new ComponentCollection<CT>()\n    );\n  }\n\n  get tags(): Set<Tag> {\n    const tags = new Set<Tag>();\n    for (const [tag, entitySet] of this._world.entitiesByTags.entries()) {\n      if (entitySet.has(this._id)) {\n        tags.add(tag);\n      }\n    }\n    return tags;\n  }\n\n  toDevEntity(): DevEntity<CT> {\n    return new DevEntity<CT>(this, this._world);\n  }\n}\n", "import World from './World';\nimport DevEntity from './DevEntity';\nimport Entity from './Entity';\n\ninterface DevSystemComps {\n  system: string;\n  components: string;\n}\n\nclass DevTools<CT> {\n  world: World<CT>;\n\n  constructor(world: World<CT>) {\n    this.world = world;\n  }\n\n  get systemComponents(): DevSystemComps[] {\n    const compsBySystems = [];\n\n    for (const [system, compNames] of this.world.systems\n      .compNamesBySystemName) {\n      compsBySystems.push({ system, components: compNames.join(', ') });\n    }\n\n    return compsBySystems;\n  }\n\n  get entities(): DevEntity<CT>[] {\n    // Filter out undefined holes in the array\n    return this.world.entities\n      .filter(e => e !== undefined)\n      .map(e => (e as Entity<CT>).toDevEntity());\n  }\n}\n\nexport default DevTools;\n", "import Entity, { EntityId } from './Entity';\nimport World, { ClassConstructor } from './World';\nimport ComponentCollection from './ComponentCollection';\n\n/**\n * Arguments that are passed into a System function on each iteration.\n */\nexport interface SystemFuncArgs<CT> {\n  /**\n   * The current entity being iterated.\n   */\n  entity: Entity<CT>;\n  /**\n   * The components that belong to the entity\n   */\n  components: ComponentCollection<CT>;\n  /**\n   * The World instance.\n   */\n  world: World<CT>;\n  /**\n   * The index of the entity in the current system execution.\n   */\n  index: number;\n  /**\n   * The total number of entities being processed by this system.\n   */\n  size: number;\n  /**\n   * Is the first entity to be iterated on this run of a system.\n   */\n  isFirst: boolean;\n  /**\n   * Is the last entity to be iterated on this run of a system.\n   */\n  isLast: boolean;\n  /**\n   * Delta time in milliseconds passed since the last frame.\n   */\n  dt: number;\n  /**\n   * Total time in milliseconds since the simulation started.\n   */\n  time: number;\n}\n\n/**\n * Function that is called when a system is run.\n */\n// eslint-disable-next-line no-unused-vars\nexport type SystemFunc<CT> = (sytemFuncArgs: SystemFuncArgs<CT>) => void;\n\nconst DEFAULT_PHASE = '__DEFAULT__';\n\ninterface SystemDef<CT> {\n  func: SystemFunc<CT>;\n  name: string;\n  key: string;\n  entities: Set<EntityId>; // Cached direct reference to the entity set\n}\n\nexport default class Systems<CT> {\n  world: World<CT>;\n  compNamesBySystemName: Map<string, string[]>;\n\n  private phases: Map<string, SystemDef<CT>[]> = new Map();\n  private phaseOrder: string[] = [\n    'Input',\n    'Logic',\n    'Events',\n    'Render',\n    'Cleanup',\n  ];\n\n  constructor(world: World<CT>) {\n    this.world = world;\n    this.compNamesBySystemName = new Map();\n    this.phases.set(DEFAULT_PHASE, []);\n  }\n\n  setPhaseOrder(order: string[]): void {\n    this.phaseOrder = order;\n  }\n\n  add(\n    cTypes: ClassConstructor<CT>[],\n    systemFunc: SystemFunc<CT>,\n    canonicalKey: string,\n    options: { phase?: string; name?: string } = {}\n  ): this {\n    const cNames = cTypes.map(ct => ct.name);\n    const { phase = DEFAULT_PHASE, name: optionName } = options;\n    const name = optionName || systemFunc.name || canonicalKey;\n\n    if (!this.phases.has(phase)) {\n      this.phases.set(phase, []);\n    }\n\n    // Cache the reference to the entities Set for this query.\n    // World.addSystem guarantees this query exists before calling Systems.add.\n    const query = this.world.systemQueries.get(canonicalKey);\n    if (!query) {\n      throw new Error(`System Query not found for key: ${canonicalKey}`);\n    }\n\n    this.phases.get(phase)?.push({\n      func: systemFunc,\n      name,\n      key: canonicalKey,\n      entities: query.entities, // Direct reference optimization\n    });\n\n    this.compNamesBySystemName.set(name, cNames);\n\n    // Move validation here (Setup time) instead of run() (Hot path)\n    this.validatePhases();\n\n    return this;\n  }\n\n  private validatePhases(): void {\n    const defaultPhaseSystems = this.phases.get(DEFAULT_PHASE) || [];\n    const hasDefaultPhaseSystems = defaultPhaseSystems.length > 0;\n    const hasNamedPhaseSystems = Array.from(this.phases.keys()).some(\n      key => key !== DEFAULT_PHASE && (this.phases.get(key)?.length ?? 0) > 0\n    );\n\n    if (hasDefaultPhaseSystems && hasNamedPhaseSystems) {\n      throw new Error(\n        'Ambiguous system execution order: Some systems are registered with a phase, while others are not. Please assign a phase to all systems if you intend to use execution phases.'\n      );\n    }\n  }\n\n  /**\n   * Runs all systems.\n   * @param args Optional time arguments.\n   */\n  run(args?: { dt?: number; time?: number }): void {\n    const dt = args?.dt ?? 16.666;\n    // eslint-disable-next-line no-undef\n    const time = args?.time ?? performance.now();\n\n    // Reuse arg object to reduce GC pressure\n    const systemArgs = {\n      entity: null as unknown as Entity<CT>,\n      components: null as unknown as ComponentCollection<CT>,\n      world: this.world,\n      index: 0,\n      size: 0,\n      isFirst: false,\n      isLast: false,\n      dt,\n      time,\n    };\n\n    // Determine active phases\n    const runOrder: string[] = [];\n\n    // Check if we are using default or named phases\n    const defaultPhase = this.phases.get(DEFAULT_PHASE);\n    if (defaultPhase && defaultPhase.length > 0) {\n      runOrder.push(DEFAULT_PHASE);\n    } else {\n      // Use configured order\n      for (const p of this.phaseOrder) {\n        runOrder.push(p);\n      }\n      // Add any custom phases not in order\n      for (const p of this.phases.keys()) {\n        if (p !== DEFAULT_PHASE && !this.phaseOrder.includes(p)) {\n          runOrder.push(p);\n        }\n      }\n    }\n\n    for (const phase of runOrder) {\n      const systemsInPhase = this.phases.get(phase);\n\n      // Run systems in this phase if any exist\n      if (systemsInPhase && systemsInPhase.length > 0) {\n        for (const system of systemsInPhase) {\n          const entityIdSet = system.entities;\n          const size = entityIdSet.size;\n\n          if (size === 0) continue;\n\n          let index = 0;\n          systemArgs.size = size;\n\n          for (const eid of entityIdSet) {\n            const entity = this.world.entities[eid];\n\n            // Fast check for holes, destroyed entities, or entities not yet created\n            // ALLOW entities in 'creating' and 'destroying' states to process for one frame\n            if (\n              !entity ||\n              (entity.state !== 'created' &&\n                entity.state !== 'creating' &&\n                entity.state !== 'destroying')\n            )\n              continue;\n\n            const components = this.world.componentCollections[eid];\n\n            // Safety check (should theoretically never happen if logic is sound)\n            if (!components) continue;\n\n            systemArgs.entity = entity;\n            systemArgs.components = components;\n            systemArgs.index = index;\n            systemArgs.isFirst = index === 0;\n            systemArgs.isLast = index + 1 === size;\n\n            system.func(systemArgs);\n\n            index++;\n          }\n        }\n      }\n\n      // Always process events for this phase, even if no systems ran\n      // This is important for phases that only have event listeners (e.g. 'Events' phase)\n      this.world.events.processQueueForPhase(phase);\n    }\n\n    // Entity Lifecycle (Create)\n    if (this.world.entitiesToCreate.size > 0) {\n      for (const entity of this.world.entitiesToCreate) {\n        entity.finishCreation();\n      }\n      this.world.entitiesToCreate.clear();\n    }\n\n    // Entity Lifecycle (Destroy)\n    if (this.world.entitiesToDestroy.size > 0) {\n      for (const entity of this.world.entitiesToDestroy) {\n        entity.destroyImmediately();\n      }\n      this.world.entitiesToDestroy.clear();\n    }\n\n    this.world.events.clearQueue();\n  }\n}\n\n// import Entity, { EntityId } from './Entity';\n// import World, { ClassConstructor } from './World';\n// import ComponentCollection from './ComponentCollection';\n\n// /**\n//  * Arguments that are passed into a System function on each iteration.\n//  */\n// export interface SystemFuncArgs<CT> {\n//   /**\n//    * The current entity being iterated.\n//    */\n//   entity: Entity<CT>;\n//   /**\n//    * The components that belong to the entity\n//    */\n//   components: ComponentCollection<CT>;\n//   /**\n//    * The World instance.\n//    */\n//   world: World<CT>;\n//   /**\n//    * The index of the entity in the current system execution.\n//    */\n//   index: number;\n//   /**\n//    * The total number of entities being processed by this system.\n//    */\n//   size: number;\n//   /**\n//    * Is the first entity to be iterated on this run of a system.\n//    */\n//   isFirst: boolean;\n//   /**\n//    * Is the last entity to be iterated on this run of a system.\n//    */\n//   isLast: boolean;\n//   /**\n//    * Delta time in milliseconds passed since the last frame.\n//    */\n//   dt: number;\n//   /**\n//    * Total time in milliseconds since the simulation started.\n//    */\n//   time: number;\n// }\n\n// /**\n//  * Function that is called when a system is run.\n//  */\n// // eslint-disable-next-line no-unused-vars\n// export type SystemFunc<CT> = (sytemFuncArgs: SystemFuncArgs<CT>) => void;\n\n// const DEFAULT_PHASE = '__DEFAULT__';\n\n// interface SystemDef<CT> {\n//   func: SystemFunc<CT>;\n//   name: string;\n//   key: string;\n//   entities: Set<EntityId>; // Cached direct reference to the entity set\n// }\n\n// export default class Systems<CT> {\n//   world: World<CT>;\n//   compNamesBySystemName: Map<string, string[]>;\n\n//   private phases: Map<string, SystemDef<CT>[]> = new Map();\n//   private phaseOrder: string[] = [\n//     'Input',\n//     'Logic',\n//     'Events',\n//     'Render',\n//     'Cleanup',\n//   ];\n\n//   constructor(world: World<CT>) {\n//     this.world = world;\n//     this.compNamesBySystemName = new Map();\n//     this.phases.set(DEFAULT_PHASE, []);\n//   }\n\n//   setPhaseOrder(order: string[]): void {\n//     this.phaseOrder = order;\n//   }\n\n//   add(\n//     cTypes: ClassConstructor<CT>[],\n//     systemFunc: SystemFunc<CT>,\n//     canonicalKey: string,\n//     options: { phase?: string; name?: string } = {}\n//   ): this {\n//     const cNames = cTypes.map(ct => ct.name);\n//     const { phase = DEFAULT_PHASE, name: optionName } = options;\n//     const name = optionName || systemFunc.name || canonicalKey;\n\n//     if (!this.phases.has(phase)) {\n//       this.phases.set(phase, []);\n//     }\n\n//     // Cache the reference to the entities Set for this query.\n//     // World.addSystem guarantees this query exists before calling Systems.add.\n//     const query = this.world.systemQueries.get(canonicalKey);\n//     if (!query) {\n//       throw new Error(`System Query not found for key: ${canonicalKey}`);\n//     }\n\n//     this.phases.get(phase)?.push({\n//       func: systemFunc,\n//       name,\n//       key: canonicalKey,\n//       entities: query.entities, // Direct reference optimization\n//     });\n\n//     this.compNamesBySystemName.set(name, cNames);\n\n//     // Move validation here (Setup time) instead of run() (Hot path)\n//     this.validatePhases();\n\n//     return this;\n//   }\n\n//   private validatePhases(): void {\n//     const defaultPhaseSystems = this.phases.get(DEFAULT_PHASE) || [];\n//     const hasDefaultPhaseSystems = defaultPhaseSystems.length > 0;\n//     const hasNamedPhaseSystems = Array.from(this.phases.keys()).some(\n//       key => key !== DEFAULT_PHASE && (this.phases.get(key)?.length ?? 0) > 0\n//     );\n\n//     if (hasDefaultPhaseSystems && hasNamedPhaseSystems) {\n//       throw new Error(\n//         'Ambiguous system execution order: Some systems are registered with a phase, while others are not. Please assign a phase to all systems if you intend to use execution phases.'\n//       );\n//     }\n//   }\n\n//   /**\n//    * Runs all systems.\n//    * @param args Optional time arguments.\n//    */\n//   run(args?: { dt?: number; time?: number }): void {\n//     const dt = args?.dt ?? 16.666;\n//     // eslint-disable-next-line no-undef\n//     const time = args?.time ?? performance.now();\n\n//     const systemArgs = {\n//       entity: null as unknown as Entity<CT>,\n//       components: null as unknown as ComponentCollection<CT>,\n//       world: this.world,\n//       index: 0,\n//       size: 0,\n//       isFirst: false,\n//       isLast: false,\n//       dt,\n//       time,\n//     };\n\n//     if (this.world.entitiesToCreate.size > 0) {\n//       for (const entity of this.world.entitiesToCreate) {\n//         entity.finishCreation();\n//       }\n//       this.world.entitiesToCreate.clear();\n//     }\n\n//     // Determine active phases\n//     const runOrder: string[] = [];\n\n//     // Check if we are using default or named phases\n//     const defaultPhase = this.phases.get(DEFAULT_PHASE);\n//     if (defaultPhase && defaultPhase.length > 0) {\n//       runOrder.push(DEFAULT_PHASE);\n//     } else {\n//       for (const p of this.phaseOrder) {\n//         runOrder.push(p);\n//       }\n//       // Add any custom phases not in order\n//       for (const p of this.phases.keys()) {\n//         if (p !== DEFAULT_PHASE && !this.phaseOrder.includes(p)) {\n//           runOrder.push(p);\n//         }\n//       }\n//     }\n\n//     for (const phase of runOrder) {\n//       const systemsInPhase = this.phases.get(phase);\n\n//       // Run systems in this phase if any exist\n//       if (systemsInPhase && systemsInPhase.length > 0) {\n//         for (const system of systemsInPhase) {\n//           const entityIdSet = system.entities;\n//           const size = entityIdSet.size;\n\n//           if (size === 0) continue;\n\n//           let index = 0;\n//           systemArgs.size = size;\n\n//           for (const eid of entityIdSet) {\n//             const entity = this.world.entities[eid];\n\n//             // Fast check for holes, destroyed entities, or entities not yet created\n//             if (\n//               !entity ||\n//               (entity.state !== 'created' && entity.state !== 'destroying')\n//             )\n//               continue;\n\n//             const components = this.world.componentCollections[eid];\n\n//             // Safety check (should theoretically never happen if logic is sound)\n//             if (!components) continue;\n\n//             systemArgs.entity = entity;\n//             systemArgs.components = components;\n//             systemArgs.index = index;\n//             systemArgs.isFirst = index === 0;\n//             systemArgs.isLast = index + 1 === size;\n\n//             system.func(systemArgs);\n\n//             index++;\n//           }\n//         }\n//       }\n\n//       // Always process events for this phase, even if no systems ran\n//       // This is important for phases that only have event listeners (e.g. 'Events' phase)\n//       this.world.events.processQueueForPhase(phase);\n//     }\n\n//     // Entity Lifecycle (Destroy)\n//     // if (this.world.entitiesToCreate.size > 0) {\n//     //   for (const entity of this.world.entitiesToCreate) {\n//     //     entity.finishCreation();\n//     //   }\n//     //   this.world.entitiesToCreate.clear();\n//     // }\n\n//     if (this.world.entitiesToDestroy.size > 0) {\n//       for (const entity of this.world.entitiesToDestroy) {\n//         entity.destroyImmediately();\n//       }\n//       this.world.entitiesToDestroy.clear();\n//     }\n//   }\n// }\n", "/* eslint-disable no-unused-vars */\nimport World, { ClassConstructor } from './World';\nimport Entity, { EntityId } from './Entity';\n\n// Waiting for Typescript 4.2 to come out so that Symbols are supporded keys.\nexport const TrackedCompSymbolKeys = {\n  isTracked: Symbol.for('ecs.trackedComponent.isTracked'),\n  world: Symbol.for('ecs.trackedComponent.world'),\n  entityIDs: Symbol.for('ecs.trackedComponent.entityIDs'),\n  getEntities: Symbol.for('ecs.trackedComponent.getEntities'),\n  setWorld: Symbol.for('ecs.trackedComponent.setWorld'),\n  onAdd: Symbol.for('ecs.trackedComponent.onAdd'),\n  onUpdate: Symbol.for('ecs.trackedComponent.onUpdate'),\n  onRemove: Symbol.for('ecs.trackedComponent.onRemove'),\n} as const;\n\n//@ts-ignore\ntype TrackedComponent<CT> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  new (...args: any[]): CT;\n\n  //@ts-ignore\n  [TrackedCompSymbolKeys.isTracked]: boolean;\n  //@ts-ignore\n  [TrackedCompSymbolKeys.setWorld]: (world: World<CT>) => void;\n  //@ts-ignore\n  [TrackedCompSymbolKeys.world]: World<CT>;\n  //@ts-ignore\n  [TrackedCompSymbolKeys.entityIDs]: Set<EntityId>;\n  //@ts-ignore\n  [TrackedCompSymbolKeys.getEntities]: () => Map<EntityId, Entity<CT>>;\n  //@ts-ignore\n  [TrackedCompSymbolKeys.onAdd]: (world: World<CT>, entity: Entity<CT>) => void;\n  //@ts-ignore\n  [TrackedCompSymbolKeys.onRemove]: (\n    world: World<CT>,\n    entity: Entity<CT>\n  ) => void;\n};\n\ninterface AddEventArgs<CT> {\n  world: World<CT>;\n  component: CT;\n  entity: Entity<CT>;\n  entities: Map<EntityId, Entity<CT>>;\n}\n\ninterface UpdateEventArgs<CT> {\n  entities: Map<EntityId, Entity<CT>>;\n  component: CT;\n  world: World<CT>;\n  previousVal: CT[keyof CT];\n  property: keyof CT;\n}\n\ninterface RemoveEventArgs<CT> {\n  world: World<CT>;\n  component: CT;\n  entity: Entity<CT>;\n  entities: Map<EntityId, Entity<CT>>;\n}\n\ninterface TrackedEventHandlers<CT> {\n  onAdd?: (args: AddEventArgs<CT>) => void;\n  onUpdate?: (args: UpdateEventArgs<CT>) => void;\n  onRemove?: (args: RemoveEventArgs<CT>) => void;\n}\n\n// NOTE: Really need to get symbols working as keys in Typescript.\n//       Until then will have to cast to keyof CT.\n// https://stackoverflow.com/questions/54324323/typescript-type-string-is-not-assignable-to-type-keyof\n// https://github.com/microsoft/TypeScript/pull/26797\nfunction createClassInstanceProxyHandlers<CT>(\n  trackedEventHandlers: TrackedEventHandlers<CT>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): ProxyHandler<any> {\n  const updatedProps = new Set();\n  return {\n    set(component: CT, property: string, value: CT[keyof CT]) {\n      updatedProps.add(property);\n\n      //@ts-ignore\n      const world = component[TrackedCompSymbolKeys.world] as World<CT>;\n\n      const previousVal = component[property as keyof CT];\n\n      component[property as keyof CT] = value;\n\n      //@ts-ignore\n      const entities = component[TrackedCompSymbolKeys.getEntities](\n        world\n      ) as Map<EntityId, Entity<CT>>;\n\n      for (const entity of entities.values()) {\n        entity.onTrackedComponentUpdate({ world, component });\n      }\n\n      if (trackedEventHandlers.onUpdate) {\n        trackedEventHandlers.onUpdate({\n          entities,\n          world,\n          component,\n          previousVal,\n          property: property as keyof CT,\n        });\n      }\n\n      return true;\n    },\n  };\n}\n\nexport function trackComponent<CT>(\n  CompClass: ClassConstructor<CT>,\n  trackedEventHandlers: TrackedEventHandlers<CT>\n): TrackedComponent<CT> {\n  return new Proxy(CompClass, {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    construct(Component: any, args: any) {\n      const component = new Component(...args) as CT & TrackedComponent<CT>;\n\n      // For use in identifing a \"tracked\" class through the proxy.\n      //@ts-ignore\n      component[TrackedCompSymbolKeys.isTracked] = true;\n\n      //@ts-ignore\n      component[TrackedCompSymbolKeys.setWorld] = (world: World<CT>) => {\n        //@ts-ignore\n        component[TrackedCompSymbolKeys.world] = world;\n      };\n\n      // Holds entities that this component has been added to.\n      // Added and removed in world.add()/world.remove().\n      //@ts-ignore\n      component[TrackedCompSymbolKeys.entityIDs] = new Set();\n\n      // Helper function to get the Entities from entityIDs\n      //@ts-ignore\n      component[TrackedCompSymbolKeys.getEntities] = (\n        world: World<CT>\n      ): Map<EntityId, Entity<CT>> => {\n        const entities = new Map<EntityId, Entity<CT>>();\n\n        //@ts-ignore\n        for (const eid of component[TrackedCompSymbolKeys.entityIDs]) {\n          const entity = world.entities[eid]; // Array lookup\n          if (entity) {\n            entities.set(eid, entity);\n          }\n        }\n\n        return entities;\n      };\n\n      //@ts-ignore\n      component[TrackedCompSymbolKeys.onAdd] = (\n        world: World<CT>,\n        entity: Entity<CT>\n      ) => {\n        if (trackedEventHandlers.onAdd) {\n          //@ts-ignore\n          const entities = component[TrackedCompSymbolKeys.getEntities](\n            world\n          ) as Map<EntityId, Entity<CT>>;\n\n          trackedEventHandlers.onAdd({ component, world, entity, entities });\n        }\n      };\n\n      //@ts-ignore\n      component[TrackedCompSymbolKeys.onRemove] = (\n        world: World<CT>,\n        entity: Entity<CT>\n      ) => {\n        if (trackedEventHandlers.onRemove) {\n          //@ts-ignore\n          const entities = component[TrackedCompSymbolKeys.getEntities](\n            world\n          ) as Map<EntityId, Entity<CT>>;\n\n          trackedEventHandlers.onRemove({ component, world, entity, entities });\n        }\n      };\n\n      return new Proxy(\n        component,\n        createClassInstanceProxyHandlers(trackedEventHandlers)\n      );\n    },\n  });\n}\n", "import World, { ClassConstructor } from './World';\n\n/**\n * Arguments passed to an event listener function.\n */\nexport interface EventListenerArgs<E, CT> {\n  /** The event instance that was emitted. */\n  event: E;\n  /** A reference to the world. */\n  world: World<CT>;\n}\n\n/**\n * The function signature for an event listener.\n */\n// eslint-disable-next-line no-unused-vars\nexport type EventListenerFunc<E, CT> = (args: EventListenerArgs<E, CT>) => void;\n\ninterface ListenerRecord<CT> {\n  func: EventListenerFunc<unknown, CT>;\n  phase: string;\n}\n\nexport class EventManager<CT> {\n  private world: World<CT>;\n  // Map where key is Event Class Constructor, value is an array of listeners for that event.\n  private listeners: Map<ClassConstructor<unknown>, ListenerRecord<CT>[]> =\n    new Map();\n  // Queue of events emitted during the current frame.\n  private queue: object[] = [];\n\n  constructor(world: World<CT>) {\n    this.world = world;\n  }\n\n  /**\n   * Registers a listener function to be called when a specific event type is emitted.\n   * @param EventType The class of the event to listen for.\n   * @param func The function to execute when the event is emitted.\n   * @param phase The execution phase during which this listener should be called.\n   */\n  addListener<E>(\n    EventType: ClassConstructor<E>,\n    func: EventListenerFunc<E, CT>,\n    phase: string\n  ): void {\n    if (!this.listeners.has(EventType)) {\n      this.listeners.set(EventType, []);\n    }\n    const listeners = this.listeners.get(EventType);\n    if (listeners) {\n      listeners.push({ func: func as EventListenerFunc<unknown, CT>, phase });\n    }\n  }\n\n  /**\n   * Queues an event to be processed by listeners in the appropriate phase.\n   * @param event An instance of an event class.\n   */\n  emit(event: object): void {\n    this.queue.push(event);\n  }\n\n  /**\n   * Processes all queued events, firing listeners that are registered for the current execution phase.\n   * This is called by the Systems.run() method.\n   * @param phase The current execution phase.\n   */\n  processQueueForPhase(phase: string): void {\n    // Process a copy of the queue, as listeners might emit new events.\n    const eventsToProcess = [...this.queue];\n\n    for (const event of eventsToProcess) {\n      const EventType = event.constructor as ClassConstructor<unknown>;\n      const eventListeners = this.listeners.get(EventType) || [];\n\n      for (const listener of eventListeners) {\n        if (listener.phase === phase) {\n          listener.func({ event: event as unknown, world: this.world });\n        }\n      }\n    }\n  }\n\n  /**\n   * Clears the event queue. This is called at the end of each frame/tick.\n   */\n  clearQueue(): void {\n    this.queue = [];\n  }\n}\n", "// eslint-disable-next-line @typescript-eslint/no-explicit-any, no-unused-vars\ntype ClassConstructor = { new (...args: any[]): any };\n\nexport class ComponentRegistry {\n  private static nextId = 0;\n  private static registry = new Map<ClassConstructor, number>();\n\n  static getId(componentClass: ClassConstructor): number {\n    if (!this.registry.has(componentClass)) {\n      this.registry.set(componentClass, this.nextId++);\n    }\n    return this.registry.get(componentClass) as number;\n  }\n}\n", "import Entity, { EntityId } from './Entity';\nimport ComponentCollection from './ComponentCollection';\nimport { Tag } from './Tag';\nimport { SystemFunc } from './Systems';\nimport DevTools from './DevTools';\nimport Systems from './Systems';\nimport { TrackedCompSymbolKeys } from './TrackedComponent';\nimport { EventListenerFunc, EventManager } from './EventManager';\nimport { ComponentRegistry } from './ComponentRegistry';\nimport { BitSet } from './BitSet';\n\nexport type SerializableClassConstructor<T> = ClassConstructor<T> & {\n  // eslint-disable-next-line no-unused-vars\n  fromJSON?: (data: unknown) => T;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, no-unused-vars\nexport type ClassConstructor<T> = { new (...args: any[]): T };\n\nexport interface ComponentLifecycle<CT> {\n  // eslint-disable-next-line no-unused-vars\n  onAdd?: (args: {\n    world: World<CT>;\n    entity: Entity<CT>;\n    component: CT;\n  }) => void;\n  // eslint-disable-next-line no-unused-vars\n  onRemove?: (args: {\n    world: World<CT>;\n    entity: Entity<CT>;\n    component: CT;\n  }) => void;\n  toJSON?: () => unknown;\n}\n\nexport interface PrefabDefinition<CT> {\n  tags?: Tag[];\n\n  components: CT[];\n}\n\nexport interface TypeMapping {\n  components: Record<string, SerializableClassConstructor<unknown>>;\n  resources: Record<string, SerializableClassConstructor<unknown>>;\n}\n\ninterface SerializedWorld {\n  resources: { name: string; data: unknown }[];\n  entities: {\n    id: EntityId;\n    tags: Tag[];\n    components: { name: string; data: unknown }[];\n  }[];\n}\n\ninterface SystemQuery {\n  mask: BitSet;\n  entities: Set<EntityId>;\n  key: string;\n}\n\nexport default class World<CT> {\n  // Optimized storage: Arrays instead of Maps\n  componentCollections: ComponentCollection<CT>[] = [];\n  entities: Entity<CT>[] = [];\n\n  // Maps a unique query Key (BitSet string) to the Set of Entities that match it.\n  entitiesByQuery: Map<string, Set<EntityId>> = new Map();\n\n  systemQueries: Map<string, SystemQuery> = new Map();\n\n  entitiesByTags: Map<Tag, Set<EntityId>> = new Map();\n\n  entitiesToCreate: Set<Entity<CT>> = new Set();\n  entitiesToDestroy: Set<Entity<CT>> = new Set();\n\n  systems: Systems<CT>;\n  dev: DevTools<CT>;\n  events: EventManager<CT>;\n\n  private nextEntityId = 0;\n  private componentToSystemQueries: Map<string, string[]> = new Map();\n  private resources: Map<ClassConstructor<unknown>, unknown> = new Map();\n  private prefabs: Map<string, PrefabDefinition<CT>> = new Map();\n\n  constructor() {\n    this.dev = new DevTools(this);\n    this.systems = new Systems(this);\n    this.events = new EventManager(this);\n  }\n\n  addSystemListener<E>(\n    EventType: ClassConstructor<E>,\n    listenerFunc: EventListenerFunc<E, CT>,\n    options: { phase?: string } = {}\n  ): this {\n    const { phase = 'Events' } = options;\n    this.events.addListener(EventType, listenerFunc, phase);\n    return this;\n  }\n\n  setResource<T>(resource: T): this {\n    // @ts-ignore\n    this.resources.set(resource.constructor as ClassConstructor<T>, resource);\n    return this;\n  }\n\n  getResource<T>(ResourceType: ClassConstructor<T>): T | undefined {\n    return this.resources.get(ResourceType) as T;\n  }\n\n  hasResource<T>(ResourceType: ClassConstructor<T>): boolean {\n    return this.resources.has(ResourceType);\n  }\n\n  removeResource<T>(ResourceType: ClassConstructor<T>): boolean {\n    return this.resources.delete(ResourceType);\n  }\n\n  registerPrefab(name: string, definition: PrefabDefinition<CT>): this {\n    this.prefabs.set(name, definition);\n    return this;\n  }\n\n  createEntityFromPrefab(\n    name: string,\n    overrides: { [componentName: string]: Partial<CT> } = {}\n  ): Entity<CT> {\n    const prefab = this.prefabs.get(name);\n    if (!prefab) {\n      throw new Error(`Prefab with name \"${name}\" not found.`);\n    }\n\n    const entity = this.createEntity();\n\n    if (prefab.tags) {\n      for (const tag of prefab.tags) {\n        entity.addTag(tag);\n      }\n    }\n\n    for (const prefabComponent of prefab.components) {\n      const componentInstance = JSON.parse(JSON.stringify(prefabComponent));\n      const componentWithConstructor = prefabComponent as CT & {\n        constructor: { prototype: unknown; name: string };\n      };\n      Object.setPrototypeOf(\n        componentInstance,\n        componentWithConstructor.constructor.prototype as object\n      );\n      const componentName = componentWithConstructor.constructor.name;\n\n      if (overrides[componentName]) {\n        Object.assign(componentInstance, overrides[componentName]);\n      }\n\n      entity.add(componentInstance);\n    }\n\n    return entity;\n  }\n\n  setPhaseOrder(order: string[]): this {\n    this.systems.setPhaseOrder(order);\n    return this;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  find = (predicate: (entity: Entity<CT>) => boolean): Entity<CT> | null => {\n    for (const entity of this.entities) {\n      if (entity && predicate(entity)) {\n        return entity;\n      }\n    }\n    return null;\n  };\n\n  // eslint-disable-next-line no-unused-vars\n  findAll = (predicate: (entity: Entity<CT>) => boolean): Entity<CT>[] => {\n    const results: Entity<CT>[] = [];\n    for (const entity of this.entities) {\n      if (entity && predicate(entity)) {\n        results.push(entity);\n      }\n    }\n    return results;\n  };\n\n  locate = (\n    cl: ClassConstructor<CT> | ClassConstructor<CT>[]\n  ): Entity<CT> | null => {\n    for (const entity of this.entities) {\n      if (entity && entity.components.has(cl)) {\n        return entity;\n      }\n    }\n    return null;\n  };\n\n  locateAll = (\n    cl: ClassConstructor<CT> | ClassConstructor<CT>[]\n  ): Entity<CT>[] => {\n    const results: Entity<CT>[] = [];\n    for (const entity of this.entities) {\n      if (entity && entity.components.has(cl)) {\n        results.push(entity);\n      }\n    }\n    return results;\n  };\n\n  grab = <T extends CT>(\n    cl: ClassConstructor<T>\n  ): { entity: Entity<CT>; component: T } | null => {\n    const entity = this.locate(cl);\n\n    if (entity) {\n      const cc =\n        this.componentCollections[entity.id] || new ComponentCollection<CT>();\n\n      const component = cc.get<T>(cl);\n\n      return {\n        entity,\n        component,\n      };\n    }\n\n    return null;\n  };\n\n  grabBy = <T extends CT>(\n    cl: ClassConstructor<T>,\n    // eslint-disable-next-line no-unused-vars\n    predicate: (comp: T) => boolean\n  ): { entity: Entity<CT>; component: T } | null => {\n    const entities = this.locateAll(cl);\n\n    for (const entity of entities) {\n      const cc =\n        this.componentCollections[entity.id] || new ComponentCollection<CT>();\n\n      const component = cc.get<T>(cl);\n\n      if (predicate(component)) {\n        return {\n          component,\n          entity,\n        };\n      }\n    }\n\n    return null;\n  };\n\n  grabAll = <T extends CT>(\n    cl: ClassConstructor<T>\n  ): { entity: Entity<CT>; component: T }[] => {\n    const entities = this.locateAll(cl);\n\n    return entities.map(entity => {\n      return {\n        entity,\n        component: entity.components.get<T>(cl),\n      };\n    });\n  };\n\n  get = <T extends CT>(eid: EntityId, cl: ClassConstructor<T>): T => {\n    const cc = this.componentCollections[eid] || new ComponentCollection<CT>();\n\n    return cc.get<T>(cl);\n  };\n\n  getComponent = <T extends CT>(\n    cl: ClassConstructor<T>,\n    defaultValue?: T\n  ): T | null => {\n    const result = this.grab(cl);\n\n    if (!result) {\n      return defaultValue ? defaultValue : null;\n    }\n\n    return result.component;\n  };\n\n  getTagged = (tag: Tag): Entity<CT> | null => {\n    const tagEntityIds = this.entitiesByTags.get(tag);\n\n    if (tagEntityIds) {\n      const entityId = tagEntityIds.values().next().value;\n\n      if (entityId !== undefined) {\n        const entity = this.entities[entityId];\n        if (entity) return entity;\n      }\n    }\n\n    return null;\n  };\n\n  getAllTagged = (tag: Tag): Entity<CT>[] => {\n    const entities: Entity<CT>[] = [];\n\n    const tagEntityIds = this.entitiesByTags.get(tag);\n\n    if (tagEntityIds) {\n      for (const entityId of tagEntityIds) {\n        const entity = this.entities[entityId];\n        if (entity) {\n          entities.push(entity);\n        }\n      }\n    }\n\n    return entities;\n  };\n\n  add = <T extends CT>(eid: EntityId, component: T): this => {\n    let cc = this.componentCollections[eid];\n\n    if (!cc) {\n      cc = new ComponentCollection<CT>();\n      this.componentCollections[eid] = cc;\n    }\n\n    const entity = this.entities[eid];\n\n    if (!entity) {\n      throw new Error(`world.add: Unable to locate entity with id ${eid}`);\n    }\n\n    // --- BITMASK OPTIMIZATION ---\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const compId = ComponentRegistry.getId((component as any).constructor);\n    entity.componentMask.set(compId);\n\n    cc.add(component);\n\n    // Update Queries\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const componentName = (component as any).constructor.name;\n    const affectedQueries =\n      this.componentToSystemQueries.get(componentName) || [];\n\n    for (const queryKey of affectedQueries) {\n      const query = this.systemQueries.get(queryKey);\n      if (query) {\n        if (entity.componentMask.contains(query.mask)) {\n          query.entities.add(eid);\n        }\n      }\n    }\n\n    // @ts-ignore\n    if (component[TrackedCompSymbolKeys.isTracked]) {\n      // @ts-ignore\n      component[TrackedCompSymbolKeys.setWorld](this);\n      // @ts-ignore\n      component[TrackedCompSymbolKeys.entityIDs].add(eid);\n      // @ts-ignore\n      component[TrackedCompSymbolKeys.onAdd](this, entity);\n    }\n\n    const componentWithLifecycle = component as CT & ComponentLifecycle<CT>;\n    if (componentWithLifecycle.onAdd) {\n      componentWithLifecycle.onAdd({ world: this, entity, component });\n    }\n\n    entity.onComponentAdd({ world: this, component });\n\n    return this;\n  };\n\n  remove = (eid: EntityId, cType: ClassConstructor<CT>): this => {\n    const cc = this.componentCollections[eid];\n    if (!cc) {\n      return this;\n    }\n\n    const componentName = cType.name;\n    if (!cc.hasByName(componentName)) {\n      return this;\n    }\n\n    const component = cc.get(cType);\n    const entity = this.entities[eid];\n    if (!entity) {\n      return this;\n    }\n\n    const componentWithLifecycle = component as CT & ComponentLifecycle<CT>;\n    if (componentWithLifecycle.onRemove) {\n      componentWithLifecycle.onRemove({ world: this, entity, component });\n    }\n\n    // Handle TrackedComponent logic first\n    // @ts-ignore\n    if (component[TrackedCompSymbolKeys.isTracked]) {\n      // @ts-ignore\n      component[TrackedCompSymbolKeys.entityIDs].delete(eid);\n      // @ts-ignore\n      component[TrackedCompSymbolKeys.onRemove](this, entity);\n    }\n\n    const compId = ComponentRegistry.getId(cType);\n    entity.componentMask.clear(compId);\n\n    const affectedQueryKeys =\n      this.componentToSystemQueries.get(componentName) || [];\n\n    for (const queryKey of affectedQueryKeys) {\n      const query = this.systemQueries.get(queryKey);\n      if (query) {\n        query.entities.delete(eid);\n      }\n    }\n\n    cc.remove(cType);\n\n    entity.onComponentRemove({ world: this, component });\n\n    return this;\n  };\n\n  addSystem(\n    cTypes: ClassConstructor<CT>[],\n    systemFunc: SystemFunc<CT>,\n    options: { phase?: string; name?: string } = {}\n  ): this {\n    const cNames = cTypes.map(ct => ct.name).sort();\n    const canonicalKey = cNames.join(',');\n\n    // Create Mask for this System\n    const mask = new BitSet();\n    for (const cType of cTypes) {\n      const id = ComponentRegistry.getId(cType);\n      mask.set(id);\n    }\n\n    // Store Query Info\n    if (!this.systemQueries.has(canonicalKey)) {\n      const entities = new Set<EntityId>();\n      this.systemQueries.set(canonicalKey, {\n        mask,\n        entities,\n        key: canonicalKey,\n      });\n      this.entitiesByQuery.set(canonicalKey, entities);\n    }\n\n    for (const componentName of cNames) {\n      const existingQueries =\n        this.componentToSystemQueries.get(componentName) || [];\n      if (!existingQueries.includes(canonicalKey)) {\n        existingQueries.push(canonicalKey);\n      }\n      this.componentToSystemQueries.set(componentName, existingQueries);\n    }\n\n    this.systems.add(cTypes, systemFunc, canonicalKey, options);\n\n    const query = this.systemQueries.get(canonicalKey);\n    if (!query) {\n      return this;\n    }\n    for (const entity of this.entities) {\n      if (entity && entity.componentMask.contains(mask)) {\n        query.entities.add(entity.id);\n      }\n    }\n\n    return this;\n  }\n\n  registerEntity(entity: Entity<CT>): World<CT> {\n    const cc = new ComponentCollection<CT>();\n\n    this.componentCollections[entity.id] = cc;\n    this.entities[entity.id] = entity;\n\n    this.entitiesToCreate.add(entity);\n\n    entity.onCreate(this);\n\n    return this;\n  }\n\n  clearEntityComponents(entityId: EntityId): this {\n    this.componentCollections[entityId] = new ComponentCollection<CT>();\n\n    for (const query of this.systemQueries.values()) {\n      if (query.entities.has(entityId)) {\n        query.entities.delete(entityId);\n      }\n    }\n\n    return this;\n  }\n\n  createEntity(): Entity<CT> {\n    const entityId = ++this.nextEntityId;\n    const entity = new Entity(this, entityId);\n\n    return entity;\n  }\n\n  destroyEntity(entityId: EntityId): this {\n    // For arrays, we can delete or set to undefined.\n    // Setting to undefined keeps the indices stable.\n    delete this.componentCollections[entityId];\n\n    const entity = this.entities[entityId];\n    if (!entity) {\n      throw new Error(\n        `world.destroyEntity: No entity found. entity id: ${entityId}`\n      );\n    }\n\n    delete this.entities[entityId];\n\n    this.entitiesToCreate.delete(entity);\n    this.entitiesToDestroy.delete(entity);\n\n    for (const query of this.systemQueries.values()) {\n      if (query.entities.has(entityId)) {\n        query.entities.delete(entityId);\n      }\n    }\n\n    for (const [tag, entitySet] of this.entitiesByTags) {\n      if (entitySet.has(entityId)) {\n        entitySet.delete(entityId);\n      }\n\n      if (entitySet.size === 0) {\n        this.entitiesByTags.delete(tag);\n      }\n    }\n\n    return this;\n  }\n\n  toJSON(): SerializedWorld {\n    const serialized: SerializedWorld = {\n      resources: [],\n      entities: [],\n    };\n\n    for (const [constructor, instance] of this.resources.entries()) {\n      const serializableInstance = instance as unknown & {\n        toJSON?: () => unknown;\n      };\n      const data = serializableInstance.toJSON\n        ? serializableInstance.toJSON()\n        : { ...(instance as object) };\n      serialized.resources.push({ name: constructor.name, data });\n    }\n\n    for (const entity of this.entities) {\n      if (!entity) continue;\n\n      const serializedComponents: { name: string; data: unknown }[] = [];\n      const components = this.componentCollections[entity.id];\n\n      if (components) {\n        for (const component of components) {\n          const componentWithToJSON = component as CT & ComponentLifecycle<CT>;\n          const data = componentWithToJSON.toJSON\n            ? componentWithToJSON.toJSON()\n            : { ...component };\n          serializedComponents.push({\n            name: (component as { constructor: { name: string } }).constructor\n              .name,\n            data,\n          });\n        }\n      }\n\n      serialized.entities.push({\n        id: entity.id,\n        tags: Array.from(entity.tags),\n        components: serializedComponents,\n      });\n    }\n\n    return serialized;\n  }\n\n  static fromJSON<CT>(\n    serializedWorld: SerializedWorld,\n    typeMapping: TypeMapping\n  ): World<CT> {\n    const world = new World<CT>();\n\n    for (const res of serializedWorld.resources) {\n      const ResourceClass = typeMapping.resources[res.name];\n      if (!ResourceClass) {\n        throw new Error(\n          `Cannot hydrate resource: Class constructor for \"${res.name}\" not found in typeMapping.resources.`\n        );\n      }\n      let instance: unknown;\n      if (ResourceClass.fromJSON) {\n        instance = ResourceClass.fromJSON(res.data);\n      } else {\n        instance = new ResourceClass();\n        Object.assign(instance as object, res.data);\n      }\n      world.setResource(instance);\n    }\n\n    let maxId = 0;\n    for (const ent of serializedWorld.entities) {\n      if (typeof ent.id === 'number' && ent.id > maxId) {\n        maxId = ent.id;\n      }\n    }\n    world.nextEntityId = maxId;\n\n    for (const ent of serializedWorld.entities) {\n      const entity = new Entity(world, ent.id);\n      world.registerEntity(entity);\n\n      for (const tag of ent.tags) {\n        entity.addTag(tag);\n      }\n\n      for (const comp of ent.components) {\n        const ComponentClass = typeMapping.components[comp.name];\n        if (!ComponentClass) {\n          throw new Error(\n            `Cannot hydrate component: Class constructor for \"${comp.name}\" not found in typeMapping.components.`\n          );\n        }\n        let instance: unknown;\n        if (ComponentClass.fromJSON) {\n          instance = ComponentClass.fromJSON(comp.data);\n        } else {\n          instance = new ComponentClass();\n          Object.assign(instance as object, comp.data);\n        }\n        entity.add(instance as CT);\n      }\n    }\n\n    return world;\n  }\n}\n"],
  "mappings": "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",
  "names": ["isComponentInstance", "Class", "comp", "ComponentCollection", "component", "cl", "func", "c", "isComponentInstance", "updatedComponent", "cType", "comp", "ct", "cTypes", "cName", "obj", "compName", "DevEntity", "entity", "world", "compNames", "systemName", "cNames", "cName", "DevEntity_default", "SimpleFSM", "initialState", "transitions", "data", "checkState", "BitSet", "_BitSet", "size", "index", "elementIndex", "bitIndex", "newSize", "newMask", "other", "len", "i", "otherChunk", "clone", "Entity", "world", "id", "BitSet", "fsmTransition", "ns", "SimpleFSM", "args", "component", "tag", "entitySet", "cType", "ComponentCollection", "cTypes", "cl", "tags", "DevEntity_default", "DevTools", "world", "compsBySystems", "system", "compNames", "e", "DevTools_default", "DEFAULT_PHASE", "Systems", "world", "order", "cTypes", "systemFunc", "canonicalKey", "options", "cNames", "ct", "phase", "optionName", "name", "query", "hasDefaultPhaseSystems", "hasNamedPhaseSystems", "key", "args", "dt", "time", "systemArgs", "runOrder", "defaultPhase", "p", "systemsInPhase", "system", "entityIdSet", "size", "index", "eid", "entity", "components", "TrackedCompSymbolKeys", "createClassInstanceProxyHandlers", "trackedEventHandlers", "updatedProps", "component", "property", "value", "world", "previousVal", "entities", "entity", "trackComponent", "CompClass", "Component", "args", "eid", "EventManager", "world", "EventType", "func", "phase", "listeners", "event", "eventsToProcess", "eventListeners", "listener", "ComponentRegistry", "componentClass", "World", "_World", "DevTools_default", "Systems", "EventManager", "EventType", "listenerFunc", "options", "phase", "resource", "ResourceType", "name", "definition", "overrides", "prefab", "entity", "tag", "prefabComponent", "componentInstance", "componentWithConstructor", "componentName", "order", "predicate", "results", "cl", "component", "ComponentCollection", "entities", "eid", "defaultValue", "result", "tagEntityIds", "entityId", "cc", "compId", "ComponentRegistry", "affectedQueries", "queryKey", "query", "TrackedCompSymbolKeys", "componentWithLifecycle", "cType", "affectedQueryKeys", "cTypes", "systemFunc", "cNames", "ct", "canonicalKey", "mask", "BitSet", "id", "existingQueries", "Entity", "entitySet", "serialized", "constructor", "instance", "serializableInstance", "data", "serializedComponents", "components", "componentWithToJSON", "serializedWorld", "typeMapping", "world", "res", "ResourceClass", "maxId", "ent", "comp", "ComponentClass"]
}
